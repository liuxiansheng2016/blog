<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="preload" href="/blog/_next/static/css/8313f4afdb9eeba6.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/8313f4afdb9eeba6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog/_next/static/chunks/webpack-b3e18345d9c37566.js" defer=""></script><script src="/blog/_next/static/chunks/framework-a4ddb9b21624b39b.js" defer=""></script><script src="/blog/_next/static/chunks/main-11af1931f42805af.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-62ff9594266cbbd0.js" defer=""></script><script src="/blog/_next/static/chunks/392-1648afe4ffecb6c6.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bid%5D-e71390792377508c.js" defer=""></script><script src="/blog/_next/static/0pNFFMvBppFtiuvXtw7Yg/_buildManifest.js" defer=""></script><script src="/blog/_next/static/0pNFFMvBppFtiuvXtw7Yg/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_container__m5jTj"><aside class="Layout_sidebar__x3OPI"><nav><h2>笔记导航</h2><ul><li><div class="Layout_navItem__0Yvho "><a class="Layout_link__nT2lh " href="/blog">首页</a></div></li></ul></nav></aside><main class="Layout_main__bVVJR"><article class="Post_article__hxT42"><h1> <!-- -->算法<!-- --> </h1> <div class="Post_meta__s01mg"><time> <!-- -->2024-10-10<!-- --> </time> </div> <div class="Post_content__bOW5d"><h2 id="每五秒打印一个数字">每五秒打印一个数字</h2>
<p>1 setInterval<br>
<br/>2function print(){<br>
console.log(111);</p>
<p>setTimeOut(print, 5000)<br>
}</p>
<p>Print()</p>
<p>3 function delay(ms) {</p>
<p>return new Promise(resolve => {</p>
<p>setTimeout(() => {</p>
<p>console.log("delay");</p>
<p>resolve();</p>
<p>},ms)</p>
<p>})</p>
<p>}</p>
<p>async function excute(){</p>
<p>while (true) {</p>
<p>await delay(2000);</p>
<p>}</p>
<p>}</p>
<p>excute();</p>
<p>3 function delay(ms) {</p>
<p>return new Promise(resolve => {</p>
<p>setTimeout(() => {</p>
<p>resolve();</p>
<p>},ms)</p>
<p>})</p>
<p>}</p>
<p>async function excute(){</p>
<p>while (true) {</p>
<p>console.log("delay");</p>
<p>await delay(2000);</p>
<p>}</p>
<p>}</p>
<p>excute();</p>
<h2 id="async-函数的实现">async 函数的实现</h2>
<h3>Generator 实现async/await</h3>
<h2 id="输入一个promise和一个时间">输入一个promise和一个时间</h2>
<p>在规定的时间内如果promise的状态为非pending，则返回状态，如果为pending则返回一个新的promise，内容为new Error()</p>
<h2 id="实现promiseall">实现promise.all</h2>
<h2 id="虚拟dom-转换成真实dom">虚拟dom 转换成真实dom</h2>
<h2 id="加密算法">加密算法</h2>
<p>区块链技术依赖于多种加密算法来确保数据的安全性、完整性和不可篡改性。这些加密算法主要用于以下几个方面：</p>
<ol>
<li><strong><strong>哈希函数（Hash Functions）</strong></strong></li>
<li><strong><strong>非对称加密（Asymmetric Encryption，也称为公钥加密）</strong></strong></li>
<li><strong><strong>数字签名（Digital Signatures）</strong></strong></li>
</ol>
<h3><strong>1. 哈希函数（Hash Functions）</strong></h3>
<p>哈希函数是区块链中非常重要的组成部分，用于创建固定长度的输出（称为哈希值或散列），这个输出与输入数据一一对应。任何对输入数据的微小改动都会导致完全不同的哈希值输出，这使得哈希函数非常适合用于验证数据完整性。</p>
<ul>
<li><strong><strong>特性</strong></strong>：
<ul>
<li><strong><strong>确定性</strong></strong>：相同的输入总是产生相同的哈希值。</li>
<li><strong><strong>抗碰撞性</strong></strong>：很难找到两个不同的输入产生相同的哈希值。</li>
<li><strong><strong>单向性</strong></strong>：从哈希值反推出原始输入在计算上是不可行的。</li>
</ul>
</li>
<li><strong><strong>常用哈希算法</strong></strong>：
<ul>
<li><strong><strong>SHA-256</strong></strong>：比特币使用的哈希算法，生成256位（32字节）的哈希值。</li>
<li><strong><strong>Keccak-256</strong></strong>：以太坊使用的哈希算法，同样生成256位的哈希值。</li>
<li><strong><strong>BLAKE2b</strong></strong>：一些区块链项目如Decred选择使用此算法，因为它比SHA-256更快且更安全。</li>
</ul>
</li>
</ul>
<h3><strong>2. 非对称加密（Asymmetric Encryption）</strong></h3>
<p>非对称加密使用一对密钥——公钥和私钥。发送方用接收方的公钥加密消息，只有持有相应私钥的人才能解密该消息。这种机制不仅保证了信息传输的安全性，还支持身份验证。</p>
<p><strong><strong>工作原理</strong></strong>：</p>
<ul>
<li>
<ul>
<li>发送者用接收者的公钥加密消息。
<ul>
<li>接收者用自己的私钥解密消息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><strong>用途</strong></strong>：</p>
<ul>
<li>
<ul>
<li><strong><strong>加密通信</strong></strong>：保护交易内容不被第三方窃取。
<ul>
<li><strong><strong>身份验证</strong></strong>：通过公钥基础设施（PKI）确认用户身份。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><strong>常用算法</strong></strong>：</p>
<ul>
<li>
<ul>
<li><strong><strong>RSA</strong></strong>：广泛应用于互联网安全协议中。
<ul>
<li><strong><strong>Elliptic Curve Cryptography (ECC)</strong></strong>：提供与RSA相同级别的安全性但密钥长度更短，因此效率更高，在移动设备上特别受欢迎。</li>
<li><strong><strong>Ed25519</strong></strong>：一种基于椭圆曲线的签名算法，因其高性能和高安全性而被越来越多的区块链项目采用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><strong>3. 数字签名（Digital Signatures）</strong></h3>
<p>数字签名结合了哈希函数和非对称加密技术，用来证明某条消息确实来自某个特定实体，并且没有被篡改过。具体来说，发送者用自己的私钥对消息的哈希值进行签名，接收者则用发送者的公钥验证签名的有效性。</p>
<p><strong><strong>过程</strong></strong>：</p>
<ul>
<li>
<ul>
<li>发送者计算消息的哈希值，并用其私钥对该哈希值进行加密，形成数字签名。
<ul>
<li>发送者将消息连同数字签名一起发送给接收者。</li>
<li>接收者用发送者的公钥解密数字签名，得到原始哈希值；同时对接收到的消息重新计算哈希值。</li>
<li>如果两个哈希值匹配，则说明消息未被篡改且确实来自声称的发送者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><strong>作用</strong></strong>：</p>
<ul>
<li>
<ul>
<li><strong><strong>不可否认性</strong></strong>：发送者不能否认自己曾经发送过这条消息。
<ul>
<li><strong><strong>完整性</strong></strong>：确保消息在传输过程中没有被修改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><strong>区块链中的应用实例</strong></h3>
<ul>
<li><strong><strong>比特币</strong></strong>：使用 SHA-256 作为哈希函数，ECDSA（椭圆曲线数字签名算法）作为数字签名方案。</li>
<li><strong><strong>以太坊</strong></strong>：早期版本主要依赖 Keccak-256 和 ECDSA，后续版本可能会引入更多先进的加密技术。</li>
<li><strong><strong>其他区块链平台</strong></strong>：根据自身需求选择适合的加密算法组合，例如 Hyperledger Fabric 使用了 BLS 签名等高级特性</li>
</ul>
</div> </article> </main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"算法相关","contentHtml":"\u003ch2 id=\"每五秒打印一个数字\"\u003e每五秒打印一个数字\u003c/h2\u003e\n\u003cp\u003e1 setInterval\u003cbr\u003e\n\u003cbr/\u003e2function print(){\u003cbr\u003e\nconsole.log(111);\u003c/p\u003e\n\u003cp\u003esetTimeOut(print, 5000)\u003cbr\u003e\n}\u003c/p\u003e\n\u003cp\u003ePrint()\u003c/p\u003e\n\u003cp\u003e3 function delay(ms) {\u003c/p\u003e\n\u003cp\u003ereturn new Promise(resolve =\u003e {\u003c/p\u003e\n\u003cp\u003esetTimeout(() =\u003e {\u003c/p\u003e\n\u003cp\u003econsole.log(\"delay\");\u003c/p\u003e\n\u003cp\u003eresolve();\u003c/p\u003e\n\u003cp\u003e},ms)\u003c/p\u003e\n\u003cp\u003e})\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003easync function excute(){\u003c/p\u003e\n\u003cp\u003ewhile (true) {\u003c/p\u003e\n\u003cp\u003eawait delay(2000);\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003eexcute();\u003c/p\u003e\n\u003cp\u003e3 function delay(ms) {\u003c/p\u003e\n\u003cp\u003ereturn new Promise(resolve =\u003e {\u003c/p\u003e\n\u003cp\u003esetTimeout(() =\u003e {\u003c/p\u003e\n\u003cp\u003eresolve();\u003c/p\u003e\n\u003cp\u003e},ms)\u003c/p\u003e\n\u003cp\u003e})\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003easync function excute(){\u003c/p\u003e\n\u003cp\u003ewhile (true) {\u003c/p\u003e\n\u003cp\u003econsole.log(\"delay\");\u003c/p\u003e\n\u003cp\u003eawait delay(2000);\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003eexcute();\u003c/p\u003e\n\u003ch2 id=\"async-函数的实现\"\u003easync 函数的实现\u003c/h2\u003e\n\u003ch3\u003eGenerator 实现async/await\u003c/h3\u003e\n\u003ch2 id=\"输入一个promise和一个时间\"\u003e输入一个promise和一个时间\u003c/h2\u003e\n\u003cp\u003e在规定的时间内如果promise的状态为非pending，则返回状态，如果为pending则返回一个新的promise，内容为new Error()\u003c/p\u003e\n\u003ch2 id=\"实现promiseall\"\u003e实现promise.all\u003c/h2\u003e\n\u003ch2 id=\"虚拟dom-转换成真实dom\"\u003e虚拟dom 转换成真实dom\u003c/h2\u003e\n\u003ch2 id=\"加密算法\"\u003e加密算法\u003c/h2\u003e\n\u003cp\u003e区块链技术依赖于多种加密算法来确保数据的安全性、完整性和不可篡改性。这些加密算法主要用于以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e哈希函数（Hash Functions）\u003c/strong\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e非对称加密（Asymmetric Encryption，也称为公钥加密）\u003c/strong\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e数字签名（Digital Signatures）\u003c/strong\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e1. 哈希函数（Hash Functions）\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e哈希函数是区块链中非常重要的组成部分，用于创建固定长度的输出（称为哈希值或散列），这个输出与输入数据一一对应。任何对输入数据的微小改动都会导致完全不同的哈希值输出，这使得哈希函数非常适合用于验证数据完整性。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e特性\u003c/strong\u003e\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e确定性\u003c/strong\u003e\u003c/strong\u003e：相同的输入总是产生相同的哈希值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e抗碰撞性\u003c/strong\u003e\u003c/strong\u003e：很难找到两个不同的输入产生相同的哈希值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e单向性\u003c/strong\u003e\u003c/strong\u003e：从哈希值反推出原始输入在计算上是不可行的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e常用哈希算法\u003c/strong\u003e\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eSHA-256\u003c/strong\u003e\u003c/strong\u003e：比特币使用的哈希算法，生成256位（32字节）的哈希值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eKeccak-256\u003c/strong\u003e\u003c/strong\u003e：以太坊使用的哈希算法，同样生成256位的哈希值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eBLAKE2b\u003c/strong\u003e\u003c/strong\u003e：一些区块链项目如Decred选择使用此算法，因为它比SHA-256更快且更安全。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e2. 非对称加密（Asymmetric Encryption）\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e非对称加密使用一对密钥——公钥和私钥。发送方用接收方的公钥加密消息，只有持有相应私钥的人才能解密该消息。这种机制不仅保证了信息传输的安全性，还支持身份验证。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e工作原理\u003c/strong\u003e\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e发送者用接收者的公钥加密消息。\n\u003cul\u003e\n\u003cli\u003e接收者用自己的私钥解密消息。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e用途\u003c/strong\u003e\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e加密通信\u003c/strong\u003e\u003c/strong\u003e：保护交易内容不被第三方窃取。\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e身份验证\u003c/strong\u003e\u003c/strong\u003e：通过公钥基础设施（PKI）确认用户身份。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e常用算法\u003c/strong\u003e\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eRSA\u003c/strong\u003e\u003c/strong\u003e：广泛应用于互联网安全协议中。\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eElliptic Curve Cryptography (ECC)\u003c/strong\u003e\u003c/strong\u003e：提供与RSA相同级别的安全性但密钥长度更短，因此效率更高，在移动设备上特别受欢迎。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eEd25519\u003c/strong\u003e\u003c/strong\u003e：一种基于椭圆曲线的签名算法，因其高性能和高安全性而被越来越多的区块链项目采用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e3. 数字签名（Digital Signatures）\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e数字签名结合了哈希函数和非对称加密技术，用来证明某条消息确实来自某个特定实体，并且没有被篡改过。具体来说，发送者用自己的私钥对消息的哈希值进行签名，接收者则用发送者的公钥验证签名的有效性。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e过程\u003c/strong\u003e\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e发送者计算消息的哈希值，并用其私钥对该哈希值进行加密，形成数字签名。\n\u003cul\u003e\n\u003cli\u003e发送者将消息连同数字签名一起发送给接收者。\u003c/li\u003e\n\u003cli\u003e接收者用发送者的公钥解密数字签名，得到原始哈希值；同时对接收到的消息重新计算哈希值。\u003c/li\u003e\n\u003cli\u003e如果两个哈希值匹配，则说明消息未被篡改且确实来自声称的发送者。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e作用\u003c/strong\u003e\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e不可否认性\u003c/strong\u003e\u003c/strong\u003e：发送者不能否认自己曾经发送过这条消息。\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e完整性\u003c/strong\u003e\u003c/strong\u003e：确保消息在传输过程中没有被修改。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003e区块链中的应用实例\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e比特币\u003c/strong\u003e\u003c/strong\u003e：使用 SHA-256 作为哈希函数，ECDSA（椭圆曲线数字签名算法）作为数字签名方案。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e以太坊\u003c/strong\u003e\u003c/strong\u003e：早期版本主要依赖 Keccak-256 和 ECDSA，后续版本可能会引入更多先进的加密技术。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e其他区块链平台\u003c/strong\u003e\u003c/strong\u003e：根据自身需求选择适合的加密算法组合，例如 Hyperledger Fabric 使用了 BLS 签名等高级特性\u003c/li\u003e\n\u003c/ul\u003e\n","h2Titles":[{"title":"每五秒打印一个数字","id":"每五秒打印一个数字"},{"title":"async 函数的实现","id":"async-函数的实现"},{"title":"输入一个promise和一个时间","id":"输入一个promise和一个时间"},{"title":"实现promise.all","id":"实现promiseall"},{"title":"虚拟dom 转换成真实dom","id":"虚拟dom-转换成真实dom"},{"title":"加密算法","id":"加密算法"}],"title":"算法","date":"2024-10-10","description":"这里会总结算法相关的内容"},"allPostsData":[{"id":"前端基础","title":"前端基础","date":"2025-1-18","description":"内容包括一些前端的基础理论","h2Titles":[{"title":"HTML","id":"html"},{"title":"CSS","id":"css"},{"title":"less和sass","id":"less和sass"},{"title":"Script","id":"script"},{"title":"Jquery","id":"jquery"},{"title":"HTML5","id":"html5"},{"title":"BootStrap","id":"bootstrap"},{"title":"三层架构","id":"三层架构"},{"title":"MVC","id":"mvc"},{"title":"AngularJS","id":"angularjs"},{"title":"跨域请求","id":"跨域请求"},{"title":"D3","id":"d3"},{"title":"JS","id":"js"},{"title":"Aurelia","id":"aurelia"},{"title":"ES6","id":"es6"},{"title":".NET","id":"net"},{"title":"Webpack","id":"webpack"},{"title":"C#","id":"c"},{"title":"Webpack 配置","id":"webpack-配置"},{"title":"Gulp","id":"gulp"},{"title":"协议","id":"协议"},{"title":"网络安全","id":"网络安全"},{"title":"JS函数式编程","id":"js函数式编程"},{"title":"代码简洁","id":"代码简洁"},{"title":"前端单元测试","id":"前端单元测试"},{"title":"SSR","id":"ssr"},{"title":"SPA","id":"spa"},{"title":"模式","id":"模式"},{"title":"数据结构","id":"数据结构"},{"title":"Git命令","id":"git命令"},{"title":"使用 PRPL 模式应用即时加载","id":"使用-prpl-模式应用即时加载"},{"title":"面向对象","id":"面向对象"},{"title":"Animation","id":"animation"},{"title":"Flex布局","id":"flex布局"},{"title":"Flutter","id":"flutter"},{"title":"JSBridge","id":"jsbridge"},{"title":"Serverless","id":"serverless"},{"title":"精读前后端渲染之争","id":"精读前后端渲染之争"},{"title":"事件驱动和数据驱动","id":"事件驱动和数据驱动"},{"title":"IndexDB 实践","id":"indexdb-实践"},{"title":"Blob","id":"blob"},{"title":"Docker","id":"docker"},{"title":"Responsive/images","id":"responsiveimages"},{"title":"Rem/em","id":"remem"},{"title":"Learnsite","id":"learnsite"},{"title":"LeetCode","id":"leetcode"},{"title":"SQL","id":"sql"},{"title":"Express","id":"express"},{"title":"MySQL","id":"mysql"},{"title":"代理服务器","id":"代理服务器"},{"title":"解释性语言和编译型语言","id":"解释性语言和编译型语言"},{"title":"空间复杂度和时间复杂度","id":"空间复杂度和时间复杂度"},{"title":"Electron","id":"electron"},{"title":"可视化","id":"可视化"},{"title":"编程","id":"编程"},{"title":"计算机基础","id":"计算机基础"},{"title":"缓存","id":"缓存"}]},{"id":"TypeScipt","title":"Typescript","date":"2025-1-11","description":"Js的超集，面向对象的编程语言，包含类和接口的概念","h2Titles":[{"title":"为什么推荐使用TS","id":"为什么推荐使用ts"},{"title":"类型检查","id":"类型检查"},{"title":"Const","id":"const"},{"title":"元组类型tuple","id":"元组类型tuple"},{"title":"枚举","id":"枚举"},{"title":"类","id":"类"},{"title":"接口","id":"接口"},{"title":"interface 和 type 的区别","id":"interface-和-type-的区别"},{"title":"泛型","id":"泛型"},{"title":"类型断言","id":"类型断言"},{"title":"配置tsconfig.json","id":"配置tsconfigjson"},{"title":"数组的类型","id":"数组的类型"},{"title":"重载","id":"重载"},{"title":"重写","id":"重写"},{"title":"三斜线指令","id":"三斜线指令"},{"title":"Mixin","id":"mixin"}]},{"id":"React","title":"React","date":"2025-1-10","description":"","h2Titles":[{"title":"基本写法","id":"基本写法"},{"title":"Dom diff","id":"dom-diff"},{"title":"React 特点","id":"react-特点"},{"title":"虚拟 dom 和真实 dom","id":"虚拟-dom-和真实-dom"},{"title":"组件","id":"组件"},{"title":"元素","id":"元素"},{"title":"生命周期","id":"生命周期"},{"title":"ReactDOM","id":"reactdom"},{"title":"ReactDOMServer","id":"reactdomserver"},{"title":"ReactTestUtils","id":"reacttestutils"},{"title":"Hook","id":"hook"},{"title":"Redux","id":"redux"},{"title":"问题","id":"问题"},{"title":"Fiber","id":"fiber"},{"title":"useImperativeHandle","id":"useimperativehandle"},{"title":"BrowserRouter 和 HashRouter","id":"browserrouter-和-hashrouter"},{"title":"React 服务端渲染（Server-Side Rendering, SSR）","id":"react-服务端渲染server-side-rendering-ssr"},{"title":"Next.js 服务端渲染的基本步骤","id":"nextjs-服务端渲染的基本步骤"},{"title":"Navigate","id":"navigate"},{"title":"搭建步骤","id":"搭建步骤"},{"title":"React","id":"react"}]},{"id":"Angular","title":"Angular","date":"2025-1-10","description":"Angular 是一个 Web 框架，能够帮助开发者构建快速、可靠的应用。","h2Titles":[{"title":"模块","id":"模块"},{"title":"数据传输","id":"数据传输"},{"title":"装饰器 decorator","id":"装饰器-decorator"},{"title":"依赖注入（Dependency Injection, DI）模式","id":"依赖注入dependency-injection-di模式"},{"title":"providedIn: 'root'","id":"providedin-root"},{"title":"设计模式","id":"设计模式"},{"title":"路由","id":"路由"},{"title":"EventEmitter","id":"eventemitter"},{"title":"视图封装（View Encapsulation）","id":"视图封装view-encapsulation"},{"title":"变更检测","id":"变更检测"},{"title":"app.module.ts根模块文件","id":"appmodulets根模块文件"},{"title":"Angular CDK","id":"angular-cdk"},{"title":"Angular 指令","id":"angular-指令"},{"title":"应用启动时执行初始化逻辑","id":"应用启动时执行初始化逻辑"},{"title":"注册拦截器","id":"注册拦截器"},{"title":"HttpClient","id":"httpclient"},{"title":"国际化","id":"国际化"},{"title":"@ngmodule","id":"ngmodule"},{"title":"Angular CDK","id":"angular-cdk"},{"title":"Reactive Forms","id":"reactive-forms"},{"title":"项目结构","id":"项目结构"},{"title":"常见用法","id":"常见用法"},{"title":"@Optional() @SkipSelf()","id":"optional-skipself"},{"title":"Rxjs","id":"rxjs"}]},{"id":"算法相关","title":"算法","date":"2024-10-10","description":"这里会总结算法相关的内容","h2Titles":[{"title":"每五秒打印一个数字","id":"每五秒打印一个数字"},{"title":"async 函数的实现","id":"async-函数的实现"},{"title":"输入一个promise和一个时间","id":"输入一个promise和一个时间"},{"title":"实现promise.all","id":"实现promiseall"},{"title":"虚拟dom 转换成真实dom","id":"虚拟dom-转换成真实dom"},{"title":"加密算法","id":"加密算法"}]},{"id":"Node","title":"Node","date":"2024-03-14","description":"Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，用于在服务器端运行 JavaScript 代码。","h2Titles":[{"title":"Express","id":"express"},{"title":"Communication","id":"communication"},{"title":"I/O","id":"io"},{"title":"Synchronous and Asynchronous","id":"synchronous-and-asynchronous"},{"title":"Eventloop","id":"eventloop"},{"title":"V8","id":"v8"},{"title":"FS","id":"fs"},{"title":"Script","id":"script"},{"title":"HTTP","id":"http"},{"title":"mongoDB","id":"mongodb"},{"title":"Template engine","id":"template-engine"},{"title":"JWT","id":"jwt"},{"title":"Passport.js","id":"passportjs"},{"title":"OAuth","id":"oauth"},{"title":"Node API retry","id":"node-api-retry"},{"title":"Others","id":"others"}]}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"算法相关"},"buildId":"0pNFFMvBppFtiuvXtw7Yg","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>