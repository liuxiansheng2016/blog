<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="preload" href="/blog/_next/static/css/8313f4afdb9eeba6.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/8313f4afdb9eeba6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog/_next/static/chunks/webpack-b3e18345d9c37566.js" defer=""></script><script src="/blog/_next/static/chunks/framework-a4ddb9b21624b39b.js" defer=""></script><script src="/blog/_next/static/chunks/main-11af1931f42805af.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-62ff9594266cbbd0.js" defer=""></script><script src="/blog/_next/static/chunks/392-1648afe4ffecb6c6.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bid%5D-86d4fb3b6bf50b40.js" defer=""></script><script src="/blog/_next/static/ioEOhEUsxyZDSqw7qI6q_/_buildManifest.js" defer=""></script><script src="/blog/_next/static/ioEOhEUsxyZDSqw7qI6q_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_container__m5jTj"><aside class="Layout_sidebar__x3OPI"><nav><h2>博客导航</h2><ul><li><div class="Layout_navItem__0Yvho "><a class="Layout_link__nT2lh " href="/blog">首页</a></div></li></ul></nav></aside><main class="Layout_main__bVVJR"><article class="Post_article__hxT42"><h1> <!-- -->Angular<!-- --> </h1> <div class="Post_meta__s01mg"><time> <!-- -->2025-1-10<!-- --> </time> </div> <div class="Post_content__bOW5d"><h1>Angular</h1>
<h2 id="模块">模块</h2>
<p>Angular 应用程序由多个模块组成，每个模块负责处理特定的功能或一组相关的功能</p>
<h3>根模块</h3>
<ul>
<li>每个 Angular 应用程序至少有一个根模块，通常命名为 AppModule。</li>
</ul>
<h4><strong>1.2 根模块的属性</strong></h4>
<ul>
<li><strong>declarations</strong>: 声明属于该模块的组件、指令和管道。</li>
<li><strong>imports</strong>: 导入其他模块，以便在当前模块中使用它们的导出内容。</li>
<li><strong>providers</strong>: 注册服务提供者，使其在模块范围内可用。</li>
<li><strong>bootstrap</strong>: 指定应用程序启动时应该引导的根组件</li>
</ul>
<h3>Feature modules</h3>
<ul>
<li>特性模块用于组织与特定功能相关的组件、服务、指令等。</li>
</ul>
<h3>共享模块（Shared Module）</h3>
<ul>
<li>共享模块包含可以在多个特性模块中复用的组件、指令和服务。</li>
</ul>
<h3>core</h3>
<ul>
<li>通常包含核心模块和服务，如全局服务、拦截器等。。</li>
</ul>
<p>路由懒加载模块（Lazy-Loaded Module）</p>
<p>loadChildren: () => import('./product/product.module').then(m => m.ProductModule)</p>
<p>如果你的功能模块是通过路由懒加载的方式引入的，那么你不需要直接在 AppModule 中导入这些模块。相反，你应该在路由配置中定义它们。</p>
<h3>Standalone Components</h3>
<p>它允许开发者创建不依赖于 NgModule 的组件、指令和管道。这意味着组件可以直接在其他组件中使用，而不需要通过 NgModule 进行声明和导出</p>
<h2 id="数据传输">数据传输</h2>
<h3></h3>
<p>1父到子</p>
<ol>
<li>输入属性（@Input）</li>
</ol>
<h3>2子到父</h3>
<p>使用 @Output 装饰器可以在子组件向父组件传递事件。子组件通过 EventEmitter 发出事件</p>
<h3>3. 服务（Services）</h3>
<p>使用服务可以在多个组件之间共享数据。服务可以通过依赖注入（DI）系统在组件中注入，并提供数据和方法。</p>
<h3>4. 路由参数（Route Parameters）</h3>
<h3></h3>
<p>5 storage</p>
<h3>6 RXjs 发布订阅</h3>
<h2 id="装饰器-decorator">装饰器 decorator</h2>
<p>装饰器（Decorators）是一种元编程工具，用于修改或注解类、方法、属性和参数</p>
<h3>类装饰器</h3>
<p>@Component</p>
<p>用于定义 Angular 组件。组件是 Angular 应用的基本构建块，包含模板、样式和类。</p>
<p>@NgModule</p>
<p>定义模块。</p>
<p>@directive<br>
用于定义指令。指令用于在模板中添加行为。</p>
<p>@Injectable</p>
<p>用于定义服务。服务通常用于提供可重用的功能，如数据访问、业务逻辑等。</p>
<h3>属性装饰器</h3>
<p>@Input / @output</p>
<p>定义输入/输出属性</p>
<p>允许父组件向子组件传递数据。/ 允许父组件向子组件传递数据。</p>
<p>@ViewChild</p>
<p>用于获取组件或指令的实例。</p>
<h3>方法装饰器</h3>
<p>@HostListener</p>
<p>用于在指令或组件中监听宿主元素的事件。</p>
<h3>怎么自定义装饰器</h3>
<p>装饰器的结构</p>
<p>装饰器函数接受一个或多个参数，具体取决于装饰器的类型：</p>
<ul>
<li><strong><strong>类装饰器</strong></strong>：接受一个参数，即类的构造函数。</li>
<li><strong><strong>属性装饰器</strong></strong>：接受两个参数，即目标对象（类的原型或类本身）和属性名。</li>
<li><strong><strong>方法装饰器</strong></strong>：接受三个参数，即目标对象（类的原型或类本身）、方法名和方法描述符。</li>
<li><strong><strong>参数装饰器</strong></strong>：接受三个参数，即目标对象（类的原型或类本身）、方法名或属性名和参数索引。</li>
</ul>
<p>装饰器的执行时机</p>
<p>装饰器在编译时被调用，而不是在运行时。这意味着装饰器可以用来修改类的定义，而不会影响运行时的性能。</p>
<p>装饰器的返回值</p>
<ul>
<li><strong><strong>类装饰器</strong></strong>：可以返回一个新的构造函数，以替换原来的类。</li>
<li><strong><strong>方法装饰器</strong></strong>：可以返回一个新的方法描述符，以替换原来的方法。</li>
<li><strong><strong>属性装饰器</strong></strong>：通常不返回值，因为它们主要用于修改属性的行为。</li>
<li><strong><strong>参数装饰器</strong></strong>：通常不返回值，因为它们主要用于添加元数据。</li>
</ul>
<h2 id="依赖注入dependency-injection-di模式">依赖注入（Dependency Injection, DI）模式</h2>
<p>Angular 的依赖注入系统是其核心特性之一。通过依赖注入，组件和服务可以轻松地获 取所需的依赖项，而不需要手动实例化对象。</p>
<h2 id="providedin-root">providedIn: 'root'</h2>
<p>providedIn: 'root': 这个选项告诉 Angular，在根注入器中提供这个服务。这意味着服务在整个应用程序中都是单例的，可以在任何组件中注入和使用。</p>
<p>@Injectable() 是 Angular 中的一个装饰器，用于标记一个类为可注入的服务。</p>
<h3>Injectable</h3>
<h3>构造函数注入</h3>
<p>在 Angular 中，依赖项通常是通过构造函数注入的。Angular 的编译器会分析构造函数参数，并从 DI 系统中获取相应的依赖项。</p>
<h3>生命周期钩子和注入</h3>
<h3>@Injectable() 和 @Inject</h3>
<ul>
<li>@Injectable() 是 Angular 中的一个装饰器，用于标记一个类为可注入的服务。</li>
</ul>
<p><strong>@Inject <strong>装饰器</strong></strong>：</p>
<ul>
<li><strong><strong>非类令牌</strong></strong>：它特别适用于注入非类令牌，如 InjectionToken 或原始类型（例如字符串、数字）。</li>
<li><strong><strong>显式注入</strong></strong>：它使依赖注入更加明确和清晰。
<ul>
<li>假设你有两个不同版本的 LoggerService，但它们都实现了同一个接口 ILoggerService。在这种情况下，你可以使用 @Inject 来明确指定要注入哪一个具体的实现。</li>
</ul>
</li>
</ul>
<p><strong>InjectionToken</strong>：用于创建标识符，以便在依赖注入系统中注入非类类型的值。</p>
<ul>
<li><strong><strong>注入非类类型的值</strong></strong>：通过 @Inject 装饰器和 InjectionToken 来实现。</li>
</ul>
<h3>注入令牌</h3>
<h2 id="设计模式">设计模式</h2>
<p><a href="https://zhuanlan.zhihu.com/p/672502223">https://zhuanlan.zhihu.com/p/672502223</a></p>
<h3>行为型设计模式</h3>
<p>描述多个类或对象之间怎样==相互协作==共同完成单个对象都无法单独完成的任务</p>
<h4>1 模版方法模式</h4>
<p>描述： 模板方法模式的核心思想是封装行为中的不变部分，同时允许可变部分通过子类来进行扩展。</p>
<p>在前端开发中，模板方法模式通常用于处理页面的渲染和事件处理。例如，我们可以定义一个基础的页面渲染算法，并在其中定义一些抽象方法，如初始化数据、绑定事件、渲染模板等，然后在子类中实现这些具体操作。这样可以使得我们在开发页面时，只需要关注具体的业务逻辑，而不用过多关注页面的渲染细节。</p>
<p>Angular 的生命周期钩子（如 ngOnInit, ngOnDestroy 等）采用了模板方法模式。这些钩子方法在组件的生命周期中自动调用，开发者可以在这些方法中添加自定义逻辑。</p>
<h4>2观察者模式（Observer Pattern）</h4>
<p>Angular 广泛使用 RxJS 库来实现观察者模式。RxJS 提供了 Observable 和 Subject 等类，用于处理异步数据流和事件。</p>
<p>在 RxJS 中，观察者模式通过 Observable 和 Observer 来实现。</p>
<ul>
<li><strong><strong>Observable（可观察对象）</strong></strong>：一个可以发送数据流的对象。它可以发送多种类型的通知，包括 next（发送数据）、error（发送错误）和 complete（发送完成通知）。</li>
<li><strong><strong>Observer（观察者）</strong></strong>：一个可以接收 Observable 发送的通知的对象。它包含三个回调函数：next、error 和 complete</li>
</ul>
<h5>发布-订阅模式</h5>
<p>Subject 类实现了发布订阅模式。Subject 是一个特殊的 Observable，它既可以作为 Observable 来订阅，也可以作为 Observer 来接收数据。</p>
<h4>3 策略模式</h4>
<p>策略模式用于定义一系列算法，并将每一个算法封装起来，使它们可以互换。Angular 中的路由守卫（Guards）就是一个典型的例子</p>
<h3><strong><a href="https://zhida.zhihu.com/search?content_id=237574615&#x26;content_type=Article&#x26;match_order=1&#x26;q=%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&#x26;zhida_source=entity%22%20%5Ct%20%22https://zhuanlan.zhihu.com/p/_blank">创建型设计模式</a></strong></h3>
<h4>1 单例模式（Singleton Pattern）</h4>
<p>Angular 的服务默认是单例的，即在整个应用中只有一个实例。这通过在服务的 @Injectable 装饰器中设置 providedIn: 'root' 来实现。</p>
<h4>2工厂模式（Factory Pattern）</h4>
<p>描述：它是专门定义一个类，依据参数的不同，来负责创建其它类的实例，被创建的实例通常都具有共同的父类</p>
<ol>
<li><strong><strong>创建服务</strong></strong>：定义你需要创建的不同服务。</li>
<li><strong><strong>创建工厂函数</strong></strong>：编写一个工厂函数，根据条件返回不同的服务实例。</li>
<li><strong><strong>注册提供者</strong></strong>：在模块中注册工厂提供者。</li>
<li><strong><strong>在组件中使用服务</strong></strong>：在组件中注入并使用服务。</li>
</ol>
<h6>简单工厂</h6>
<p>简单工厂模式是最基本的形式</p>
<p>简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。</p>
<p>简单工厂模式（Simple Factory Pattern）也称为静态工厂模式，它是专门定义一个类，依据参数的不同，来负责创建其它类的实例，被创建的实例通常都具有共同的父类。之所以称作静态工厂模式，</p>
<p>假设我们有一个应用，需要创建不同类型的日志记录器（例如，文件日志记录器和数据库日志记录器）。</p>
<h6>工厂方法</h6>
<p>定义了一个创建对象的抽象接口（类或接口中的方法）==并不是代码中的interface==，但由子类决定要实例化的类 是哪一个。工厂方法把实例化推迟到子类</p>
<p>提供一个接口，让子类决定实例化哪一个类。</p>
<h6>抽象工厂</h6>
<ul>
<li><strong><strong>工厂方法模式</strong></strong>适合于创建单一类型的产品，通过子类来决定具体的实现。</li>
<li><strong><strong>抽象工厂模式</strong></strong>适合于创建一系列相关的产品，通过具体的工厂类来创建这些产品。</li>
</ul>
<h3>结构型设计模式</h3>
<h4>1代理模式</h4>
<p>描述：当我们想要对一个业务类进行某些横切性的增强时，例如：增加请求与响应 的日志、增加权限校验、增加远程请求对象封装等等。我们可以采用代理模式去实现， 而不需要修改原有的类。</p>
<h4>2组合模式</h4>
<p>描述：用于将对象组合成树形结构以表示“部分-整体”的层次结构。</p>
<p>在 Angular 中，你可以利用组合模式来构建复杂的 UI 组件或数描述：它允许向一个现有的对象动态地添加新的功能，同时不改变其结构。它是继承的一种替代方案，可以实现在运行时动态地扩展对象的行为，而无需修改原有代码。</p>
<p>假设我们要构建一个简单的文件系统，其中包含文件和文件夹。文件夹可以包含文件和其他文件夹，形成一个树形结构。</p>
<p>1、Component：组合模式中的“根节点”，可以是接口、抽象类、普通类，该类中定义了其子类的所有共性内容，并且该类中还存在着用于访问和管理它子部件的方法。</p>
<p>2、Leaf：组合中的叶子节点，也就是最末端的节点，该节点下不会再有子节点。</p>
<p>3、Composite：非叶子节点，它的作用是存储子部件，并且在Composite中实现了对子部件的相关操作。</p>
<h4>3装饰器模式（Decorator Pattern）</h4>
<p>用于修改或注解类、方法、属性和参数</p>
<h4>4适配器模式</h4>
<p>模式描述：适配器模式允许你将一个类的接口转换成客户端期望的另一个接口。在 Angular 中，你可以使用适配器模式来处理不同数据源的格式转换。</p>
<h2 id="路由">路由</h2>
<ol>
<li><strong><strong>路由（Routes）</strong></strong>：定义了 URL 与组件之间的映射关系。</li>
<li><strong><strong>路由模块（RouterModule）</strong></strong>：用于配置路由的模块。</li>
<li><strong><strong>路由器（Router）</strong></strong>：负责根据当前 URL 导航到相应的组件。</li>
<li><strong><strong>路由出口（RouterOutlet）</strong></strong>：用于显示匹配到的组件。</li>
<li><strong><strong>路由参数（Route Parameters）</strong></strong>：可以从 URL 中提取动态参数。</li>
<li><strong><strong>路由守卫（Route Guards）</strong></strong>：用于控制路由的访问权限，如登录验证、权限检查等</li>
</ol>
<h3>RouterModule.forRoot</h3>
<p>RouterModule.forRoot 是配置 Angular 应用程序路由的核心方法</p>
<h3>使用provideRouter</h3>
<ul>
<li>withInMemoryScrolling()：启用内存滚动恢复，确保用户在导航时保持滚动位置。</li>
<li>withDebugTracing()：启用路由调试跟踪，有助于调试路由问题。</li>
</ul>
<h2 id="eventemitter">EventEmitter</h2>
<p>EventEmitter 的基本原理是观察者模式（Observer Pattern）。观察者模式定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</p>
<p>在 Angular 中，EventEmitter 主要用于父子组件之间的通信。以下是一些关键点：</p>
<h4>定义 EventEmitter</h4>
<p>使用 @Output 装饰器将 EventEmitter 标记为输出属性。</p>
<p>EventEmitter 是一个 RxJS 的 Subject，它可以用来发射事件。</p>
<h4>发射事件</h4>
<p>通过调用 emit 方法来发射事件，并传递事件数据。</p>
<h4>监听事件</h4>
<p>父组件通过模板绑定来监听子组件的 EventEmitter 事件。</p>
<h4>代码实现</h4>
<p>1 EventEmitter 类<br>
继承自 RxJS 的 Subject 类。Subject 是一个特殊的 Observable，它既是 Observer 又是 Observable，可以用来在多个订阅者之间共享数据。</p>
<p>2 @Output 装饰器</p>
<p>@Output 装饰器用于标记一个属性为输出属性，这样 Angular 可以在编译时识别并处理它</p>
<p>3事件监听</p>
<p>在父组件中，通过模板绑定来监听子组件的 EventEmitter 事件。</p>
<h2 id="视图封装view-encapsulation">视图封装（View Encapsulation）</h2>
<p>用于控制组件样式的可见性和作用域。Angular 提供了三种视图封装模式，</p>
<h5>1.1 Emulated（模拟）</h5>
<p>这是默认的视图封装模式。在这种模式下，Angular 会模拟 Shadow DOM 的行为，通过为组件的样式添加唯一的选择器前缀，确保组件的样式不会影响其他组件。</p>
<h5>1.2 None（无）</h5>
<p>在这种模式下，组件的样式将直接应用于全局样式表，没有任何作用域限制。这意味着组件的样式可能会与其他组件的样式发生冲突。</p>
<h5><strong>1.3 ShadowDom（Shadow DOM）</strong></h5>
<p>在这种模式下，组件的样式将完全封装在 Shadow DOM 中，确保组件的样式不会影响其他组件，也不会被其他组件的样式所影响。这种模式需要浏览器支持 Shadow DOM。</p>
<h2 id="变更检测">变更检测</h2>
<h3>默认</h3>
<p>默认策略是最常用的策略，Angular 会自动检测组件及其子组件的所有变化</p>
<h3>Onpush</h3>
<p>22.2 OnPush 策略</p>
<p>OnPush 策略是一种优化策略，适用于纯组件（即组件的输出只依赖于输入）。启用 OnPush 策略后，Angular 只在以下情况下才会检查组件的变更：</p>
<ul>
<li>组件的输入属性发生变化</li>
<li>组件接收到新的事件（如 @Input、@Output）</li>
<li>组件内的异步操作完成（如 Promise、Observable）</li>
<li>通过 ChangeDetectorRef.markForCheck</li>
</ul>
<p>要启用 OnPush 策略，可以在组件装饰器中设置 changeDetection 属性：</p>
<p>Default ：</p>
<p>这是默认的变更检测策略。每次事件触发时，Angular 会检查所有组件。</p>
<p>适用于大多数情况，但可能会导致性能问题，特别是在大型应用中。</p>
<p>OnPush：</p>
<p>仅在输入属性（@Input）发生变化或事件触发时进行变更检测。</p>
<p>适用于纯组件（没有副作用的组件），可以提高性能。</p>
<p>ChangeDetectorRef 提供了几种方法来管理变更检测过程：</p>
<p>ChangeDetectorRef 是 Angular 中一个非常重要的类，它提供了对组件变更检测机制的细粒度控制。</p>
<p>markForCheck()：当使用 OnPush 策略时，如果组件的输入属性没有发生变化，但你仍然希望该组件及其祖先组件被检查，则可以调用此方法。这将使得即使没有触发器，也会检查该组件（markForCheck() 不会立即触发变更检测，而是将当前组件及所有父组件标记为需要检测的状态。这意味着如果一个组件或其某个祖先组件使用了 OnPush 策略，调用 markForCheck() 后，Angular 将会在下一次全局变更检测时重新评估这些组件的状态，）</p>
<p>detach()：从变更检测树中移除当前组件的变更检测器。这意味着该组件及其子组件将不再执行变更检测，直到重新附加为止。这对于避免不必要的变更检测非常有用，特别是在处理大量数据或复杂计算时8。</p>
<p>reattach()：将之前分离出去的变更检测器重新添加回变更检测树中，从而使组件能够再次参与变更检测流程。通常与 detach() 一起使用，以实现局部变更检测8。</p>
<p>detectChanges()：强制立即对该组件及其所有子组件执行一次变更检测。这对于确保视图及时反映最新的数据状态特别有帮助，尤其是在异步操作完成之后1。</p>
<p>checkNoChanges()：用于调试目的，检查是否存在未预期的状态更改。它会抛出错误，如果发现任何脏值（即未经处理的数据变更）。这个方法在开发阶段很有用，但在生产环境中应该谨慎使用，因为它可能会导致性能问题8</p>
<h2 id="appmodulets根模块文件">app.module.ts根模块文件</h2>
<h2 id="angular-cdk">Angular CDK</h2>
<p>Angular CDK (Component Dev Kit) 是 Angular 团队提供的一套工具和构建块，旨在帮助开发者更轻松地创建高质量的 Angular 组件。CDK 不是一个独立的库，而是作为 @angular/cdk 包的一部分发布，它提供了许多底层功能，这些功能在 Angular Material 中被广泛使用，但也可以独立于 Material 使用。</p>
<h3><strong>主要特点</strong></h3>
<p><strong><strong>基础组件</strong></strong>：</p>
<ul>
<li>
<ol>
<li>CDK 提供了一些基础组件，如 Overlay、Portal、Scrolling 等，这些组件可以用来构建复杂的 UI 组件。</li>
<li>例如，Overlay 可以用来创建浮动面板（如对话框、弹出菜单等），而 Portal 可以用来将内容动态插入到 DOM 中。</li>
</ol>
</li>
</ul>
<h2 id="angular-指令">Angular 指令</h2>
<p>Angular 指令是 Angular 框架中的一个重要概念，它们允许你将行为附加到 DOM 元素上。指令可以用来操作 DOM、监听事件、响应数据变化等。Angular 中主要有三种类型的指令：</p>
<p>1属性型指令（Attribute Directives）：</p>
<p>用于改变元素的外观或行为。</p>
<p>通常以 @Directive 装饰器来定义，并通过属性的形式应用到元素上。</p>
<p>例如，内置的 ngClass 和 ngStyle 指令。</p>
<p>2结构型指令（Structural Directives）：</p>
<p>用于在模板中添加或移除 DOM 元素。</p>
<p>通常以 * 符号作为前缀，表示它们会影响宿主元素及其子元素。</p>
<p>例如，内置的 *ngIf 和 *ngFor 指令。</p>
<p>改变元素的行为</p>
<p>使用&#x3C;div appHighlight></p>
<p>结构型指令<br>
Featurecheck</p>
<p>使用</p>
<p>*gdFeatureCheck=’featureName’<br>
说明这是一个结构型指令</p>
<ul>
<li><strong>gdFeatureCheck</strong>：用于传递静态值，不涉及动态计算。</li>
<li><strong>[gdFeatureCheck]</strong>：用于传递动态值或表达式，会触发变更检测。</li>
<li><strong>*gdFeatureCheck</strong>：用于结构型指令，影响 DOM 结构，可以传递静态值或动态值。</li>
</ul>
<h2 id="应用启动时执行初始化逻辑">应用启动时执行初始化逻辑</h2>
<h3>APP_INITIALIZER（使用provideAppInitializer 替换）</h3>
<p>APP_INITIALIZER 是一个用于在应用启动时执行初始化逻辑的注入令牌</p>
<h3>provideAppInitializer</h3>
<ul>
<li><strong>APP_INITIALIZER</strong>：是一个注入令牌，用于在应用启动之前执行初始化逻辑。</li>
<li><strong>provideAppInitializer</strong>：是一个辅助函数，提供了更简洁和类型安全的方式来配置 APP_INITIALIZER。</li>
</ul>
<h3><strong>bootstrapApplication 启动独立组件</strong></h3>
<p>独立组件的应用，并且你想在应用启动前执行一些初始化逻辑：</p>
<p>platformBrowser().bootstrapModule(MyModule);</p>
<h3>Muti:true</h3>
<p>，使用 multi: true 可以确保这些提供者都被正确地添加到一个数组中，而不是被覆盖。</p>
<h2 id="注册拦截器">注册拦截器</h2>
<p>使用</p>
<p>httpHeaderIntercepter<br>
添加请求头</p>
<p>ErrorIntercepter<br>
拿到错误码，转换错误对象</p>
<p>LogIntercepter<br>
排除文字 图片获取时的log</p>
<p>tokenIntercepter</p>
<p>给http 请求添加token，并且如果没有token的话</p>
<p>Retry</p>
<p>（timer(0) 表示立即重试）</p>
<p>可以定义一个core-interceptors.providers.ts</p>
<p>将所有的拦截器放进去</p>
<p>1你需要创建一个实现了 HttpInterceptor 接口的类。这个接口只有一个方法 intercept</p>
<p>2接下来，你需要在你的应用中注册这个拦截器。你可以通过 providers 数组将拦截器提供给依赖注入系统，并使用 HTTP_INTERCEPTORS 注入令牌。</p>
<p>3使用 withInterceptors 和 withInterceptorsFromDi</p>
<h2 id="httpclient">HttpClient</h2>
<h3>配置HttpClient</h3>
<p>HttpClientModule 在 Angular 16 及更高版本中已被标记为不推荐使用,</p>
<p>不需要再导入httpclientModule</p>
<h4>provideHttpClient 函数</h4>
<h4>独立组件（standalone component）的应用</h4>
<h4><strong>使用 NgModule</strong></h4>
<ul>
<li><strong>provideHttpClient</strong>：这是一个函数，用于配置 HttpClient。</li>
<li><strong>withInterceptorsFromDi</strong>：这个函数会从依赖注入器中获取所有已注册的 HTTP_INTERCEPTORS，并将它们添加到 HttpClient 的拦截器链中。</li>
</ul>
<h3>怎么使用HttpClient</h3>
<h3><strong>将 Observable 转换为 Promise</strong></h3>
<h4><strong>使用 toPromise（RxJS 6.x 及之前版本）</strong></h4>
<h4>使用firstValueFrom or lastValueFrom</h4>
<p>取消订阅<br>
Subscription 是一个对象，用于表示对 Observable 的订阅。通过 Subscription 对象，你可以控制订阅的生命周期，包括取消订阅</p>
<h3>取消订阅</h3>
<h4><strong>使用 Subscription 管理多个订阅</strong></h4>
<p>如果你有多个订阅，可以使用 Subscription 类来管理它们</p>
<h4><strong>1. private subscriptions: Subscription = new Subscription();</strong></h4>
<p>这种声明方式创建了一个新的 Subscription 对象，并将其赋值给 subscriptions 属性。这个 Subscription 对象可以用来管理多个订阅，通过 add 方法将多个订阅添加到这个对象中。</p>
<p>优点：</p>
<ul>
<li><strong><strong>集中管理</strong></strong>：可以将多个订阅集中管理在一个 Subscription 对象中。</li>
<li><strong><strong>自动取消</strong></strong>：当调用 unsubscribe 方法时，所有添加的订阅都会被自动取消。</li>
</ul>
<p>如果使用</p>
<p>this.subscriptions.push(subscription1);的话，需要遍历所有订阅然后取消</p>
<p>subscriptions的声明方式如下：<br>
private subscriptions: Subscription[] = [];</p>
<h4><strong>destroy$？</strong></h4>
<p>private destroy$: Subject&#x3C;void> = new Subject&#x3C;void>();</p>
<ul>
<li>
<p>这里定义了一个名为 destroy$ 的私有属性，类型为 Subject&#x3C;void>。void 表示这个 Subject 不会发送任何实际的数据，只是一个信号。</p>
</li>
<li>
<p>你调用 this.destroy$.next() 来发出一个信号，表示组件即将销毁。</p>
</li>
<li>
<p>然后调用 this.destroy$.complete() 来完成这个 Subject，确保不会再有新的信号发出。</p>
</li>
</ul>
<p>pipe(takeUntil(this.destroy$)) 创建一个新的 Observable，它会在 this.destroy$ 发出信号时停止发出值。</p>
<h2 id="国际化">国际化</h2>
<h3>1实现工厂类（来动态加载和合并翻译文件）</h3>
<ul>
<li><strong><strong>TranslateLoaderFactory</strong></strong> 这是一个工厂类，返回一个新的类 LazyTranslateLoader，该类实现了 TranslateLoader 接口。</li>
</ul>
<h3>2模块导入</h3>
<p>Providers: [brandTranslateService]</p>
<h3><strong>3使用 TranslateService</strong></h3>
<p>配置语言（项目中用的是配置brand）</p>
<h3>4 <strong>在模板中使用管道</strong></h3>
<p>或者在ts中直接<br>
this.brandTranslateService.getText('WELCOME').subscribe((res: string) => { this.welcomeMessage = res; });</p>
<h2 id="ngmodule">@ngmodule</h2>
<h3>useFactory</h3>
<ul>
<li><strong>useFactory</strong>：是一个工厂函数，用于动态地创建和返回服务实例。</li>
<li><strong>deps</strong>：指定工厂函数的依赖项。</li>
</ul>
<h3>Usevalue</h3>
<p>提供的值是静态的，在应用运行时不会改变。</p>
<h3>InjectionToken</h3>
<p>InjectionToken 是 Angular 中用于创建依赖注入令牌的类。这些令牌可以用来标识那些不能直接通过类来提供的值，例如原始类型（如字符串、数字）、数组或对象等。使用 InjectionToken 可以让你在 DI 系统中明确地指定要注入的值，并且可以为这些值提供一个描述性的名称。</p>
<h2 id="angular-cdk">Angular CDK</h2>
<p>Angular CDK (Component Dev Kit) 是 Angular 团队提供的一套工具和组件，旨在帮助开发者构建高质量的 Angular 应用程序。CDK 不仅包括一些可以直接使用的 UI 组件，更重要的是它提供了许多底层服务和工具，</p>
<ul>
<li>cdk/overlay：用于处理弹出层、对话框等覆盖物相关的逻辑。</li>
<li>cdk/drag-drop：支持拖拽交互。</li>
<li>cdk/a11y：提供无障碍辅助功能。</li>
<li>cdk/layout：提供布局相关服务，例如断点检测。</li>
<li></li>
</ul>
<h2 id="reactive-forms">Reactive Forms</h2>
<ol>
<li>
<p><strong>FormGroup</strong>：表示一组控件（FormControl），可以是简单的输入字段，也可以是其他 FormGroup 或 FormArray。</p>
</li>
<li>
<p><strong>FormControl</strong>：表示单个表单控件，例如文本框、复选框等。你可以为每个 FormControl 添加验证器（Validators）。</p>
</li>
<li>
<p><strong>FormArray</strong>：表示一个动态数组，其中可以包含多个 FormControl 或 FormGroup。这对于实现动态添加或移除表单字段非常有用。</p>
</li>
<li>
<p><strong>FormBuilder</strong>：提供了一种简便的方式来创建 FormGroup、FormControl 和 FormArray，简化了表单构建过程。</p>
</li>
</ol>
<p>this.fb.array([this.createItem()]) 创建了一个 FormArray，其中包含一个由 createItem 方法返回的 FormGroup。</p>
<p>5 formArrayName</p>
<p>是 Angular Reactive Forms 中的一个指令，它用于将 FormArray 绑定到模板中的一个 &#x3C;div> 或其他容器元素。使用 formArrayName 指令可以让 Angular 知道哪个 DOM 元素对应于表单模型中的 FormArray</p>
<p>formGroup 指令用于将一个 FormGroup 实例绑定到一个 &#x3C;form> 元素或任何其他容器元素上。</p>
<p>formControlName 指令用于将一个 FormControl 实例绑定到一个具体的输入元素上。每个带有 formControlName 的输入元素都对应于 FormGroup 中的一个键值对。</p>
<h2 id="项目结构">项目结构</h2>
<ul>
<li>core: 通常包含核心模块和服务，如全局服务、拦截器等。
<ul>
<li>Component: Error/pagenotfount/success、</li>
<li>Factories: initial-load/translate-loader/app-preloading-strategy</li>
<li>Guards</li>
<li>Interceptors: error/http-deader/logging/retry/token</li>
<li>Models: 接口文件（也可以放在shared目录下）</li>
<li>Enums: 枚举文件（也可以放在shared目录下）</li>
</ul>
</li>
</ul>
<p>core-routing.module.ts/core.module.ts</p>
<ul>
<li>features: 通常包含应用的各个功能模块，每个功能模块可能包含自己的组件、服务和路由。(如果使用懒加载模块就不用导入到app.module)</li>
<li>shared: 通常包含共享的组件、服务和管道等，可以在多个功能模块中复用。
<ul>
<li>shared.module.ts</li>
</ul>
</li>
</ul>
<p>app-routing.module.ts: 应用的路由模块，定义了应用的路由配置。</p>
<p>app.module.ts: 应用的根模块，定义了应用的模块配置。</p>
<p>assets</p>
<ul>
<li>brands: 品牌相关的静态资源。</li>
<li>docs: 文档相关的静态资源。</li>
<li>favicon: 网站的 favicon 图标。</li>
<li>fonts: 字体文件。</li>
<li>i18n: 国际化资源文件。</li>
<li>images: 图片资源。</li>
</ul>
<p>css</p>
<ul>
<li>brands: 品牌相关的 CSS 文件。</li>
<li>components: 组件相关的 CSS 文件。</li>
<li>fonts: 字体相关的 CSS 文件。</li>
<li>mixins: CSS 混入文件。</li>
<li>page-design: 页面设计相关的 CSS 文件。</li>
<li>pages: 页面相关的 CSS 文件。
<ul>
<li>Footer/header/menu</li>
</ul>
</li>
<li>reset.scss: 重置样式文件。</li>
<li>styles.scss: 主要的样式文件。
<ul>
<li>H1/h2/font/color/notification/</li>
</ul>
</li>
</ul>
<p>environments: 环境配置文件。</p>
<p>mirage: Mirage.js 相关文件，用于模拟数据。</p>
<p>module-federation.ts: 模块联邦相关的配置文件。</p>
<p>Enums</p>
<p>最推荐的做法是将枚举放在 shared/models 文件夹中.</p>
<p>比如与应用程序配置、环境设置等相关的枚举，可以考虑将其放置在 core 文件夹中</p>
<h2 id="常见用法">常见用法</h2>
<h3>ng-container 和ng-template</h3>
<p>ng-container 是 Angular 提供的一个特殊的容器标签，它允许你在模板中创建逻辑分组而不向最终的 DOM 添加额外的节点。这意味着 ng-container 在渲染时不会出现在页面上，也不会影响样式或布局。</p>
<p>ng-container 还可以与 ngTemplateOutlet 结合使用来递归调用模板，这有助于减少不必要的 DOM 元素嵌套，并且能够更灵活地传递参数给子模板</p>
<p>ng-template</p>
<p>另一方面，ng-template 是一个用于定义模板片段的 Angular 指令。这些模板片段本身并不会直接显示在页面上，而是作为模板的一部分被引用和重用。ng-template 的内容只有在通过特定的指令（如 *ngIf、*ngFor 或 ngTemplateOutlet）显式渲染时才会出现在视图中8。</p>
<p>ng-template 可以用来创建复杂的条件渲染逻辑，比如根据上下文的不同显示不同部分的内容。通过 context 参数，还可以向模板传递数据，使模板变得更加动态和交互性强4。</p>
<h3>ngTemplateOutlet</h3>
<p>ngTemplateOutlet 是 Angular 框架中的一个内置结构指令，它允许开发者动态地插入由 ng-template 定义的模板内容。这个功能特别有用，尤其是在需要创建高度可定制或复用的组件时。通过 ngTemplateOutlet，你可以将一个提前准备好的 TemplateRef 插入到页面指定的位置，并且可以传递上下文数据给该模板以实现更加灵活的内容展示</p>
<p>在父组件中定义一个模板，并在子组件中渲染它：</p>
<p>parent.component.html 中定义了一个名为 customContent 的模板，并通过 &#x3C;app-child> 标签将其传递给了子组件。子组件接收到这个模板后，在其自己的模板中使用了 ngTemplateOutlet 来渲染父组件传递过来的内容。同时，还设置了上下文对象 { $implicit: 'someItem' }，使得父组件定义的模板能够获取到传递的数据 item。</p>
<p>$implicit 等于let-item<br>
$implicit 是一个特殊的上下文变量名称，它用于 ngTemplateOutlet 和其他结构指令中，当定义模板引用变量时，可以用来表示默认传递的数据值</p>
<p>除了 $implicit，你也可以添加其他键值对到上下文对象中，以便在模板中使用不同的局部变量名进行绑定。</p>
<h3>获取子组件的实例</h3>
<p>使用 @ViewChild 获取单个子组件实例</p>
<p>使用 @ViewChildren 获取多个子组件实例</p>
<p>使用 @ContentChild 和 @ContentChildren 获取内容投影的子组件实例</p>
<h2 id="optional-skipself">@Optional() @SkipSelf()</h2>
<p>用于构造函数参数的参数装饰器</p>
<p>Optional</p>
<p>将参数标记为可选依赖项。如果找不到依赖关系，DI框架将提供null。</p>
<p>SkipSelf</p>
<p>它告诉DI框架从父注入器开始依赖项解析。分辨率在注射器层次结构中向上工作，因此不会检查本地注射器的提供者。</p>
<h2 id="rxjs">Rxjs</h2>
<p><a href="https://segmentfault.com/a/1190000021143815">https://segmentfault.com/a/1190000021143815</a></p>
<p>一种用于异步编程的库。它基于响应式编程模型</p>
<h3>观察者</h3>
<h4>Observer</h4>
<p><strong><strong>定义</strong></strong>：一个 Observer 是一个拥有三个可选方法的对象或实现这些方法的函数，用于接收来自 Observable 的通知：</p>
<ul>
<li><strong>next(value)</strong>：当 Observable 发出一个值时调用。</li>
<li><strong>error(error)</strong>：当 Observable 遇到错误并终止时调用。</li>
<li><strong>complete()</strong>：当 Observable 正常完成且不再发出更多值时调用。</li>
</ul>
<p>作用：Observer 负责处理从 Observable 接收到的数据或事件，并对这些数据或事件做出响应。它订阅了 Observable 后，就会开始监听由该 Observable 发出的通知。</p>
<h4>Observable</h4>
<p><strong><strong>定义</strong></strong>：Observable 是一个可以被订阅的对象，它代表了一个可能异步发生的值或事件序列。一旦有观察者订阅它，Observable 就会开始发送通知给这个观察者。</p>
<p>生产者与消费者：Observable 是生产者，负责生成数据流；而 Observer 是消费者，负责消费这些数据。</p>
<h4>其他创建方法</h4>
<h4><strong>使用静态创建方法</strong></h4>
<p>RxJS 提供了多个静态方法来创建特定类型的 Observables，例如从数组、Promise、事件等创建。</p>
<ul>
<li>from: 将任何可迭代对象或 Promise 转换为 Observable。</li>
<li>of: 创建一个发出一系列指定值的 Observable。</li>
<li>interval: 创建一个每隔一定时间发出递增数值的 Observable。</li>
<li>timer: 创建一个在指定延迟后开始发出值的 Observable。</li>
</ul>
<h3>订阅</h3>
<p>什么是订阅？订阅是表示可支配资源的对象，通常是 Observable 的执行。</p>
<p>取消订阅</p>
<p>1 subscription.unsubscribe();</p>
<p>2 private subscriptions: Subscription[] = [];</p>
<p>3 通过 "adding" 一个订阅到另一个订阅来做到这一点：</p>
<h3>Of</h3>
<p>of 方法可以接受一系列的值，并立即创建一个 Observable，该 Observable 会依次发出这些值，并在最后一个值发出之后完成。</p>
<h3>From</h3>
<p>from 方法可以接受任何可迭代的对象（如数组、字符串、Set、Map，promise 等），并创建一个 Observable，该 Observable 会依次发出可迭代对象中的每个元素，并在最后一个元素发出之后完成。</p>
<p>你可以使用 from 将一个 Promise 转换为 Observable。</p>
<h3>Pipe</h3>
<p>pipe 方法是一个函数，它接受一系列的操作符作为参数，并返回一个新的操作符</p>
<h3>Subject</h3>
<ul>
<li><strong><strong>Subject</strong></strong>：是一个可以被多个观察者订阅的可观察对象，同时它可以向观察者发送值。</li>
<li><strong><strong>BehaviorSubject</strong></strong>：始终保持最新的值，并且新订阅的观察者可以接收到这个最新的值。</li>
</ul>
<p>Subject 是一个特殊的对象，它同时具备 Observable 和 Observer 的特性。具体来说，Subject 可以作为 Observable 被多个订阅者订阅，同时也可以作为 Observer 接收数据并将其广播给所有订阅者。</p>
<h3>mergeMap</h3>
<p>假设你有一个用户 ID 列表，你需要根据这些 ID 获取用户的详细信息。你可以使用 flatMap 来实现这一点：</p>
<h3><strong>switchMap</strong></h3>
<p><strong>switchMap</strong>: 类似于 mergeMap，但当新的 Observable 发出时，它会取消之前的 Observable。</p>
<p>/ 只输出最后一个 Observable 的结果</p>
<h3>mergeAll</h3>
<p>假设你有一个发出多个 Observables 的 Observable，你需要将这些 Observables 的值合并到一个单一的 Observable 中</p>
<h3>concatWith和concatAll</h3>
<h4>concatWith</h4>
<p>将当前的 Observable 与另一个 Observable 连接起来，只有当前一个 Observable 完成后，才会开始订阅下一个 Observable。</p>
<p>在这个例子中，source1 先发出 1, 2, 3，然后 source2 发出 4, 5, 6。concat 确保了 source1 完成后再开始 source2</p>
<h4>concatAll</h4>
<p>假设你有一个发出多个 Observable 的 Observable，你需要按顺序处理这些 Observable：</p>
<p>如果不使用concatAll</p>
<p>返回的是两个observable.</p>
<h4>concatAll 和mergeAll</h4>
<ul>
<li><strong>concatAll</strong> 适合于需要保持内部 Observables 顺序的情况，它会确保按照它们被发出的顺序依次执行。</li>
<li><strong>mergeAll</strong> 适用于需要同时并发处理多个内部 Observables 的情况，它可以将所有内部 Observable 的输出合并到一个单一的流中，但不保证值的顺序。</li>
</ul>
<h3>Tap</h3>
<p>用于对来自源 observable 的通知执行副作用</p>
<h3></h3>
<p>forkJoin</p>
<p>当有一组 observables，但你只关心每个 observable 最后发出的值时，此操作符是最适合的。它可能与 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all%22%20%5Ct%20%22_blank">Promise.all</a> 的使用方式类似。</p>
<h3>pairwise</h3>
<p>假设你有一个数字序列，你想计算每对相邻值之间的差值：</p>
<p>假设你有一个事件流，你想检测每次值变化的情况：</p>
<h3>retry</h3>
<h3>Race</h3>
<p>使用首先发出值的 observable 。</p>
<h3>startWith</h3>
<h3>timer</h3>
<p>timer 接收第二个参数，它决定了发出序列值的频率，在本例中我们在1秒发出第一个值</p>
<h3>Interval</h3>
<h3>publish</h3>
<h3>Share</h3>
<h3>shareReplay</h3>
<p>共享源 observable 并重放指定次数的发出。</p>
<h3>debounce</h3>
<p>只有在另一个 Observable 确定的特定时间跨度过去且没有另一个源发射时，才从源 Observable 发出通知。</p>
<h3>将Observable转换成Promise</h3>
<p>Tsconfig</p>
</div> </article> </main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"Angular","contentHtml":"\u003ch1\u003eAngular\u003c/h1\u003e\n\u003ch2 id=\"模块\"\u003e模块\u003c/h2\u003e\n\u003cp\u003eAngular 应用程序由多个模块组成，每个模块负责处理特定的功能或一组相关的功能\u003c/p\u003e\n\u003ch3\u003e根模块\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e每个 Angular 应用程序至少有一个根模块，通常命名为 AppModule。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cstrong\u003e1.2 根模块的属性\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003edeclarations\u003c/strong\u003e: 声明属于该模块的组件、指令和管道。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eimports\u003c/strong\u003e: 导入其他模块，以便在当前模块中使用它们的导出内容。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eproviders\u003c/strong\u003e: 注册服务提供者，使其在模块范围内可用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ebootstrap\u003c/strong\u003e: 指定应用程序启动时应该引导的根组件\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eFeature modules\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e特性模块用于组织与特定功能相关的组件、服务、指令等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e共享模块（Shared Module）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e共享模块包含可以在多个特性模块中复用的组件、指令和服务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ecore\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e通常包含核心模块和服务，如全局服务、拦截器等。。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e路由懒加载模块（Lazy-Loaded Module）\u003c/p\u003e\n\u003cp\u003eloadChildren: () =\u003e import('./product/product.module').then(m =\u003e m.ProductModule)\u003c/p\u003e\n\u003cp\u003e如果你的功能模块是通过路由懒加载的方式引入的，那么你不需要直接在 AppModule 中导入这些模块。相反，你应该在路由配置中定义它们。\u003c/p\u003e\n\u003ch3\u003eStandalone Components\u003c/h3\u003e\n\u003cp\u003e它允许开发者创建不依赖于 NgModule 的组件、指令和管道。这意味着组件可以直接在其他组件中使用，而不需要通过 NgModule 进行声明和导出\u003c/p\u003e\n\u003ch2 id=\"数据传输\"\u003e数据传输\u003c/h2\u003e\n\u003ch3\u003e\u003c/h3\u003e\n\u003cp\u003e1父到子\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e输入属性（@Input）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e2子到父\u003c/h3\u003e\n\u003cp\u003e使用 @Output 装饰器可以在子组件向父组件传递事件。子组件通过 EventEmitter 发出事件\u003c/p\u003e\n\u003ch3\u003e3. 服务（Services）\u003c/h3\u003e\n\u003cp\u003e使用服务可以在多个组件之间共享数据。服务可以通过依赖注入（DI）系统在组件中注入，并提供数据和方法。\u003c/p\u003e\n\u003ch3\u003e4. 路由参数（Route Parameters）\u003c/h3\u003e\n\u003ch3\u003e\u003c/h3\u003e\n\u003cp\u003e5 storage\u003c/p\u003e\n\u003ch3\u003e6 RXjs 发布订阅\u003c/h3\u003e\n\u003ch2 id=\"装饰器-decorator\"\u003e装饰器 decorator\u003c/h2\u003e\n\u003cp\u003e装饰器（Decorators）是一种元编程工具，用于修改或注解类、方法、属性和参数\u003c/p\u003e\n\u003ch3\u003e类装饰器\u003c/h3\u003e\n\u003cp\u003e@Component\u003c/p\u003e\n\u003cp\u003e用于定义 Angular 组件。组件是 Angular 应用的基本构建块，包含模板、样式和类。\u003c/p\u003e\n\u003cp\u003e@NgModule\u003c/p\u003e\n\u003cp\u003e定义模块。\u003c/p\u003e\n\u003cp\u003e@directive\u003cbr\u003e\n用于定义指令。指令用于在模板中添加行为。\u003c/p\u003e\n\u003cp\u003e@Injectable\u003c/p\u003e\n\u003cp\u003e用于定义服务。服务通常用于提供可重用的功能，如数据访问、业务逻辑等。\u003c/p\u003e\n\u003ch3\u003e属性装饰器\u003c/h3\u003e\n\u003cp\u003e@Input / @output\u003c/p\u003e\n\u003cp\u003e定义输入/输出属性\u003c/p\u003e\n\u003cp\u003e允许父组件向子组件传递数据。/ 允许父组件向子组件传递数据。\u003c/p\u003e\n\u003cp\u003e@ViewChild\u003c/p\u003e\n\u003cp\u003e用于获取组件或指令的实例。\u003c/p\u003e\n\u003ch3\u003e方法装饰器\u003c/h3\u003e\n\u003cp\u003e@HostListener\u003c/p\u003e\n\u003cp\u003e用于在指令或组件中监听宿主元素的事件。\u003c/p\u003e\n\u003ch3\u003e怎么自定义装饰器\u003c/h3\u003e\n\u003cp\u003e装饰器的结构\u003c/p\u003e\n\u003cp\u003e装饰器函数接受一个或多个参数，具体取决于装饰器的类型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e类装饰器\u003c/strong\u003e\u003c/strong\u003e：接受一个参数，即类的构造函数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e属性装饰器\u003c/strong\u003e\u003c/strong\u003e：接受两个参数，即目标对象（类的原型或类本身）和属性名。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e方法装饰器\u003c/strong\u003e\u003c/strong\u003e：接受三个参数，即目标对象（类的原型或类本身）、方法名和方法描述符。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e参数装饰器\u003c/strong\u003e\u003c/strong\u003e：接受三个参数，即目标对象（类的原型或类本身）、方法名或属性名和参数索引。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e装饰器的执行时机\u003c/p\u003e\n\u003cp\u003e装饰器在编译时被调用，而不是在运行时。这意味着装饰器可以用来修改类的定义，而不会影响运行时的性能。\u003c/p\u003e\n\u003cp\u003e装饰器的返回值\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e类装饰器\u003c/strong\u003e\u003c/strong\u003e：可以返回一个新的构造函数，以替换原来的类。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e方法装饰器\u003c/strong\u003e\u003c/strong\u003e：可以返回一个新的方法描述符，以替换原来的方法。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e属性装饰器\u003c/strong\u003e\u003c/strong\u003e：通常不返回值，因为它们主要用于修改属性的行为。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e参数装饰器\u003c/strong\u003e\u003c/strong\u003e：通常不返回值，因为它们主要用于添加元数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"依赖注入dependency-injection-di模式\"\u003e依赖注入（Dependency Injection, DI）模式\u003c/h2\u003e\n\u003cp\u003eAngular 的依赖注入系统是其核心特性之一。通过依赖注入，组件和服务可以轻松地获 取所需的依赖项，而不需要手动实例化对象。\u003c/p\u003e\n\u003ch2 id=\"providedin-root\"\u003eprovidedIn: 'root'\u003c/h2\u003e\n\u003cp\u003eprovidedIn: 'root': 这个选项告诉 Angular，在根注入器中提供这个服务。这意味着服务在整个应用程序中都是单例的，可以在任何组件中注入和使用。\u003c/p\u003e\n\u003cp\u003e@Injectable() 是 Angular 中的一个装饰器，用于标记一个类为可注入的服务。\u003c/p\u003e\n\u003ch3\u003eInjectable\u003c/h3\u003e\n\u003ch3\u003e构造函数注入\u003c/h3\u003e\n\u003cp\u003e在 Angular 中，依赖项通常是通过构造函数注入的。Angular 的编译器会分析构造函数参数，并从 DI 系统中获取相应的依赖项。\u003c/p\u003e\n\u003ch3\u003e生命周期钩子和注入\u003c/h3\u003e\n\u003ch3\u003e@Injectable() 和 @Inject\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e@Injectable() 是 Angular 中的一个装饰器，用于标记一个类为可注入的服务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e@Inject \u003cstrong\u003e装饰器\u003c/strong\u003e\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e非类令牌\u003c/strong\u003e\u003c/strong\u003e：它特别适用于注入非类令牌，如 InjectionToken 或原始类型（例如字符串、数字）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e显式注入\u003c/strong\u003e\u003c/strong\u003e：它使依赖注入更加明确和清晰。\n\u003cul\u003e\n\u003cli\u003e假设你有两个不同版本的 LoggerService，但它们都实现了同一个接口 ILoggerService。在这种情况下，你可以使用 @Inject 来明确指定要注入哪一个具体的实现。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eInjectionToken\u003c/strong\u003e：用于创建标识符，以便在依赖注入系统中注入非类类型的值。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e注入非类类型的值\u003c/strong\u003e\u003c/strong\u003e：通过 @Inject 装饰器和 InjectionToken 来实现。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e注入令牌\u003c/h3\u003e\n\u003ch2 id=\"设计模式\"\u003e设计模式\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/672502223\"\u003ehttps://zhuanlan.zhihu.com/p/672502223\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e行为型设计模式\u003c/h3\u003e\n\u003cp\u003e描述多个类或对象之间怎样==相互协作==共同完成单个对象都无法单独完成的任务\u003c/p\u003e\n\u003ch4\u003e1 模版方法模式\u003c/h4\u003e\n\u003cp\u003e描述： 模板方法模式的核心思想是封装行为中的不变部分，同时允许可变部分通过子类来进行扩展。\u003c/p\u003e\n\u003cp\u003e在前端开发中，模板方法模式通常用于处理页面的渲染和事件处理。例如，我们可以定义一个基础的页面渲染算法，并在其中定义一些抽象方法，如初始化数据、绑定事件、渲染模板等，然后在子类中实现这些具体操作。这样可以使得我们在开发页面时，只需要关注具体的业务逻辑，而不用过多关注页面的渲染细节。\u003c/p\u003e\n\u003cp\u003eAngular 的生命周期钩子（如 ngOnInit, ngOnDestroy 等）采用了模板方法模式。这些钩子方法在组件的生命周期中自动调用，开发者可以在这些方法中添加自定义逻辑。\u003c/p\u003e\n\u003ch4\u003e2观察者模式（Observer Pattern）\u003c/h4\u003e\n\u003cp\u003eAngular 广泛使用 RxJS 库来实现观察者模式。RxJS 提供了 Observable 和 Subject 等类，用于处理异步数据流和事件。\u003c/p\u003e\n\u003cp\u003e在 RxJS 中，观察者模式通过 Observable 和 Observer 来实现。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eObservable（可观察对象）\u003c/strong\u003e\u003c/strong\u003e：一个可以发送数据流的对象。它可以发送多种类型的通知，包括 next（发送数据）、error（发送错误）和 complete（发送完成通知）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eObserver（观察者）\u003c/strong\u003e\u003c/strong\u003e：一个可以接收 Observable 发送的通知的对象。它包含三个回调函数：next、error 和 complete\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e发布-订阅模式\u003c/h5\u003e\n\u003cp\u003eSubject 类实现了发布订阅模式。Subject 是一个特殊的 Observable，它既可以作为 Observable 来订阅，也可以作为 Observer 来接收数据。\u003c/p\u003e\n\u003ch4\u003e3 策略模式\u003c/h4\u003e\n\u003cp\u003e策略模式用于定义一系列算法，并将每一个算法封装起来，使它们可以互换。Angular 中的路由守卫（Guards）就是一个典型的例子\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e\u003ca href=\"https://zhida.zhihu.com/search?content_id=237574615\u0026#x26;content_type=Article\u0026#x26;match_order=1\u0026#x26;q=%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\u0026#x26;zhida_source=entity%22%20%5Ct%20%22https://zhuanlan.zhihu.com/p/_blank\"\u003e创建型设计模式\u003c/a\u003e\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e1 单例模式（Singleton Pattern）\u003c/h4\u003e\n\u003cp\u003eAngular 的服务默认是单例的，即在整个应用中只有一个实例。这通过在服务的 @Injectable 装饰器中设置 providedIn: 'root' 来实现。\u003c/p\u003e\n\u003ch4\u003e2工厂模式（Factory Pattern）\u003c/h4\u003e\n\u003cp\u003e描述：它是专门定义一个类，依据参数的不同，来负责创建其它类的实例，被创建的实例通常都具有共同的父类\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e创建服务\u003c/strong\u003e\u003c/strong\u003e：定义你需要创建的不同服务。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e创建工厂函数\u003c/strong\u003e\u003c/strong\u003e：编写一个工厂函数，根据条件返回不同的服务实例。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e注册提供者\u003c/strong\u003e\u003c/strong\u003e：在模块中注册工厂提供者。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e在组件中使用服务\u003c/strong\u003e\u003c/strong\u003e：在组件中注入并使用服务。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch6\u003e简单工厂\u003c/h6\u003e\n\u003cp\u003e简单工厂模式是最基本的形式\u003c/p\u003e\n\u003cp\u003e简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。\u003c/p\u003e\n\u003cp\u003e简单工厂模式（Simple Factory Pattern）也称为静态工厂模式，它是专门定义一个类，依据参数的不同，来负责创建其它类的实例，被创建的实例通常都具有共同的父类。之所以称作静态工厂模式，\u003c/p\u003e\n\u003cp\u003e假设我们有一个应用，需要创建不同类型的日志记录器（例如，文件日志记录器和数据库日志记录器）。\u003c/p\u003e\n\u003ch6\u003e工厂方法\u003c/h6\u003e\n\u003cp\u003e定义了一个创建对象的抽象接口（类或接口中的方法）==并不是代码中的interface==，但由子类决定要实例化的类 是哪一个。工厂方法把实例化推迟到子类\u003c/p\u003e\n\u003cp\u003e提供一个接口，让子类决定实例化哪一个类。\u003c/p\u003e\n\u003ch6\u003e抽象工厂\u003c/h6\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e工厂方法模式\u003c/strong\u003e\u003c/strong\u003e适合于创建单一类型的产品，通过子类来决定具体的实现。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e抽象工厂模式\u003c/strong\u003e\u003c/strong\u003e适合于创建一系列相关的产品，通过具体的工厂类来创建这些产品。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e结构型设计模式\u003c/h3\u003e\n\u003ch4\u003e1代理模式\u003c/h4\u003e\n\u003cp\u003e描述：当我们想要对一个业务类进行某些横切性的增强时，例如：增加请求与响应 的日志、增加权限校验、增加远程请求对象封装等等。我们可以采用代理模式去实现， 而不需要修改原有的类。\u003c/p\u003e\n\u003ch4\u003e2组合模式\u003c/h4\u003e\n\u003cp\u003e描述：用于将对象组合成树形结构以表示“部分-整体”的层次结构。\u003c/p\u003e\n\u003cp\u003e在 Angular 中，你可以利用组合模式来构建复杂的 UI 组件或数描述：它允许向一个现有的对象动态地添加新的功能，同时不改变其结构。它是继承的一种替代方案，可以实现在运行时动态地扩展对象的行为，而无需修改原有代码。\u003c/p\u003e\n\u003cp\u003e假设我们要构建一个简单的文件系统，其中包含文件和文件夹。文件夹可以包含文件和其他文件夹，形成一个树形结构。\u003c/p\u003e\n\u003cp\u003e1、Component：组合模式中的“根节点”，可以是接口、抽象类、普通类，该类中定义了其子类的所有共性内容，并且该类中还存在着用于访问和管理它子部件的方法。\u003c/p\u003e\n\u003cp\u003e2、Leaf：组合中的叶子节点，也就是最末端的节点，该节点下不会再有子节点。\u003c/p\u003e\n\u003cp\u003e3、Composite：非叶子节点，它的作用是存储子部件，并且在Composite中实现了对子部件的相关操作。\u003c/p\u003e\n\u003ch4\u003e3装饰器模式（Decorator Pattern）\u003c/h4\u003e\n\u003cp\u003e用于修改或注解类、方法、属性和参数\u003c/p\u003e\n\u003ch4\u003e4适配器模式\u003c/h4\u003e\n\u003cp\u003e模式描述：适配器模式允许你将一个类的接口转换成客户端期望的另一个接口。在 Angular 中，你可以使用适配器模式来处理不同数据源的格式转换。\u003c/p\u003e\n\u003ch2 id=\"路由\"\u003e路由\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e路由（Routes）\u003c/strong\u003e\u003c/strong\u003e：定义了 URL 与组件之间的映射关系。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e路由模块（RouterModule）\u003c/strong\u003e\u003c/strong\u003e：用于配置路由的模块。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e路由器（Router）\u003c/strong\u003e\u003c/strong\u003e：负责根据当前 URL 导航到相应的组件。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e路由出口（RouterOutlet）\u003c/strong\u003e\u003c/strong\u003e：用于显示匹配到的组件。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e路由参数（Route Parameters）\u003c/strong\u003e\u003c/strong\u003e：可以从 URL 中提取动态参数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e路由守卫（Route Guards）\u003c/strong\u003e\u003c/strong\u003e：用于控制路由的访问权限，如登录验证、权限检查等\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eRouterModule.forRoot\u003c/h3\u003e\n\u003cp\u003eRouterModule.forRoot 是配置 Angular 应用程序路由的核心方法\u003c/p\u003e\n\u003ch3\u003e使用provideRouter\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ewithInMemoryScrolling()：启用内存滚动恢复，确保用户在导航时保持滚动位置。\u003c/li\u003e\n\u003cli\u003ewithDebugTracing()：启用路由调试跟踪，有助于调试路由问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"eventemitter\"\u003eEventEmitter\u003c/h2\u003e\n\u003cp\u003eEventEmitter 的基本原理是观察者模式（Observer Pattern）。观察者模式定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。\u003c/p\u003e\n\u003cp\u003e在 Angular 中，EventEmitter 主要用于父子组件之间的通信。以下是一些关键点：\u003c/p\u003e\n\u003ch4\u003e定义 EventEmitter\u003c/h4\u003e\n\u003cp\u003e使用 @Output 装饰器将 EventEmitter 标记为输出属性。\u003c/p\u003e\n\u003cp\u003eEventEmitter 是一个 RxJS 的 Subject，它可以用来发射事件。\u003c/p\u003e\n\u003ch4\u003e发射事件\u003c/h4\u003e\n\u003cp\u003e通过调用 emit 方法来发射事件，并传递事件数据。\u003c/p\u003e\n\u003ch4\u003e监听事件\u003c/h4\u003e\n\u003cp\u003e父组件通过模板绑定来监听子组件的 EventEmitter 事件。\u003c/p\u003e\n\u003ch4\u003e代码实现\u003c/h4\u003e\n\u003cp\u003e1 EventEmitter 类\u003cbr\u003e\n继承自 RxJS 的 Subject 类。Subject 是一个特殊的 Observable，它既是 Observer 又是 Observable，可以用来在多个订阅者之间共享数据。\u003c/p\u003e\n\u003cp\u003e2 @Output 装饰器\u003c/p\u003e\n\u003cp\u003e@Output 装饰器用于标记一个属性为输出属性，这样 Angular 可以在编译时识别并处理它\u003c/p\u003e\n\u003cp\u003e3事件监听\u003c/p\u003e\n\u003cp\u003e在父组件中，通过模板绑定来监听子组件的 EventEmitter 事件。\u003c/p\u003e\n\u003ch2 id=\"视图封装view-encapsulation\"\u003e视图封装（View Encapsulation）\u003c/h2\u003e\n\u003cp\u003e用于控制组件样式的可见性和作用域。Angular 提供了三种视图封装模式，\u003c/p\u003e\n\u003ch5\u003e1.1 Emulated（模拟）\u003c/h5\u003e\n\u003cp\u003e这是默认的视图封装模式。在这种模式下，Angular 会模拟 Shadow DOM 的行为，通过为组件的样式添加唯一的选择器前缀，确保组件的样式不会影响其他组件。\u003c/p\u003e\n\u003ch5\u003e1.2 None（无）\u003c/h5\u003e\n\u003cp\u003e在这种模式下，组件的样式将直接应用于全局样式表，没有任何作用域限制。这意味着组件的样式可能会与其他组件的样式发生冲突。\u003c/p\u003e\n\u003ch5\u003e\u003cstrong\u003e1.3 ShadowDom（Shadow DOM）\u003c/strong\u003e\u003c/h5\u003e\n\u003cp\u003e在这种模式下，组件的样式将完全封装在 Shadow DOM 中，确保组件的样式不会影响其他组件，也不会被其他组件的样式所影响。这种模式需要浏览器支持 Shadow DOM。\u003c/p\u003e\n\u003ch2 id=\"变更检测\"\u003e变更检测\u003c/h2\u003e\n\u003ch3\u003e默认\u003c/h3\u003e\n\u003cp\u003e默认策略是最常用的策略，Angular 会自动检测组件及其子组件的所有变化\u003c/p\u003e\n\u003ch3\u003eOnpush\u003c/h3\u003e\n\u003cp\u003e22.2 OnPush 策略\u003c/p\u003e\n\u003cp\u003eOnPush 策略是一种优化策略，适用于纯组件（即组件的输出只依赖于输入）。启用 OnPush 策略后，Angular 只在以下情况下才会检查组件的变更：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e组件的输入属性发生变化\u003c/li\u003e\n\u003cli\u003e组件接收到新的事件（如 @Input、@Output）\u003c/li\u003e\n\u003cli\u003e组件内的异步操作完成（如 Promise、Observable）\u003c/li\u003e\n\u003cli\u003e通过 ChangeDetectorRef.markForCheck\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e要启用 OnPush 策略，可以在组件装饰器中设置 changeDetection 属性：\u003c/p\u003e\n\u003cp\u003eDefault ：\u003c/p\u003e\n\u003cp\u003e这是默认的变更检测策略。每次事件触发时，Angular 会检查所有组件。\u003c/p\u003e\n\u003cp\u003e适用于大多数情况，但可能会导致性能问题，特别是在大型应用中。\u003c/p\u003e\n\u003cp\u003eOnPush：\u003c/p\u003e\n\u003cp\u003e仅在输入属性（@Input）发生变化或事件触发时进行变更检测。\u003c/p\u003e\n\u003cp\u003e适用于纯组件（没有副作用的组件），可以提高性能。\u003c/p\u003e\n\u003cp\u003eChangeDetectorRef 提供了几种方法来管理变更检测过程：\u003c/p\u003e\n\u003cp\u003eChangeDetectorRef 是 Angular 中一个非常重要的类，它提供了对组件变更检测机制的细粒度控制。\u003c/p\u003e\n\u003cp\u003emarkForCheck()：当使用 OnPush 策略时，如果组件的输入属性没有发生变化，但你仍然希望该组件及其祖先组件被检查，则可以调用此方法。这将使得即使没有触发器，也会检查该组件（markForCheck() 不会立即触发变更检测，而是将当前组件及所有父组件标记为需要检测的状态。这意味着如果一个组件或其某个祖先组件使用了 OnPush 策略，调用 markForCheck() 后，Angular 将会在下一次全局变更检测时重新评估这些组件的状态，）\u003c/p\u003e\n\u003cp\u003edetach()：从变更检测树中移除当前组件的变更检测器。这意味着该组件及其子组件将不再执行变更检测，直到重新附加为止。这对于避免不必要的变更检测非常有用，特别是在处理大量数据或复杂计算时8。\u003c/p\u003e\n\u003cp\u003ereattach()：将之前分离出去的变更检测器重新添加回变更检测树中，从而使组件能够再次参与变更检测流程。通常与 detach() 一起使用，以实现局部变更检测8。\u003c/p\u003e\n\u003cp\u003edetectChanges()：强制立即对该组件及其所有子组件执行一次变更检测。这对于确保视图及时反映最新的数据状态特别有帮助，尤其是在异步操作完成之后1。\u003c/p\u003e\n\u003cp\u003echeckNoChanges()：用于调试目的，检查是否存在未预期的状态更改。它会抛出错误，如果发现任何脏值（即未经处理的数据变更）。这个方法在开发阶段很有用，但在生产环境中应该谨慎使用，因为它可能会导致性能问题8\u003c/p\u003e\n\u003ch2 id=\"appmodulets根模块文件\"\u003eapp.module.ts根模块文件\u003c/h2\u003e\n\u003ch2 id=\"angular-cdk\"\u003eAngular CDK\u003c/h2\u003e\n\u003cp\u003eAngular CDK (Component Dev Kit) 是 Angular 团队提供的一套工具和构建块，旨在帮助开发者更轻松地创建高质量的 Angular 组件。CDK 不是一个独立的库，而是作为 @angular/cdk 包的一部分发布，它提供了许多底层功能，这些功能在 Angular Material 中被广泛使用，但也可以独立于 Material 使用。\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e主要特点\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e基础组件\u003c/strong\u003e\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003eCDK 提供了一些基础组件，如 Overlay、Portal、Scrolling 等，这些组件可以用来构建复杂的 UI 组件。\u003c/li\u003e\n\u003cli\u003e例如，Overlay 可以用来创建浮动面板（如对话框、弹出菜单等），而 Portal 可以用来将内容动态插入到 DOM 中。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"angular-指令\"\u003eAngular 指令\u003c/h2\u003e\n\u003cp\u003eAngular 指令是 Angular 框架中的一个重要概念，它们允许你将行为附加到 DOM 元素上。指令可以用来操作 DOM、监听事件、响应数据变化等。Angular 中主要有三种类型的指令：\u003c/p\u003e\n\u003cp\u003e1属性型指令（Attribute Directives）：\u003c/p\u003e\n\u003cp\u003e用于改变元素的外观或行为。\u003c/p\u003e\n\u003cp\u003e通常以 @Directive 装饰器来定义，并通过属性的形式应用到元素上。\u003c/p\u003e\n\u003cp\u003e例如，内置的 ngClass 和 ngStyle 指令。\u003c/p\u003e\n\u003cp\u003e2结构型指令（Structural Directives）：\u003c/p\u003e\n\u003cp\u003e用于在模板中添加或移除 DOM 元素。\u003c/p\u003e\n\u003cp\u003e通常以 * 符号作为前缀，表示它们会影响宿主元素及其子元素。\u003c/p\u003e\n\u003cp\u003e例如，内置的 *ngIf 和 *ngFor 指令。\u003c/p\u003e\n\u003cp\u003e改变元素的行为\u003c/p\u003e\n\u003cp\u003e使用\u0026#x3C;div appHighlight\u003e\u003c/p\u003e\n\u003cp\u003e结构型指令\u003cbr\u003e\nFeaturecheck\u003c/p\u003e\n\u003cp\u003e使用\u003c/p\u003e\n\u003cp\u003e*gdFeatureCheck=’featureName’\u003cbr\u003e\n说明这是一个结构型指令\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003egdFeatureCheck\u003c/strong\u003e：用于传递静态值，不涉及动态计算。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[gdFeatureCheck]\u003c/strong\u003e：用于传递动态值或表达式，会触发变更检测。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e*gdFeatureCheck\u003c/strong\u003e：用于结构型指令，影响 DOM 结构，可以传递静态值或动态值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"应用启动时执行初始化逻辑\"\u003e应用启动时执行初始化逻辑\u003c/h2\u003e\n\u003ch3\u003eAPP_INITIALIZER（使用provideAppInitializer 替换）\u003c/h3\u003e\n\u003cp\u003eAPP_INITIALIZER 是一个用于在应用启动时执行初始化逻辑的注入令牌\u003c/p\u003e\n\u003ch3\u003eprovideAppInitializer\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAPP_INITIALIZER\u003c/strong\u003e：是一个注入令牌，用于在应用启动之前执行初始化逻辑。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eprovideAppInitializer\u003c/strong\u003e：是一个辅助函数，提供了更简洁和类型安全的方式来配置 APP_INITIALIZER。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003cstrong\u003ebootstrapApplication 启动独立组件\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e独立组件的应用，并且你想在应用启动前执行一些初始化逻辑：\u003c/p\u003e\n\u003cp\u003eplatformBrowser().bootstrapModule(MyModule);\u003c/p\u003e\n\u003ch3\u003eMuti:true\u003c/h3\u003e\n\u003cp\u003e，使用 multi: true 可以确保这些提供者都被正确地添加到一个数组中，而不是被覆盖。\u003c/p\u003e\n\u003ch2 id=\"注册拦截器\"\u003e注册拦截器\u003c/h2\u003e\n\u003cp\u003e使用\u003c/p\u003e\n\u003cp\u003ehttpHeaderIntercepter\u003cbr\u003e\n添加请求头\u003c/p\u003e\n\u003cp\u003eErrorIntercepter\u003cbr\u003e\n拿到错误码，转换错误对象\u003c/p\u003e\n\u003cp\u003eLogIntercepter\u003cbr\u003e\n排除文字 图片获取时的log\u003c/p\u003e\n\u003cp\u003etokenIntercepter\u003c/p\u003e\n\u003cp\u003e给http 请求添加token，并且如果没有token的话\u003c/p\u003e\n\u003cp\u003eRetry\u003c/p\u003e\n\u003cp\u003e（timer(0) 表示立即重试）\u003c/p\u003e\n\u003cp\u003e可以定义一个core-interceptors.providers.ts\u003c/p\u003e\n\u003cp\u003e将所有的拦截器放进去\u003c/p\u003e\n\u003cp\u003e1你需要创建一个实现了 HttpInterceptor 接口的类。这个接口只有一个方法 intercept\u003c/p\u003e\n\u003cp\u003e2接下来，你需要在你的应用中注册这个拦截器。你可以通过 providers 数组将拦截器提供给依赖注入系统，并使用 HTTP_INTERCEPTORS 注入令牌。\u003c/p\u003e\n\u003cp\u003e3使用 withInterceptors 和 withInterceptorsFromDi\u003c/p\u003e\n\u003ch2 id=\"httpclient\"\u003eHttpClient\u003c/h2\u003e\n\u003ch3\u003e配置HttpClient\u003c/h3\u003e\n\u003cp\u003eHttpClientModule 在 Angular 16 及更高版本中已被标记为不推荐使用,\u003c/p\u003e\n\u003cp\u003e不需要再导入httpclientModule\u003c/p\u003e\n\u003ch4\u003eprovideHttpClient 函数\u003c/h4\u003e\n\u003ch4\u003e独立组件（standalone component）的应用\u003c/h4\u003e\n\u003ch4\u003e\u003cstrong\u003e使用 NgModule\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eprovideHttpClient\u003c/strong\u003e：这是一个函数，用于配置 HttpClient。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewithInterceptorsFromDi\u003c/strong\u003e：这个函数会从依赖注入器中获取所有已注册的 HTTP_INTERCEPTORS，并将它们添加到 HttpClient 的拦截器链中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e怎么使用HttpClient\u003c/h3\u003e\n\u003ch3\u003e\u003cstrong\u003e将 Observable 转换为 Promise\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e使用 toPromise（RxJS 6.x 及之前版本）\u003c/strong\u003e\u003c/h4\u003e\n\u003ch4\u003e使用firstValueFrom or lastValueFrom\u003c/h4\u003e\n\u003cp\u003e取消订阅\u003cbr\u003e\nSubscription 是一个对象，用于表示对 Observable 的订阅。通过 Subscription 对象，你可以控制订阅的生命周期，包括取消订阅\u003c/p\u003e\n\u003ch3\u003e取消订阅\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e使用 Subscription 管理多个订阅\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果你有多个订阅，可以使用 Subscription 类来管理它们\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e1. private subscriptions: Subscription = new Subscription();\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e这种声明方式创建了一个新的 Subscription 对象，并将其赋值给 subscriptions 属性。这个 Subscription 对象可以用来管理多个订阅，通过 add 方法将多个订阅添加到这个对象中。\u003c/p\u003e\n\u003cp\u003e优点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e集中管理\u003c/strong\u003e\u003c/strong\u003e：可以将多个订阅集中管理在一个 Subscription 对象中。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003e自动取消\u003c/strong\u003e\u003c/strong\u003e：当调用 unsubscribe 方法时，所有添加的订阅都会被自动取消。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果使用\u003c/p\u003e\n\u003cp\u003ethis.subscriptions.push(subscription1);的话，需要遍历所有订阅然后取消\u003c/p\u003e\n\u003cp\u003esubscriptions的声明方式如下：\u003cbr\u003e\nprivate subscriptions: Subscription[] = [];\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003edestroy$？\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eprivate destroy$: Subject\u0026#x3C;void\u003e = new Subject\u0026#x3C;void\u003e();\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e这里定义了一个名为 destroy$ 的私有属性，类型为 Subject\u0026#x3C;void\u003e。void 表示这个 Subject 不会发送任何实际的数据，只是一个信号。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e你调用 this.destroy$.next() 来发出一个信号，表示组件即将销毁。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e然后调用 this.destroy$.complete() 来完成这个 Subject，确保不会再有新的信号发出。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003epipe(takeUntil(this.destroy$)) 创建一个新的 Observable，它会在 this.destroy$ 发出信号时停止发出值。\u003c/p\u003e\n\u003ch2 id=\"国际化\"\u003e国际化\u003c/h2\u003e\n\u003ch3\u003e1实现工厂类（来动态加载和合并翻译文件）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eTranslateLoaderFactory\u003c/strong\u003e\u003c/strong\u003e 这是一个工厂类，返回一个新的类 LazyTranslateLoader，该类实现了 TranslateLoader 接口。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2模块导入\u003c/h3\u003e\n\u003cp\u003eProviders: [brandTranslateService]\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e3使用 TranslateService\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e配置语言（项目中用的是配置brand）\u003c/p\u003e\n\u003ch3\u003e4 \u003cstrong\u003e在模板中使用管道\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e或者在ts中直接\u003cbr\u003e\nthis.brandTranslateService.getText('WELCOME').subscribe((res: string) =\u003e { this.welcomeMessage = res; });\u003c/p\u003e\n\u003ch2 id=\"ngmodule\"\u003e@ngmodule\u003c/h2\u003e\n\u003ch3\u003euseFactory\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003euseFactory\u003c/strong\u003e：是一个工厂函数，用于动态地创建和返回服务实例。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edeps\u003c/strong\u003e：指定工厂函数的依赖项。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eUsevalue\u003c/h3\u003e\n\u003cp\u003e提供的值是静态的，在应用运行时不会改变。\u003c/p\u003e\n\u003ch3\u003eInjectionToken\u003c/h3\u003e\n\u003cp\u003eInjectionToken 是 Angular 中用于创建依赖注入令牌的类。这些令牌可以用来标识那些不能直接通过类来提供的值，例如原始类型（如字符串、数字）、数组或对象等。使用 InjectionToken 可以让你在 DI 系统中明确地指定要注入的值，并且可以为这些值提供一个描述性的名称。\u003c/p\u003e\n\u003ch2 id=\"angular-cdk\"\u003eAngular CDK\u003c/h2\u003e\n\u003cp\u003eAngular CDK (Component Dev Kit) 是 Angular 团队提供的一套工具和组件，旨在帮助开发者构建高质量的 Angular 应用程序。CDK 不仅包括一些可以直接使用的 UI 组件，更重要的是它提供了许多底层服务和工具，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecdk/overlay：用于处理弹出层、对话框等覆盖物相关的逻辑。\u003c/li\u003e\n\u003cli\u003ecdk/drag-drop：支持拖拽交互。\u003c/li\u003e\n\u003cli\u003ecdk/a11y：提供无障碍辅助功能。\u003c/li\u003e\n\u003cli\u003ecdk/layout：提供布局相关服务，例如断点检测。\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"reactive-forms\"\u003eReactive Forms\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eFormGroup\u003c/strong\u003e：表示一组控件（FormControl），可以是简单的输入字段，也可以是其他 FormGroup 或 FormArray。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eFormControl\u003c/strong\u003e：表示单个表单控件，例如文本框、复选框等。你可以为每个 FormControl 添加验证器（Validators）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eFormArray\u003c/strong\u003e：表示一个动态数组，其中可以包含多个 FormControl 或 FormGroup。这对于实现动态添加或移除表单字段非常有用。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eFormBuilder\u003c/strong\u003e：提供了一种简便的方式来创建 FormGroup、FormControl 和 FormArray，简化了表单构建过程。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ethis.fb.array([this.createItem()]) 创建了一个 FormArray，其中包含一个由 createItem 方法返回的 FormGroup。\u003c/p\u003e\n\u003cp\u003e5 formArrayName\u003c/p\u003e\n\u003cp\u003e是 Angular Reactive Forms 中的一个指令，它用于将 FormArray 绑定到模板中的一个 \u0026#x3C;div\u003e 或其他容器元素。使用 formArrayName 指令可以让 Angular 知道哪个 DOM 元素对应于表单模型中的 FormArray\u003c/p\u003e\n\u003cp\u003eformGroup 指令用于将一个 FormGroup 实例绑定到一个 \u0026#x3C;form\u003e 元素或任何其他容器元素上。\u003c/p\u003e\n\u003cp\u003eformControlName 指令用于将一个 FormControl 实例绑定到一个具体的输入元素上。每个带有 formControlName 的输入元素都对应于 FormGroup 中的一个键值对。\u003c/p\u003e\n\u003ch2 id=\"项目结构\"\u003e项目结构\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ecore: 通常包含核心模块和服务，如全局服务、拦截器等。\n\u003cul\u003e\n\u003cli\u003eComponent: Error/pagenotfount/success、\u003c/li\u003e\n\u003cli\u003eFactories: initial-load/translate-loader/app-preloading-strategy\u003c/li\u003e\n\u003cli\u003eGuards\u003c/li\u003e\n\u003cli\u003eInterceptors: error/http-deader/logging/retry/token\u003c/li\u003e\n\u003cli\u003eModels: 接口文件（也可以放在shared目录下）\u003c/li\u003e\n\u003cli\u003eEnums: 枚举文件（也可以放在shared目录下）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ecore-routing.module.ts/core.module.ts\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efeatures: 通常包含应用的各个功能模块，每个功能模块可能包含自己的组件、服务和路由。(如果使用懒加载模块就不用导入到app.module)\u003c/li\u003e\n\u003cli\u003eshared: 通常包含共享的组件、服务和管道等，可以在多个功能模块中复用。\n\u003cul\u003e\n\u003cli\u003eshared.module.ts\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eapp-routing.module.ts: 应用的路由模块，定义了应用的路由配置。\u003c/p\u003e\n\u003cp\u003eapp.module.ts: 应用的根模块，定义了应用的模块配置。\u003c/p\u003e\n\u003cp\u003eassets\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ebrands: 品牌相关的静态资源。\u003c/li\u003e\n\u003cli\u003edocs: 文档相关的静态资源。\u003c/li\u003e\n\u003cli\u003efavicon: 网站的 favicon 图标。\u003c/li\u003e\n\u003cli\u003efonts: 字体文件。\u003c/li\u003e\n\u003cli\u003ei18n: 国际化资源文件。\u003c/li\u003e\n\u003cli\u003eimages: 图片资源。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ecss\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ebrands: 品牌相关的 CSS 文件。\u003c/li\u003e\n\u003cli\u003ecomponents: 组件相关的 CSS 文件。\u003c/li\u003e\n\u003cli\u003efonts: 字体相关的 CSS 文件。\u003c/li\u003e\n\u003cli\u003emixins: CSS 混入文件。\u003c/li\u003e\n\u003cli\u003epage-design: 页面设计相关的 CSS 文件。\u003c/li\u003e\n\u003cli\u003epages: 页面相关的 CSS 文件。\n\u003cul\u003e\n\u003cli\u003eFooter/header/menu\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ereset.scss: 重置样式文件。\u003c/li\u003e\n\u003cli\u003estyles.scss: 主要的样式文件。\n\u003cul\u003e\n\u003cli\u003eH1/h2/font/color/notification/\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eenvironments: 环境配置文件。\u003c/p\u003e\n\u003cp\u003emirage: Mirage.js 相关文件，用于模拟数据。\u003c/p\u003e\n\u003cp\u003emodule-federation.ts: 模块联邦相关的配置文件。\u003c/p\u003e\n\u003cp\u003eEnums\u003c/p\u003e\n\u003cp\u003e最推荐的做法是将枚举放在 shared/models 文件夹中.\u003c/p\u003e\n\u003cp\u003e比如与应用程序配置、环境设置等相关的枚举，可以考虑将其放置在 core 文件夹中\u003c/p\u003e\n\u003ch2 id=\"常见用法\"\u003e常见用法\u003c/h2\u003e\n\u003ch3\u003eng-container 和ng-template\u003c/h3\u003e\n\u003cp\u003eng-container 是 Angular 提供的一个特殊的容器标签，它允许你在模板中创建逻辑分组而不向最终的 DOM 添加额外的节点。这意味着 ng-container 在渲染时不会出现在页面上，也不会影响样式或布局。\u003c/p\u003e\n\u003cp\u003eng-container 还可以与 ngTemplateOutlet 结合使用来递归调用模板，这有助于减少不必要的 DOM 元素嵌套，并且能够更灵活地传递参数给子模板\u003c/p\u003e\n\u003cp\u003eng-template\u003c/p\u003e\n\u003cp\u003e另一方面，ng-template 是一个用于定义模板片段的 Angular 指令。这些模板片段本身并不会直接显示在页面上，而是作为模板的一部分被引用和重用。ng-template 的内容只有在通过特定的指令（如 *ngIf、*ngFor 或 ngTemplateOutlet）显式渲染时才会出现在视图中8。\u003c/p\u003e\n\u003cp\u003eng-template 可以用来创建复杂的条件渲染逻辑，比如根据上下文的不同显示不同部分的内容。通过 context 参数，还可以向模板传递数据，使模板变得更加动态和交互性强4。\u003c/p\u003e\n\u003ch3\u003engTemplateOutlet\u003c/h3\u003e\n\u003cp\u003engTemplateOutlet 是 Angular 框架中的一个内置结构指令，它允许开发者动态地插入由 ng-template 定义的模板内容。这个功能特别有用，尤其是在需要创建高度可定制或复用的组件时。通过 ngTemplateOutlet，你可以将一个提前准备好的 TemplateRef 插入到页面指定的位置，并且可以传递上下文数据给该模板以实现更加灵活的内容展示\u003c/p\u003e\n\u003cp\u003e在父组件中定义一个模板，并在子组件中渲染它：\u003c/p\u003e\n\u003cp\u003eparent.component.html 中定义了一个名为 customContent 的模板，并通过 \u0026#x3C;app-child\u003e 标签将其传递给了子组件。子组件接收到这个模板后，在其自己的模板中使用了 ngTemplateOutlet 来渲染父组件传递过来的内容。同时，还设置了上下文对象 { $implicit: 'someItem' }，使得父组件定义的模板能够获取到传递的数据 item。\u003c/p\u003e\n\u003cp\u003e$implicit 等于let-item\u003cbr\u003e\n$implicit 是一个特殊的上下文变量名称，它用于 ngTemplateOutlet 和其他结构指令中，当定义模板引用变量时，可以用来表示默认传递的数据值\u003c/p\u003e\n\u003cp\u003e除了 $implicit，你也可以添加其他键值对到上下文对象中，以便在模板中使用不同的局部变量名进行绑定。\u003c/p\u003e\n\u003ch3\u003e获取子组件的实例\u003c/h3\u003e\n\u003cp\u003e使用 @ViewChild 获取单个子组件实例\u003c/p\u003e\n\u003cp\u003e使用 @ViewChildren 获取多个子组件实例\u003c/p\u003e\n\u003cp\u003e使用 @ContentChild 和 @ContentChildren 获取内容投影的子组件实例\u003c/p\u003e\n\u003ch2 id=\"optional-skipself\"\u003e@Optional() @SkipSelf()\u003c/h2\u003e\n\u003cp\u003e用于构造函数参数的参数装饰器\u003c/p\u003e\n\u003cp\u003eOptional\u003c/p\u003e\n\u003cp\u003e将参数标记为可选依赖项。如果找不到依赖关系，DI框架将提供null。\u003c/p\u003e\n\u003cp\u003eSkipSelf\u003c/p\u003e\n\u003cp\u003e它告诉DI框架从父注入器开始依赖项解析。分辨率在注射器层次结构中向上工作，因此不会检查本地注射器的提供者。\u003c/p\u003e\n\u003ch2 id=\"rxjs\"\u003eRxjs\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://segmentfault.com/a/1190000021143815\"\u003ehttps://segmentfault.com/a/1190000021143815\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e一种用于异步编程的库。它基于响应式编程模型\u003c/p\u003e\n\u003ch3\u003e观察者\u003c/h3\u003e\n\u003ch4\u003eObserver\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e定义\u003c/strong\u003e\u003c/strong\u003e：一个 Observer 是一个拥有三个可选方法的对象或实现这些方法的函数，用于接收来自 Observable 的通知：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003enext(value)\u003c/strong\u003e：当 Observable 发出一个值时调用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eerror(error)\u003c/strong\u003e：当 Observable 遇到错误并终止时调用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ecomplete()\u003c/strong\u003e：当 Observable 正常完成且不再发出更多值时调用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e作用：Observer 负责处理从 Observable 接收到的数据或事件，并对这些数据或事件做出响应。它订阅了 Observable 后，就会开始监听由该 Observable 发出的通知。\u003c/p\u003e\n\u003ch4\u003eObservable\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003e定义\u003c/strong\u003e\u003c/strong\u003e：Observable 是一个可以被订阅的对象，它代表了一个可能异步发生的值或事件序列。一旦有观察者订阅它，Observable 就会开始发送通知给这个观察者。\u003c/p\u003e\n\u003cp\u003e生产者与消费者：Observable 是生产者，负责生成数据流；而 Observer 是消费者，负责消费这些数据。\u003c/p\u003e\n\u003ch4\u003e其他创建方法\u003c/h4\u003e\n\u003ch4\u003e\u003cstrong\u003e使用静态创建方法\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eRxJS 提供了多个静态方法来创建特定类型的 Observables，例如从数组、Promise、事件等创建。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efrom: 将任何可迭代对象或 Promise 转换为 Observable。\u003c/li\u003e\n\u003cli\u003eof: 创建一个发出一系列指定值的 Observable。\u003c/li\u003e\n\u003cli\u003einterval: 创建一个每隔一定时间发出递增数值的 Observable。\u003c/li\u003e\n\u003cli\u003etimer: 创建一个在指定延迟后开始发出值的 Observable。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e订阅\u003c/h3\u003e\n\u003cp\u003e什么是订阅？订阅是表示可支配资源的对象，通常是 Observable 的执行。\u003c/p\u003e\n\u003cp\u003e取消订阅\u003c/p\u003e\n\u003cp\u003e1 subscription.unsubscribe();\u003c/p\u003e\n\u003cp\u003e2 private subscriptions: Subscription[] = [];\u003c/p\u003e\n\u003cp\u003e3 通过 \"adding\" 一个订阅到另一个订阅来做到这一点：\u003c/p\u003e\n\u003ch3\u003eOf\u003c/h3\u003e\n\u003cp\u003eof 方法可以接受一系列的值，并立即创建一个 Observable，该 Observable 会依次发出这些值，并在最后一个值发出之后完成。\u003c/p\u003e\n\u003ch3\u003eFrom\u003c/h3\u003e\n\u003cp\u003efrom 方法可以接受任何可迭代的对象（如数组、字符串、Set、Map，promise 等），并创建一个 Observable，该 Observable 会依次发出可迭代对象中的每个元素，并在最后一个元素发出之后完成。\u003c/p\u003e\n\u003cp\u003e你可以使用 from 将一个 Promise 转换为 Observable。\u003c/p\u003e\n\u003ch3\u003ePipe\u003c/h3\u003e\n\u003cp\u003epipe 方法是一个函数，它接受一系列的操作符作为参数，并返回一个新的操作符\u003c/p\u003e\n\u003ch3\u003eSubject\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eSubject\u003c/strong\u003e\u003c/strong\u003e：是一个可以被多个观察者订阅的可观察对象，同时它可以向观察者发送值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cstrong\u003eBehaviorSubject\u003c/strong\u003e\u003c/strong\u003e：始终保持最新的值，并且新订阅的观察者可以接收到这个最新的值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSubject 是一个特殊的对象，它同时具备 Observable 和 Observer 的特性。具体来说，Subject 可以作为 Observable 被多个订阅者订阅，同时也可以作为 Observer 接收数据并将其广播给所有订阅者。\u003c/p\u003e\n\u003ch3\u003emergeMap\u003c/h3\u003e\n\u003cp\u003e假设你有一个用户 ID 列表，你需要根据这些 ID 获取用户的详细信息。你可以使用 flatMap 来实现这一点：\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003eswitchMap\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eswitchMap\u003c/strong\u003e: 类似于 mergeMap，但当新的 Observable 发出时，它会取消之前的 Observable。\u003c/p\u003e\n\u003cp\u003e/ 只输出最后一个 Observable 的结果\u003c/p\u003e\n\u003ch3\u003emergeAll\u003c/h3\u003e\n\u003cp\u003e假设你有一个发出多个 Observables 的 Observable，你需要将这些 Observables 的值合并到一个单一的 Observable 中\u003c/p\u003e\n\u003ch3\u003econcatWith和concatAll\u003c/h3\u003e\n\u003ch4\u003econcatWith\u003c/h4\u003e\n\u003cp\u003e将当前的 Observable 与另一个 Observable 连接起来，只有当前一个 Observable 完成后，才会开始订阅下一个 Observable。\u003c/p\u003e\n\u003cp\u003e在这个例子中，source1 先发出 1, 2, 3，然后 source2 发出 4, 5, 6。concat 确保了 source1 完成后再开始 source2\u003c/p\u003e\n\u003ch4\u003econcatAll\u003c/h4\u003e\n\u003cp\u003e假设你有一个发出多个 Observable 的 Observable，你需要按顺序处理这些 Observable：\u003c/p\u003e\n\u003cp\u003e如果不使用concatAll\u003c/p\u003e\n\u003cp\u003e返回的是两个observable.\u003c/p\u003e\n\u003ch4\u003econcatAll 和mergeAll\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003econcatAll\u003c/strong\u003e 适合于需要保持内部 Observables 顺序的情况，它会确保按照它们被发出的顺序依次执行。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003emergeAll\u003c/strong\u003e 适用于需要同时并发处理多个内部 Observables 的情况，它可以将所有内部 Observable 的输出合并到一个单一的流中，但不保证值的顺序。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTap\u003c/h3\u003e\n\u003cp\u003e用于对来自源 observable 的通知执行副作用\u003c/p\u003e\n\u003ch3\u003e\u003c/h3\u003e\n\u003cp\u003eforkJoin\u003c/p\u003e\n\u003cp\u003e当有一组 observables，但你只关心每个 observable 最后发出的值时，此操作符是最适合的。它可能与 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all%22%20%5Ct%20%22_blank\"\u003ePromise.all\u003c/a\u003e 的使用方式类似。\u003c/p\u003e\n\u003ch3\u003epairwise\u003c/h3\u003e\n\u003cp\u003e假设你有一个数字序列，你想计算每对相邻值之间的差值：\u003c/p\u003e\n\u003cp\u003e假设你有一个事件流，你想检测每次值变化的情况：\u003c/p\u003e\n\u003ch3\u003eretry\u003c/h3\u003e\n\u003ch3\u003eRace\u003c/h3\u003e\n\u003cp\u003e使用首先发出值的 observable 。\u003c/p\u003e\n\u003ch3\u003estartWith\u003c/h3\u003e\n\u003ch3\u003etimer\u003c/h3\u003e\n\u003cp\u003etimer 接收第二个参数，它决定了发出序列值的频率，在本例中我们在1秒发出第一个值\u003c/p\u003e\n\u003ch3\u003eInterval\u003c/h3\u003e\n\u003ch3\u003epublish\u003c/h3\u003e\n\u003ch3\u003eShare\u003c/h3\u003e\n\u003ch3\u003eshareReplay\u003c/h3\u003e\n\u003cp\u003e共享源 observable 并重放指定次数的发出。\u003c/p\u003e\n\u003ch3\u003edebounce\u003c/h3\u003e\n\u003cp\u003e只有在另一个 Observable 确定的特定时间跨度过去且没有另一个源发射时，才从源 Observable 发出通知。\u003c/p\u003e\n\u003ch3\u003e将Observable转换成Promise\u003c/h3\u003e\n\u003cp\u003eTsconfig\u003c/p\u003e\n","h2Titles":[{"title":"模块","id":"模块"},{"title":"数据传输","id":"数据传输"},{"title":"装饰器 decorator","id":"装饰器-decorator"},{"title":"依赖注入（Dependency Injection, DI）模式","id":"依赖注入dependency-injection-di模式"},{"title":"providedIn: 'root'","id":"providedin-root"},{"title":"设计模式","id":"设计模式"},{"title":"路由","id":"路由"},{"title":"EventEmitter","id":"eventemitter"},{"title":"视图封装（View Encapsulation）","id":"视图封装view-encapsulation"},{"title":"变更检测","id":"变更检测"},{"title":"app.module.ts根模块文件","id":"appmodulets根模块文件"},{"title":"Angular CDK","id":"angular-cdk"},{"title":"Angular 指令","id":"angular-指令"},{"title":"应用启动时执行初始化逻辑","id":"应用启动时执行初始化逻辑"},{"title":"注册拦截器","id":"注册拦截器"},{"title":"HttpClient","id":"httpclient"},{"title":"国际化","id":"国际化"},{"title":"@ngmodule","id":"ngmodule"},{"title":"Angular CDK","id":"angular-cdk"},{"title":"Reactive Forms","id":"reactive-forms"},{"title":"项目结构","id":"项目结构"},{"title":"常见用法","id":"常见用法"},{"title":"@Optional() @SkipSelf()","id":"optional-skipself"},{"title":"Rxjs","id":"rxjs"}],"title":"Angular","date":"2025-1-10","description":"Angular 是一个 Web 框架，能够帮助开发者构建快速、可靠的应用。"},"allPostsData":[{"id":"前端基础","title":"前端基础","date":"2025-1-18","description":"内容包括一些前端的基础理论","h2Titles":[{"title":"HTML","id":"html"},{"title":"CSS3.0","id":"css30"},{"title":"CSS","id":"css"},{"title":"less和sass","id":"less和sass"},{"title":"Css","id":"css"},{"title":"Script","id":"script"},{"title":"Jquery","id":"jquery"},{"title":"HTML5","id":"html5"},{"title":"BootStrap","id":"bootstrap"},{"title":"三层架构","id":"三层架构"},{"title":"MVC","id":"mvc"},{"title":"AngularJS","id":"angularjs"},{"title":"跨域请求","id":"跨域请求"},{"title":"D3","id":"d3"},{"title":"JS","id":"js"},{"title":"Aurelia","id":"aurelia"},{"title":"ES6","id":"es6"},{"title":".NET","id":"net"},{"title":"Webpack","id":"webpack"},{"title":"C#","id":"c"},{"title":"Webpack 配置","id":"webpack-配置"},{"title":"Gulp","id":"gulp"},{"title":"协议","id":"协议"},{"title":"网络安全","id":"网络安全"},{"title":"JS函数式编程","id":"js函数式编程"},{"title":"代码简洁","id":"代码简洁"},{"title":"前端单元测试","id":"前端单元测试"},{"title":"SSR","id":"ssr"},{"title":"SPA","id":"spa"},{"title":"模式","id":"模式"},{"title":"数据结构","id":"数据结构"},{"title":"Git命令","id":"git命令"},{"title":"使用 PRPL 模式应用即时加载","id":"使用-prpl-模式应用即时加载"},{"title":"面向对象","id":"面向对象"},{"title":"Animation","id":"animation"},{"title":"Flex布局","id":"flex布局"},{"title":"Flutter","id":"flutter"},{"title":"JSBridge","id":"jsbridge"},{"title":"Serverless","id":"serverless"},{"title":"精读前后端渲染之争","id":"精读前后端渲染之争"},{"title":"事件驱动和数据驱动","id":"事件驱动和数据驱动"},{"title":"IndexDB 实践","id":"indexdb-实践"},{"title":"Blob","id":"blob"},{"title":"Docker","id":"docker"},{"title":"Responsive/images","id":"responsiveimages"},{"title":"Rem/em","id":"remem"},{"title":"Learnsite","id":"learnsite"},{"title":"LeetCode","id":"leetcode"},{"title":"SQL","id":"sql"},{"title":"Express","id":"express"},{"title":"MySQL","id":"mysql"},{"title":"代理服务器","id":"代理服务器"},{"title":"解释性语言和编译型语言","id":"解释性语言和编译型语言"},{"title":"空间复杂度和时间复杂度","id":"空间复杂度和时间复杂度"},{"title":"Electron","id":"electron"},{"title":"可视化","id":"可视化"},{"title":"编程","id":"编程"},{"title":"计算机基础","id":"计算机基础"},{"title":"缓存","id":"缓存"}]},{"id":"TypeScipt","title":"Typescript","date":"2025-1-11","description":"Js的超集，面向对象的编程语言，包含类和接口的概念","h2Titles":[{"title":"为什么推荐使用TS","id":"为什么推荐使用ts"},{"title":"类型检查","id":"类型检查"},{"title":"Const","id":"const"},{"title":"元组类型tuple","id":"元组类型tuple"},{"title":"枚举","id":"枚举"},{"title":"类","id":"类"},{"title":"接口","id":"接口"},{"title":"interface 和 type 的区别","id":"interface-和-type-的区别"},{"title":"泛型","id":"泛型"},{"title":"类型断言","id":"类型断言"},{"title":"配置tsconfig.json","id":"配置tsconfigjson"},{"title":"数组的类型","id":"数组的类型"},{"title":"重载","id":"重载"},{"title":"重写","id":"重写"},{"title":"三斜线指令","id":"三斜线指令"},{"title":"Mixin","id":"mixin"}]},{"id":"React","title":"React","date":"2025-1-10","description":"","h2Titles":[{"title":"基本写法","id":"基本写法"},{"title":"Dom diff","id":"dom-diff"},{"title":"React 特点","id":"react-特点"},{"title":"虚拟 dom 和真实 dom","id":"虚拟-dom-和真实-dom"},{"title":"组件","id":"组件"},{"title":"元素","id":"元素"},{"title":"生命周期","id":"生命周期"},{"title":"ReactDOM","id":"reactdom"},{"title":"ReactDOMServer","id":"reactdomserver"},{"title":"ReactTestUtils","id":"reacttestutils"},{"title":"Hook","id":"hook"},{"title":"Redux","id":"redux"},{"title":"问题","id":"问题"},{"title":"Fiber","id":"fiber"},{"title":"useImperativeHandle","id":"useimperativehandle"},{"title":"BrowserRouter 和 HashRouter","id":"browserrouter-和-hashrouter"},{"title":"React 服务端渲染（Server-Side Rendering, SSR）","id":"react-服务端渲染server-side-rendering-ssr"},{"title":"Next.js 服务端渲染的基本步骤","id":"nextjs-服务端渲染的基本步骤"},{"title":"Navigate","id":"navigate"},{"title":"搭建步骤","id":"搭建步骤"},{"title":"React","id":"react"}]},{"id":"Angular","title":"Angular","date":"2025-1-10","description":"Angular 是一个 Web 框架，能够帮助开发者构建快速、可靠的应用。","h2Titles":[{"title":"模块","id":"模块"},{"title":"数据传输","id":"数据传输"},{"title":"装饰器 decorator","id":"装饰器-decorator"},{"title":"依赖注入（Dependency Injection, DI）模式","id":"依赖注入dependency-injection-di模式"},{"title":"providedIn: 'root'","id":"providedin-root"},{"title":"设计模式","id":"设计模式"},{"title":"路由","id":"路由"},{"title":"EventEmitter","id":"eventemitter"},{"title":"视图封装（View Encapsulation）","id":"视图封装view-encapsulation"},{"title":"变更检测","id":"变更检测"},{"title":"app.module.ts根模块文件","id":"appmodulets根模块文件"},{"title":"Angular CDK","id":"angular-cdk"},{"title":"Angular 指令","id":"angular-指令"},{"title":"应用启动时执行初始化逻辑","id":"应用启动时执行初始化逻辑"},{"title":"注册拦截器","id":"注册拦截器"},{"title":"HttpClient","id":"httpclient"},{"title":"国际化","id":"国际化"},{"title":"@ngmodule","id":"ngmodule"},{"title":"Angular CDK","id":"angular-cdk"},{"title":"Reactive Forms","id":"reactive-forms"},{"title":"项目结构","id":"项目结构"},{"title":"常见用法","id":"常见用法"},{"title":"@Optional() @SkipSelf()","id":"optional-skipself"},{"title":"Rxjs","id":"rxjs"}]},{"id":"算法相关","title":"算法","date":"2024-10-10","description":"这里会总结算法相关的内容","h2Titles":[{"title":"每五秒打印一个数字","id":"每五秒打印一个数字"},{"title":"async 函数的实现","id":"async-函数的实现"},{"title":"输入一个promise和一个时间","id":"输入一个promise和一个时间"},{"title":"实现promise.all","id":"实现promiseall"},{"title":"虚拟dom 转换成真实dom","id":"虚拟dom-转换成真实dom"},{"title":"加密算法","id":"加密算法"}]},{"id":"Node","title":"Node","date":"2024-03-14","description":"Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，用于在服务器端运行 JavaScript 代码。","h2Titles":[{"title":"Express","id":"express"},{"title":"Communication","id":"communication"},{"title":"I/O","id":"io"},{"title":"Synchronous and Asynchronous","id":"synchronous-and-asynchronous"},{"title":"Eventloop","id":"eventloop"},{"title":"V8","id":"v8"},{"title":"FS","id":"fs"},{"title":"Script","id":"script"},{"title":"HTTP","id":"http"},{"title":"mongoDB","id":"mongodb"},{"title":"Template engine","id":"template-engine"},{"title":"JWT","id":"jwt"},{"title":"Passport.js","id":"passportjs"},{"title":"OAuth","id":"oauth"},{"title":"Node API retry","id":"node-api-retry"},{"title":"Others","id":"others"}]}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"Angular"},"buildId":"ioEOhEUsxyZDSqw7qI6q_","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>