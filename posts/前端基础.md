---
title: '前端基础'
date: '2025-1-18'
description: '内容包括一些前端的基础理论'
---


# 前端基础

## HTML

HTML（Hyper Text Markup Language）超文本标记语言：制作网页的语言，基于浏览器运行的，解释性的语言，不需要编译，语法不区分大小写，由W3C组织创造，目前的版本分为html4.01和html5两大版本

基本语法：&lt;标签名称&gt; &lt;/标签名称&gt; 成对标签 &lt;标签名称&gt; 没有结束的单一标签

创建一个网页，扩展名.html，一般网站主页规范名称index.html default.html

Html的基本结构：

&lt;html&gt;

&lt;head&gt;

网页的文档的定义

&lt;/head&gt;

&lt;body&gt;

网页的文档的内容

&lt;/body&gt;

&lt;/html&gt;

嵌套标签，内层标签要缩进（tab键）

编码：每个国家都有自己的语言编码，网页需要显示的设置编码，推荐设置UTF-8这种unicode编码(全球统一编码)

DreamWeaver是一个所见即所得的网页开发工具，简单的说，就是可以自动生成标签

文档类型（doctype）：作用是让浏览器知道当前的网页使用的是那种html文档语法，html4系列，html5系列，xhtml系列，更好的解析html内容

html属性：是对标签具体的设置，每个标签都有0到多个属性，设置：属性名称=”属性值”

meta标签设置元数据，根据属性不同，功能也不同

&lt;meta charset="utf-8"&gt; 设置文档编码

Web颜色表示法有三种：

16进制数字表示法：#000000纯黑 #ffffff纯白 六位可以简写为三位数字，例如#0cc，换算为#00cccc

英文单词表示法，例如red green blue yellow gray

RGB表示法，CSS支持  

注释：让浏览器忽略执行 &lt;!-- 注释文字内容 --&gt;

实体字符：对特殊字符进行转义

< &lt;

\> &gt;

空格 &nbsp;

双引号 &quot;

&符号 &amp;

文字相关的标签：

&lt;font&gt; ：属性 size字号 color颜色 face字体

&lt;b&gt;加粗 &lt;i&gt;倾斜 &lt;u&gt;下划线 &lt;strong&gt;加粗 &lt;em&gt;倾斜 &lt;sub&gt;下标 &lt;sup&gt;上标

段落相关的标签：

h1~h6标题文字

&lt;p&gt; 段落文字

&lt;br&gt; 换行

超级链接：&lt;a&gt;标签 方便用户点击定向到一个url，链接的载体可以是文字和图片

href属性：链接的url

target属性：打开链接的方式 属性值 \_self当前窗口（默认） \_blank新窗口 \_parent父框架 \_top最外层框架

title属性：鼠标椅上提示文字

锚点链接：链接到网页一个具体位置 &lt;a href=”#锚点名称”&gt;

定义锚点&lt;a name=”锚点名称”&gt;

定义锚点方式2：在元素中用id属性定义锚点名称

图片：img标签

src属性：图片文件的路径

alt属性：替代文字，在图片无法显示的时候会显示，另一个作用就是作为SEO搜索引擎优化

width属性：图片宽度 像素或者百分比单位

height属性：图片高度，同上

引用外部资源的路径问题

路径表示法：

物理路径：直接用驱动器下的目录表示，例如c:\\abc\\123\\a.jpg

绝对路径：引用url 例如<http://www.sohu.com/img/Harvest.jpg>

相对路径：

**相对于当前位置：../代表上一级目录**

相对于根目录：以/开头表示根目录，这种路径表示法必须基于服务器运行

水平线：&lt;hr&gt;标签

width属性：宽度

align属性：对齐方式，left center right

size属性：高度

noshade属性：单一属性，没有属性值，代表是否有阴影

color属性：颜色

预格式化：&lt;pre&gt;标签 把源代码中的格式体现到浏览器中

自定义列表：&lt;dl&gt;标签代表列表 &lt;dt&gt;标签代表标题 &lt;dd&gt;标签代表内容

有序列表：&lt;ol&gt;代表列表 &lt;li&gt;代表一个条目

无序列表：&lt;ul&gt;代表列表 &lt;li&gt;同上

div是排版布局中最常用的标签元素，本身是一个块级元素

span是一个内联元素，和a是相同性质

块级元素（block）：每个元素必须占据一行，可以设置宽度高度，例如div h1~h6 p hr

内联元素（inline）：多个元素可以在一行，不可使设置宽度高度，例如span a

内联块级（inline-block）：多个元素可以在一行，可以设置宽度高度，例如 img 表单元素

网页排版布局的方式，主流方式有两种：

1. 表格排版
2. CSS+DIV

**表格**：基本的三个标签组成 &lt;table&gt;表格 &lt;tr&gt;行 &lt;td&gt;单元格 &lt;th&gt;标题单元格 &lt;thead&gt;表格头部区域 &lt;tbody&gt; 表格内容区域 &lt;tfoot&gt;表格底部区域

Table标签的属性：border边框的宽度 width宽度 height高度 bgcolor背景色 cellpadding填充（单元格内边距） cellspacing间距（单元格外边距）

Tr和td标签的属性：align水平对齐 valign垂直对齐：top middle bottom width宽度 height高度 bgcolor背景色

合并单元格：colspan单元格跨列数 rowspan单元格跨行数 大量的合并单元格会使代码变得混乱，建议用表格嵌套布局来代替合并单元格

id属性和name属性的区别：id属性每个元素都有，name属性只有少数的元素有，例如form img frame，id必须是网页中唯一的，不能重复，name属性值在网页中允许重复。

表单：&lt;form&gt;标签 表单可以包含表单元素

id：通用属性，id名称

name：表单名称

action：提交的url地址

method：提交数据的方式，get（默认）和post

单行文本框：&lt;input type=”text”&gt;

size：字符宽度

maxlength：允许最多字符数

readonly：只读（单一属性）

disabled：禁用，和只读不同，禁用会使表单元素的数据无法提交

value：默认值

placeholder：输入提示（h5属性）

密码框：&lt;input type=”password”&gt; 属性同文本框

文本区域：&lt;textarea&gt; 没有value属性，默认值是写在标签中的

cols：列宽

rows：行高

单选按钮：&lt;input type=”radio”&gt;

name：单选按钮同一组的name名称必须相同

checked：默认选中（单一属性）

value：设置单选的value值

label标签可以辅助单选复选的文字绑定，唯一的属性就是for对应单选复选的id

复选按钮：&lt;input type=”checkbox”&gt; 属性同单选按钮 一组复选按钮的name也必须相同

列表框：&lt;select&gt;和&lt;option&gt;

select标签属性：size显示的条目数量 multiple是否允许多选

option标签属性：value设置值 selected默认选中

文件域：&lt;input type=”file”&gt;：上传文件的表单必须要设置enctype属性值为multipart/form-data（二进制数据），默认是application/x-www-form-urlencoded（纯文本数据） 多文件选中需要设置multiple属性

隐藏域：&lt;input type=”hidden”&gt; 用户看不见的表单元素，一般设置一个需要提交但是不需要用户看到的数据

三种按钮：

提交按钮：&lt;input type=”submit”&gt;

重置按钮：&lt;input type=”reset”&gt;

普通按钮：&lt;input type=”button”&gt;

&lt;button&gt;标签也可以产生按钮

Fieldset字段集：产生一个包围表单元素的 配合legend标题文字

框架概念：一个浏览器窗口，可以显示不同的网页，框架是对窗口进行分割，框架的网页数量是n+1

框架集：&lt;frameset&gt;标签 包含一到多个&lt;frame&gt;

cols属性：水平分割的设置

rows属性：垂直分割的设置

frameborder属性： 是否显示边框 yes no , 1 0

framespacing属性：边距大小，IE特有

框架：&lt;frame&gt;标签 一个frame就是一个单独的分割窗口

src属性：引用的网页路径

noresize属性：不允许用户调整大小

scrolling属性：滚动条设置 auto默认 no无滚动条 yes永远出现滚动条

框架页本身没有body标签，没有自己的内容，是引用其他网页的内容

浮动框架：&lt;iframe&gt;标签，可以灵活的潜入到网页的任何位置，不需要分割窗口

多媒体：&lt;embed&gt;标签 可以在网页中潜入视频和音频 html4中，浏览器本身是没有播放音频视频的能力，是需要借助系统的插件播放器来播放

滚动效果：&lt;marquee&gt;标签

### 垂直margin失效问题的解决办法



1. 父元素有Overflow: hidden
2. 父元素有border
3. 父元素position设置absolute或者fixed，或者float浮动，脱离文档输出流
4. 父元素Display: inline-block

### 浮动元素会导致父元素高度塌陷，解决的方法

浮动布局中，父元素的内容高度默认是被子元素撑开的，但子元素浮动后，便脱离了文档流，因此无法撑起父元素，从而导致父元素高度丢失

1. 父容器设置固定高度
2. 最后一个浮动子元素的后面，加上一个任意块级元素应用clear清除浮动样式
3. 父元素应用overflow:hidden样式，在IE6下需要用zoom:1样式做兼容
4. 用伪元素动态的在父元素的最后输出一个空内容，在空内容上应用清除浮动样式



position：设置元素的定位方式，取值：

static：正常的文档输出流，无法使用left top right bottom属性（默认）

absolute：绝对定位，可以使用left top right bottom进行定位，脱离文档输出流，absolute元素在设置left top right bottom之前位置不会相对于原来的位置有任何变化（位置跟随）

如果有父元素，且父元素设置了position:fixed 或 absolute 或 relative，相对于父元素的原点定位，如果不是，则相对于网页原点定位

fixed：永远相对于视口定位，脱离文档输出流

relative：相对定位，正常文档输出流，利用left top right bottom相对于原理的位置进行偏移

盒子的叠放次序问题：

1. 相同的定位下，默认就是下面叠放次序比上面高
2. 设置position叠放次序（非static）比默认高
3. 设置z-index值越大，叠放次序越高，z-index设置为负数，叠放次序要低于正常文档输出流
4. 设置position叠放次序比float浮动高

背景的相关样式：

background-color：背景颜色

background-image：背景图片

background-repeat：平铺的方式 repeat默认平铺 no-repeat不平铺 repeat-x横向平铺 repeat-y纵向平铺

background-attachment：背景是否固定 fixed为固定

background-position：设置背景图片的位置，

百分比：偏移量=（容器的宽度-图片的宽度）\*百分比 高度也是同样道理 可以为负数

像素：直接设置偏移量，也可以为负数

固定位置：center left right top bottom

background：背景多个样式的合并写法

雪碧图（CssSprite）：把多个图片图标合成一个图片，利用css的背景图片位置偏移单独显示某一个图标，主要好处就是减少网络连接的请求次数，提高效率，网站优化。

代码重构：重新组织html和css，减少冗余代码，让代码结构更加健壮。

border-collapse：相邻边框是否合并 collapse合并

样式的继承：子元素直接应用父元素的样式设置，有一些样式默认就可以被子元素继承，例如 font-size color line-height

显式继承：inherit

引用外联样式表的第二种的方式

&lt;style&gt;

@import “css文件路径”;

&lt;/style&gt;

如果同时用&lt;link&gt;和@import，&lt;link&gt;的加载比@import快

clip：裁剪，必须是postion:absolute元素才可以应用

网站结构：html画面 images（图片文件） css（样式文件） js（程序脚本）

reset.css文件：统一重写浏览器的默认元素样式

区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。

　　区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。

　　区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。

　　区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。

### [BFC(块级格式化上下文)](https://blog.csdn.net/m0_46613429/article/details/119213853)

#### 用于决定盒子布局以及浮动互相影响范围的一个区域

用于决定盒子布局以及浮动互相影响范围的一个区域。  
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素

有BFC属性的容器可以包含浮动元素、会阻止外边距折叠、可以阻止元素被浮动元素覆盖。

什么是BFC：Block Formatting Context，解释为块级格式化上下文

一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：

1、float的值不是none。（float:left 或者float:right）

2、position的值不是static或者relative。（position:absolute或者position:fixed）

3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex

4、overflow的值不是visible（overflow:hidden、overflow:scroll）

5、父元素与正常文件流的子元素（非浮动子元素）自动形成一个BFC

<https://my.oschina.net/u/2612473/blog/2221555>

BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。

垂直margin合并的问题：垂直的margin，会合并为一个margin，取两者之间的最大值

border：边框 上下左右可以单独设置 三个样式：宽度，颜色，线型可以单独设置

outline：外边框，是在border之外的边框

overflow：溢出容器 visible默认，正常显示 hidden超出部分隐藏 scroll固定有滚动条 auto溢出后出现滚动条

### 选择器的分类

1. **元素选择器，标签名称作为选择器 例如 p h1 table**
2. **类选择器，用.语法定义类名，然后在元素中用class属性应用**
3. **Id选择器，用#语法定义，指定id的元素会自动应用样式**
4. 通配选择器，用\*定义，选择所有元素
5. 后代选择器，语法：E F，E和F是元素，类，id选择器任意情况 例如 ul li，#div1 a，.p1 .span1
6. 父子选择器，语法：E>F，例如 ul>li ，#div1>a
7. 群组选择器，语法：E,F 例如 p,h1,h2
8. 属性选择器：语法：E\[属性\] E\[属性=值\] 例如input\[size\] input\[type=text\]

#### 伪类选择器

#### （**表单相关的伪类：checked, enabled**）

(文档类：:first-child)

语法：

- 1. E:link未访问过的链接状态
  2. E:visited访问过时的样式
  3. E:hover 鼠标悬停时的样式
  4. E:active 鼠标按下时的样式（激活）
  5. E:focus 获得焦点是的样式

1. 伪元素选择器：语法E:after E:before 通过css添加页面内容，必须配合content属性

CSS 伪元素用来选择和添加非内容产生的元素

**选择器优先级**：id选择器>类选择器>元素选择器 行内样式>内嵌样式>外联样式

## CSS

在Codepen上最受欢迎的十个Demo <https://codepen.io/jh3y/full/WNxBLbB>  
<https://dev.to/fabiogiolito/create-a-color-theme-with-these-upcoming-css-features-4o83>  
<https://segmentfault.com/a/1190000041826742>  
CSS custom properties are declared by words prefixed with two dashes (--), and accessed using the var() function.

Css（Cascade Style Sheet）级联式样式表，html本身的语法特点决定只能决定页面显示的内容，但是html的样式功能极其薄弱，所以网页的样式格式基本都是由css语法控制的。

使用css控制网页的样式，优点：样式选择多，可以统一控制网页的格式。

目前有两个版本：css2.1 css3

CSS的使用方式

1. 在&lt;head&gt;中加入&lt;style&gt;标签（嵌入式）
2. 外联css文件（外联式）用&lt;link&gt;标签在html中引用
3. 直接在标签中用style属性设置样式（行内样式）

定义样式：选择器 {样式1：值;样式2：值;……}

### @keyframes 自定义动画

animation 调用自定义动画

animation-name 调用的动画名称

animation-duration 动画执行的时间

animation-timing-function 动画执行的类型，默认ease

animation-delay 动画延迟时间

animation-iteration-count 动画执行次数 infinite无限次

animation-direction 是否有反向动画 alternate为有反向动画，默认没有

animation-fill-mode 动画执行结束后的状态

animation-play-state 动画是否暂停 running运动 pause暂停  
<br/>

### sidenav

<https://web.dev/building-a-sidenav-component/>

是css2.1的升级版本，多出了很多css样式，现在已经得到了绝大多数的浏览器的支持，IE8只支持其中一小部分，在移动端支持良好，因为移动端是安卓，苹果手机占大众化，所以谷歌内核（webkit）的浏览器是最多的。

### 选择器的权重

元素选择器 1

类选择器 10

Id选择器 100

行内样式 1000

!important 权重最高！

### CSS 加载和渲染阻塞

解析阻塞：浏览器在解析 HTML 文档时，遇到 &lt;link rel="stylesheet"&gt; 标签时会暂停解析 HTML，直到 CSS 文件完全加载并解析完毕。这是因为浏览器需要确保在渲染页面之前，所有的样式规则都已经准备好，以避免出现“闪屏”（FOUC，Flash of Unstyled Content）现象。

渲染阻塞：即使 HTML 解析继续进行，浏览器也不会开始渲染页面，直到所有的关键样式表（即 &lt;link rel="stylesheet"&gt; 标签引用的样式表）都已加载完毕。这是因为浏览器需要确保页面的视觉效果是完整的，不会在用户面前显示不完整的样式。

JavaScript 执行阻塞：由于 CSS 加载会阻塞 HTML 解析，因此也会间接阻塞 JavaScript 的执行。当浏览器遇到 &lt;script&gt; 标签时，它会暂停 HTML 解析并执行 JavaScript 代码。如果在此之前有未加载完毕的 CSS 文件，HTML 解析会被阻塞，进而导致 JavaScript 代码的执行也被阻塞。

伪类选择器，例如:link :hover等等权重是1

属性选择器，例如\[href\] 权重是10

在权重完全相同情况下，下面声明的优先级比上面声明的高。

字体相关样式：

font-family：字体，可以设置多个，以第一个好用的为准，安全字体：系统一定安装的字体

font-size：字号，单位可以px和百分比，其他还可以是em rem，webkit内核浏览器不支持小于12px的字号，需要做特殊设置

color ：文字颜色

font-weight：加粗 bold加粗 normal取消加粗

font-style：倾斜 italic倾斜 normal正常

text-decoration：文字修饰 none无 underline下划线 overline上划线 line-through删除线

line-height：行高，单位可以是数字，百分比，和固定像素，（百分比和数字都是以当前字号为基数做换算）

text-indent：文字缩进，可以为负数

text-transform：大小写转换

font：字号行号字体的合并写法

white-space：强制不换行nowrap

word-wrap:强制换行break-word

text-align：水平对齐 left center right

盒子模型：一个完整的盒子模型是由四部分组成，内容 padding（内边距） border（边框） margin（外边距）

padding：内边距，可以上下左右单独设置，也可以写出合并写法 一个值：padding：上下左右，两个值：padding:上下 左右 三个值：padding：上 左右 下 四个值：padding：上 右 下 左

margin：外边距，也可以上下左右单独设置，也可以写合并写法，同padding，可以写负数，也可以写出auto表示浏览器自动计算


浏览器的私有前缀：

谷歌浏览器 –webkit

火狐浏览器 –moz

欧朋浏览器 –o

IE浏览器 -ms

例如 -webkit-box-shadow

overflow-x：水平溢出设置

overflow-y：垂直溢出设置

border-radius：圆角 单位像素和百分比

单独设置border-top-left-radius border-top-right-radius border-bottom-left-radius border-bottom-right-radius

box-shadow：阴影d

box-reflect：倒影 兼容性比较差，目前只有webkit内核支持

background-origin：背景图片占据的盒子模型 padding-box（默认）在padding开始显示背景 border-box 在border区域开始显示背景 content-box在内容区域开始显示背景

background-clip：背景裁剪 属性值同上

background-size：设置图片的大小 可以是像素，也可以是百分比 cover宽度或高度自适应容器，超出的部分隐藏 contain保证背景能够完整显示，但是容器可能出现空白区

rgba表示法：最后的a就表示颜色透明度取值0~1

opacity：设置网页元素的透明度 取值0.0~1.0

IE兼容写法：filter:alpha(opactiy=值) 值0~100之间

calc：css3新的计算宽度和高度的一个函数，可以做百分比和像素的混合运算，例如calc(100% - 100px) 注意！运算符两边有空格！

tab-size：在pre标签中一个tab的空格数量

text-shadow：文字阴影

text-overflow：文字溢出显示省略号 ellipsis

column-count：文字分栏

### transition

css样式过渡，但是不是所有的css样式都能做成过渡效果

transition-property 参与过渡的样式名称，如果全都参与，设置为all

transition-duration 过渡时间，秒为单位，例如 3.5s

transition-timing-function 过渡的动画类型

transition-delay 动画延迟执行的时间，秒为单位

### transform

元素的变换效果

平移：translate translateX translateY 单位可以是像素或者百分比（自身的百分比，不是父元素）

旋转:rotate(60deg) 默认按z轴旋转（2D旋转）transform-origin配置旋转的原点

缩放：scale scaleX scaleY 值是原始大小的倍率

扭曲：skew skewX skewY

transform-style：preserve-3d 产生3d立体效果

perspective：远近度，值越小立体效果越强，必须要加在父元素上，单位像素

backface-visibility:hidden 元素旋转到背面不可视

### 新增选择器

E:not 不是某个选择器

E:first-child父元素的第一个子元素

E:last-child父元素的最后一个子元素

E:only-child父元素仅有的一个子元素

E:nth-child(n) 匹配父元素的第n个子元素

E:first-of-type匹配同类型中的第一个同级兄弟元素

E:last-of-type匹配同类型中的最后一个同级兄弟元素

E:only-of-type匹配同类型中的唯一的一个同级兄弟元素

E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素

E:empty匹配没有任何子元素（包括text节点）的元素

E:checked 选中状态

E:enabled 可用状态

E:disabled 禁用状态

E:selection 选中状态

E:first-letter 段落中的首字

E:first-line 段落中的第一行

E\[att\] 选择具有att属性的E元素

E\[att="val"\]选择具有att属性且属性值等于val的E元素

E\[att~="val"\]选择具有att属性且属性值为一用空格分隔的字词列表

E\[att^="val"\]选择具有att属性且属性值为以val开头的字符串的E元素

E\[att\*="val"\]选择具有att属性且属性值为包含val的字符串的E元素

E\[att$="val"\]选择具有att属性且属性值为以val结尾的字符串的E元素

E~F选择E元素后面的所有兄弟元素F

filter:blur 模糊效果

网络字体：字体文件放到网站中，用户打开网页的时候自动下载引用这个字体

@font-face 自定义字体，将字体文件定义为css中的字体

主要用于字体图标

border-image：用图片设置边框线

border-image-source 设置图片路径

border-image-slice 图片分割

border-image-width 边框宽度

border-image-outset 外扩宽度

border-image-repeat 重复的设置

### 盒子模型的怪异模式

在标准模式的盒子模型中，padding和border都是向外扩展空间，并不会占据内容本身的空间

在怪异模式的盒子模型中，padding和border是占据内容本身的空间，并不会向外扩展

产生怪异模式的情况：

1. 不写doctype文档类型并且在低版本的IE的浏览器下
2. 在CSS3中用box-sizing属性设置值为border-box

定位相关的样式：

display：决定元素显示的特征 none不显示 inline内联元素特征 inline-block内联块特征 block块元素特征

显示隐藏元素

display属性:none隐藏 其他值是显示，不占位隐藏

visibility属性：visible显示 hidden隐藏，占位隐藏

**排版定位的原则：从上到下，从左到右，从外到内**

float：浮动元素，none不浮动 left左浮动 right右浮动

**浮动元素会脱离正常文档输出流**，float设计的初衷是文字环绕图片，内联元素应用了float，默认就是块级元素特征

**clear：清除浮动** left不允许上边有左浮动元素 right不允许上边有右浮动元素 both不允许上边有左或右浮动元素


## less和sass

嵌套：结构分明

变量

继承

运算

导入

css中有可能会大量的编写重复性的样式设置，例如重复的属性值，重复的样式，当我们后期维护的时候，就比较困难，一次改变外观，需要修改多处css。

Css中没有变量的概念（常量，就是不可变的量，变量，就是可变的量，变量的取名规范驼峰写法，xxxXxxXxx，多个单词组成，第一个单词全小写，第二个开始首字母大写，例如studentCode）

Less和sass就是为了解决以上问题的一种工具语言，这个语言模拟了变量的概念，必须通过工具去自动维护css文件

Less和sass都是css预处理器，less的文件扩展名是.less，sass的文件扩展名是.scss。

单行注释：// 不会出现到css文件中 没有多行注释专用语法

Less定义变量使用@符号 Sass定义变量使用$符号，变量可以直接做数学表达式运算，定义到样式外的是全局变量，定义到样式里的是局部变量，局部变量优先级高于全局变量。

Java document.querySelectorAll(".moveArea") as NodeListOf&lt;HTMLElement&gt;

### Less

extend must be last

#### Variables

##### Mixins



##### selectors



##### Properties





##### Variable Names



##### Default Variables



#### Extend

&:extend(.inline)

.a:extend(.b) {} == .a{ &: extend( .b )}

.c:extend(.d all) { _// extends all instances of ".d" e.g. ".x.d" or ".d.x"_ }

.c:extend(.d) { _// extends only instances where the selector will be output as just ".d"_ }

.e:extend(.f){}

.e:extend(.g){} 等于.e extend(.f , .g){}

pre:hover:extend(div pre):extend(.bucket tr) - Note this is the same as pre:hover:extend(div pre, .bucket tr)





##### All



##### Selector with variable will not be matched

##### Scoping / Extend Inside @media

Extend written inside a media declaration should match only selectors inside the same media declaration:

Top level extend matches everything including selectors inside nested media:



#### Mixins

If you want to create a mixin but you do not want that mixin to be output, you can put parentheses after it.



##### Guarded namespaces



##### !important

Use the !important keyword after mixin call to mark all properties inherited by it as !important:

##### Parametric mixins

Mixins can also take arguments, which are variables passed to the block of selectors when it is mixed in



Parametric mixins can also have default values for their parameters:



##### Advanced Arguments and the @rest Variable

.mixin(...) { _// matches 0-N arguments_

.mixin() { _// matches exactly 0 arguments_

.mixin(@a: 1) { _// matches 0-1 arguments_

.mixin(@a: 1; ...) { _// matches 0-N arguments_

.mixin(@a; ...) { _// matches 1-N arguments_

##### The @arguments variable



##### Pattern-marching

Now let's say we want .mixin to behave differently, based on the value of @switch, we could define .mixin as such:



##### Mixin as functions



##### Passing Rulesets to Mixins

Parentheses after a detached ruleset call are mandatory. The call @detached-ruleset; would NOT work.



### Import Options

Reference/ inline/less/css/once/multiple/optional

Use @import (optional) to allow importing of a file only when it exists. Without the optional keyword Less throws a FileError and stops compiling when importing a file that can not be found.



## Script

JavaScript由网景公司开发，后来由于浏览器大战，出现了多个版本的JavaScript，例如IE的Jscript，所以不同的浏览器会有兼容性问题。

JavaScript通过浏览器执行，是一种即时编译的脚本语言，是解释性语言（不需要事先编译好，一边编译一边执行的语言）

面向过程的语言：程序的最小单位是函数，没有对象，类，属性，方法的概念，例如C语言

面向对象的语言：程序的最小单位是类，没有函数的概念，都是对象，属性，方法，例如Java，c++，c#

JavaScript是面向过程，基于对象的。

Web前端的三层结构：html（结构）css（表现）JavaScript（行为）

目前的标准的名称是EcmaScript，最新版本是EcmaScript6.0。

JavaScript的语法严格区分大小写，每条语句用分号结束。

严格模式：在代码中加入 'use strict'; 如果代码中出现不规范的语句，直接报错

使用方式：

内嵌式：在网页的head或者body中，加入&lt;script&gt;标签

外联式：在&lt;script src=”外部js文件”&gt;

注意：

外联的css文件，如果用到了外部资源，相对路径的位置以css文件位置为准

外联的js文件，如果用到了外部资源，相对路径的位置以应用了js的html文件位置为准

document.write(数据) 输出数据到页面

window.alert(数据) 弹出对话框 window对象可以省略，直接调用alert方法

单行注释：//

多行注释：/\* \*/

控制台输出语句: console.log(数据) IE不支持，会直接报错

变量用var声明，必须是字母，下弧线，$符号开头，后面可以是字母，下划线，$符号，数字，不可以是关键字（程序中有特殊含义的，例如var）

例如 stuId $font12 \_color

变量声明语法：var 变量; var 变量=值; var 变量1，变量2=值，……;

Js的数据类型是弱类型，不是像java那种强类型，变量必须显示的声明数据类型

强类型举例： int i = 10; String s = “abcd“; double d = 3.14;

弱类型举例：var i = 10; var s = “abcd”; var d = 3.14;

### JS的数据类型划分

基本数据类型（原始数据类型）

undefined 未定义

null 空对象（代表空指针）

number 数字型 例如 100 3.14

string 字符型（字符串）常量需要用双引号或者单引号括起 例如 “中国” ‘abcd’ 空字符串”” ‘’

boolean 布尔值 就两个取值 true代表真 false代表假

引用数据类型

object 对象类型

### JavaScript 中的变量在内存中的具体存储形式是什么

原始类型包括但不限于 number、string、boolean、null、undefined 和 bigint（ES10 引入的新类型）。这些类型的值在内存中直接存储。

原始类型的值直接存储在栈内存中。

访问速度快，因为栈内存具有连续性和固定大小的特点。

引用类型包括但不限于 object、array 和 function。引用类型的变量实际上存储的是指向实际对象的引用（地址）

堆内存（Heap Memory）

存储引用类型：引用类型的对象存储在堆内存中。

优点：存储空间大，适合存储大对象。

栈（Stack）：用于存储原始类型变量和引用类型变量的引用。

堆（Heap）：用于存储引用类型的实际数据

返回数据类型的函数 typeof  
typeof null 返回 "object"，因为在JavaScript中，null 被认为是一个空对象引用。

console.log(typeof typeof typeof null); //string

console.log(typeof console.log(1));// 1 undefined

NaN不是一个单独的数据类型，是一个number的特殊值，代表计算结果是非数字（Not a Number）

Asc码：用0~127的数字代表键盘的128个字符 例如a~z 97~122，A~Z 65~90，0~9 48~57

Unicode码用0~65535 代表全球统一编码（世界上所有官方语言） unicode的前128位就是asc码

### 运算符

**字符串拼接符：**\+ 运算符两边有一个是字符串，就做拼接运算

**数学运算符**：+ - \* / %取模 -取负 ++自增 --自减

++ -- 前置，先做自增自减运算，再过其他运算，后置，先做其他运算，再做自增自减运算

**赋值运算符：** \= += -= \*= /= %=

**比较运算符：**\>大于 &lt;小于 &gt;= 大于等于 <= 小于等于 ==等于 !=不等于 ===严格等于 !==严格不等于 比较运算返回的值都是布尔型true和false

严格等于：先判断两个数据类型是否一致，如果不一致，直接false，如果一致，再进行比较

在js的判断条件中以下值代表假：false 0 空字符串 null undefined，其他的都代表真

**逻辑运算符：优先级 ! > && > ||**

&&逻辑与：同真则真，有一个假，就为假

||逻辑或：有一个真就为真，同假则假

! 逻辑非：真变假 假变真

逻辑与的短路运算：表达式1为假，不执行表达式2

逻辑或的短路运算：表达式1为真，不执行表达式2

单目运算符： ++ -- - !

双目运算符：> &lt; &gt;= <= == != && ||

三目运算符：表达式?返回值1:返回值2 表达式为真返回值1，为假返回值2

浮点运算：根据IEEE标准特点，浮点数运算一定会有误差

window. prompt 输入对话框

parseInt(数据)：可以把其他数据转换为整数数字型

isNaN(数据)： 判读是否是非数字

isNaN() 会对非数字类型的值进行类型转换，而 Number.isNaN() 则不会。

转义符号：反斜杠 \\ 例如 \\” \\’ \\\\

特殊转义：\\n 换行符 \\r回车符 \\t制表位

JavaScript是基于对象，面向过程的语言，语言中既有对象，方法，也有函数的概念。

在JS里，方法函数都是function

function可以理解为是一个定义好的功能，一次声明，多次调用

**声明function基本语法**

function 自定义名称（形参1，形参2，……） {

语句块代码

\[return \[返回值\]\];

}

**调用function**

function名称(实参1，实参2，……);

return表示退出当前函数，回到调用者那里继续执行（即时没有return语句，函数执行完毕也会回到调用者那里继续向下执行）

return 返回值，表示退出当前函数，并且把函数的返回值，返回给调用者，然后继续向下值

递归调用：函数调用自己本身，如果没有设置正确的退出条件，很容易形成无限递归（死递归）

document.getElementById(元素的id)：通过id得到元素的对象

### 流程控制-条件语句

只有条件为真才会执行特定语句，条件为假再执行其他语句

**If语句语法1：**

if (条件表达式) {

条件为真执行的语句块

}

**If语句语法2：**

if (条件表达式) {

条件为真执行的语句块

} else {

条件为假执行的语句块

}

**If语句语法3：**

if (条件表达式1) {

条件1为真执行的语句块

} else if (条件表达式2) {

条件2为真执行的语句块

} else if (条件表达式3) {

条件3为真执行的语句块

}……

else {

以上条件都为假执行的语句块

}

如果有一个条件为真，就会执行对应的语句块，然后退出整个if语句块，没有机会执行其他的条件判断

if里的执行语句块如果只有一句，可以省略花括号

**switch条件判断：和if的区别就是，只能做等值判断**

switch(表达式) {

c ase 值1:

执行语句;

\[break;\]

c ase 值2:

执行语句;

\[break;\]

……

default:

执行默认语句;

\[break;\]

}

break如果不写，当条件为真的时候，执行语句后，会无条件的继续向下执行，可以用break语句直接跳出整个switch语句

**循环语句：在满足条件的情况下，反复执行特定的代码**

一个完整的循环的组成：初始计数值，条件，迭代，循环代码

**while循环：只要条件为真就一直循环执行**

whiile (条件表达式) {

循环执行的代码

}

**do…while循环**：类似while循环，但是是先执行一次循环体代码，然后再判断循环条件

do {

循环执行的代码

} while (条件表达式);

**for循环**：典型的计数循环，通过一个计数变量来控制循环的次数

for (计数变量初始化;条件表达式;迭代) {

循环执行的代码

}

break：跳出整个循环继续向下运行

continue：跳出当前循环（continue下面的语句不执行），进行下一次循环

**for…in循环**：遍历对象的成员或者遍历数组的下标

for (变量 in 对象) {

循环执行代码

}

### 变量的作用域：变量的使用范围

<https://segmentfault.com/a/1190000014741472#articleHeader6>

分为两种作用域：

全局变量：属于window对象（全局对象，是作用域中最大的对象），在整个js程序中都可以使用，声明在function的外部，尽可能少用全局变量，会造成全局污染。

局部变量：属于某个function范围，仅限于在function内部使用

**JS中没有块级作用域这一说**，最小的作用域就是一个function，声明在function里面的变量包括参数都是属于局部变量。

变量如果没有加var声明，即时写在function内部，也算全局变量。

全局作用域

函数作用域

3\. 块级作用域

块级作用域是指在代码块（由 {} 包围的代码段）内部声明的变量和函数，只能在该代码块内部访问。ES6 引入了 let 和 const 关键字来实现块级作用域。

作用域链：当在某个function使用某个的变量时候，首先先查看当前function作用域中是否有这个变量，如果有，直接使用，如果没有，就会像上层（外层）作用域查找，直至全局作用域。

生命周期：变量出现在内存开始，到从内存中销毁为止，中间的过程，就是一个变量的生命周期，一个局部变量的生命周期从函数调用开始，到函数执行完毕，全局变量的生命周期是整个js程序结束。

### 面向对象编程

类：**抽象**上的定义，不具体代表任何一个实例

对象：必须是一个**具体**的对象实例

类和对象是一对多关系，一个类可以创建多个对象实例，通过类创建对象的过程叫做实例化

**声明类：**

function 类名() {

属性定义

方法定义

}

类名的规范是大驼峰：XxxXxXxxx 每一个单词首字母大写

**通过类创建对象实例**

var 变量 = new 类名(); 这是function的**构造函数**调用，调用构造函数的作用就是创建某个类的对象实例

对象的成员：

属性：作用是存储对象的数据，在类中用this关键字来定义属性

方法：作用是实现对象的功能，在类中用关键字来定义方法

function本身就是一个对象，它的数据类型是function

创建一个function有三种写法：

写法1：函数声明

function 自定义名称() {

语句块

}

写法2：函数表达式

var 名称 = function() {

语句块

}

写法3：创建Function类的对象

var 名称 = new Function(‘参数1’,’参数2’,……,’函数语句块’);

函数声明和函数表达式最大的区别是，函数声明带有声明提升，即使函数声明在后面，js引擎把函数在执行之前放到代码的最前面，但是函数表达式没有声明提升。

匿名函数：没有名字的函数，例如function(xx,xx){}，本身就是一个函数对象

匿名自执行:模仿块级作用域

(

function(xxx,xx) {

}

)(xxx,xxx);

### this关键字

代表一个对象，不同的情况下，this代表的对象也不同

函数调用function：this永远代表window全局对象

构造函数调用function：this永远代表当前创建的对象

对象实例方法调用function：this永远代表当前的对象

function Person(name) {

this.name = name;

}

var person = new Person('Bob');

console.log(person.name); // 输出："Bob"

静态方法调用function：this永远代表当前类的function对象

### 内存分布

栈区：只存储局部变量（也包括全局变量）

堆区：只存储对象的实例，每个对象实例在堆中都会自动产生一个唯一的内存地址

### 堆和栈的区别

1\. 数据结构：栈和堆都是内存数据结构，栈是一种线性结构，堆是一种树形结构。

2\. 内存分配方式：栈采用的是静态内存分配，系统在编译阶段就确定了分配给栈的内存空间，而且栈内存的释放是由系统自动完成的。而堆采用的是动态内存分配，程序在运行时可以向操作系统请求动态分配一段空间，然后使用完之后再手动释放。

3\. 存储内容：栈中存储的是函数的调用和局部变量，而堆中存储的是对象的实例。

4\. 访问方式：栈是一种后进先出（LIFO）的数据结构，只有栈顶的元素可以被访问和操作，而堆是一棵树形结构，其存储的元素可以被通过指针或引用访问。

5\. 内存分配效率：栈的内存分配效率比较高，因为栈是一种内存结构，其内存块相互紧凑，可以直接通过指针操作，而堆的内存分配效率相对低一些，因为需要手动分配和释放内存空间。

对象之间赋值赋的是引用地址，基本类型赋值赋的是值本身。

私有方法：在类中声明的函数，就是只能在类内部调用，在外部调用不了的功能

公有方法：在类中声明的正常方法，在类的内部可以调用，也可以在类的外部使用

JS的对象时可以随时动态添加和删除对象的成员（属性和方法）

在对象中添加属性或者方法

对象.属性=xxx 对象.方法名=function() {}

删除对象中的某个属性后者方法

delete 对象.属性 delete 对象.方法

Object类：是JS语言自带的一个类，是所有类的父类（超类），类中的属性和方法会被其他的类所继承，所有说，任何类都具有Object类的成员

字面量对象：等同于创建一个Object类的对象，利用特定的语法，设置属性和方法

{

属性名称：属性值,

属性名称：属性值，

……

方法名称：function(){},

方法名称：function(){},

……

}

对象实例成员（对象实例的属性和方法）：是属于具体的某个对象实例，需要通过对象调用

静态成员（类成员）：是属于类本身的，不属于任何一个具体的对象实例，需要通过类调用

在类中定义静态属性：类名.属性 = 属性值 类名.方法名 = function(){}

静态成员在js中只能通过类访问，不能通过对象访问，静态方法中不能访问对象实例成员（<https://www.cnblogs.com/signheart/p/6599838.html），但是可以调用静态成员。>

访问对象的成员的两种方式：

对象.成员

对象\[‘成员名称’\]：一般用在属性或者方法是动态调用，而不是固定属性和方法名称的情况下

instanceof运算符： 对象 instanceof 类 ，如果对象是这个类创建的，返回true，否则为false

with语句：可以绑定一个默认对象，可以在调用对象成员的时候，省略对象前缀

with (默认对象) {

直接访问对象的成员

}

with效率极差，开发中不推荐使用。

### Array数组

：数组是对象引用类型，在js中的类名叫做Array，可以存储相同类型的一组数据，一个数组对象可以存放数组元素，数组元素是用下标访问，起始下标是从0开始，js的数组是可变长数组，可以任意的添加新元素

- ****伪数组****：通常指的是 arguments 对象，它具有数组的一些特征，但不是真正的数组。
- ****类数组对象****：具有 length 属性和索引，但不是 Array 类型的对象。这类对象还包括 NodeList、HTMLCollection 等。

创建数组对象的方式：

1. var 变量 = new Array(); 基本语法
2. var 变量 = new Array(值1，值2，……); 直接初始化元素值
3. var 变量 = \[值1，值2，……\]; 等价于上面语句，是字面量写法

数组对象的属性方法：

length属性：返回数组的元素个数

push方法：在数组末尾添加元素

pop方法：删除数组末尾元素

unshift方法：在数组头部添加元素

shift方法：删除数组头部的元素

splice方法：删除数组指定的元素

concat方法：合并另一个数组

join方法：按照指定的分隔符（默认逗号）将数组元素拼接为一个字符串

reverse方法：颠倒数组中元素的顺序

slice方法：根据起始和终止下标截取返回数组的一部分，下标可以为负数，代表倒数第n位 (不会修改原始数组，而是返回一个浅拷贝的新数组。)

sort方法：两种用法：

无参：默认按照数组中的元素的asc码来排序

传参：传入一个function，在这个function中定义排序规则，这个排序规则的function需要传入两个参数，代表比较的两个数值，如果是按照升序排序，参数1>参数2，返回正整数，参数1<参数2，返回负整数，参数1==参数2，返回0

改变原有数组的方法push Pop Shift splice sort reverse

数组排序算法：冒泡排序（下沉法，上浮法） 选择排序 插入排序 希尔排序 快速排序

冒泡排序下沉法算法核心思想：通过多次遍历数组，每次比较相邻的元素，如果顺序错误则交换它们，直到数组有序

时间复杂度：如果是有序的O(1), 否则O(n^2) 空间复杂度O(1)

冒泡排序：

**for(var i = 0;i < a.length;i ++){**

**for(var j = 0;j < a.length -1 –i;j ++){**

**if(a\[j\] > a\[j+1\]){**

**var temp = a\[j\]**

**a\[j\] = a\[j+1\]**

**a\[j+1\] = temp**

**}**

**}**

**}**

数组查找算法：线性查找法 二分查找法（折半查找法）：数组必须先排序

多维数组：数组的元素本身又是一个数组对象，例如二维数组，三维数组，……

### String字符串对象

常用属性和方法

charAt方法：字符串string的第n个字符

charCodeAt方法：字符串string的第n个字符的Unicode编码

fromCharCode方法：指定编码的字符的新字符串

concat方法：拼接字符串，不如用+号方便

indexOf方法：查找返回子字符串的下标，如果没有返回-1

lastIndexOf方法，同上，从后向前找

length属性：返回字符串长度

substr方法：返回指定下标范围的子字符串 第二个参数代表长度

substring方法：类似substr，但是第二个参数代表终止下标

toLowerCase, toUpperCase方法：大小写转换

split方法：按照分隔符，将一个字符串分割为一个数组

Math数学对象

常用属性和方法：

floor方法：返回一个数字的不大于本身的最大整数

round方法：四舍五入取整

ceil方法：进位取整，小数位有有效数字，就进位

random方法：返回一个随机小数，一定是大于等于0 小于1之间

产生任意两整数之间的随机整数（包括两整数本身）公式:

parseInt((大值-小值+1)\*Math.random()+小值)

(parseInt(10\* Math.random()+1))\*100  
Date对象

常用方法：

构造函数：new Date( )默认当前系统时间 new Date(毫秒数) new Date(“2013-7-18”) new Date(year, month, day, hours, minutes, seconds, ms)

getYear/setYear方法：返回或设置年份 有兼容问题 推荐使用getFullYear方法

getMonth/setMonth方法：返回或设置月份 0~11表示1~12月

getDate/setDate方法：返回或设置天数

getHours/setHours方法：返回或设置小时

getMinutes/setMinutes方法：返回或设置分钟

getSeconds/setSeconds方法：返回或设置秒

getDay/setDay方法：返回或设置星期几 0~6表示周日到周六

getTime/setTime方法:返回或设置当前日期对象毫秒数，这个毫秒数代表的是从1970-1-1 0:0:0到这个日期间隔的毫秒数

定时器

window.setTimeout：间隔多少毫秒执行一个程序

语法：setTimeout(函数对象或者语句字符串,毫秒数); 推荐传函数，不推荐传语句字符串，效率低

window. setInterval：同上，但是是每隔多少毫秒执行一次程序

setTimeout和setInterval方法都有一个返回值timerId，代表这个定时器的唯一标识，可以用来取消定时器（clearTimeout clearInterval）

document.write方法：如果潜入在网页的输出流中，那么将会和网页输出流形成同一个输出流，如果网页输出流已经结束，重新执行document.write方法，会产生一个新的输出流，网页原始内容会被覆盖。

所有的容器对象都具有两个动态属性：

innerHTML属性：代表一个容器中的html内容，可以设置，也可以返回

innerText属性：代表一个容器中的text文本内容，可以设置，也可以返回

innerHTML属性：类似innerHTML，但是是包含元素本身

中文在gbk编码下一个字符占2字节，在unicode编码下是占3字节

浏览器提交表单数据的时候会自动把中文转换为**url编码**

Tomcat服务器默认的网络请求编码是iso-8859-1西欧编码，post请求发送中文可以在后台代码中手动设置请求编码，但是get请求服务器是写死iso-8859-1编码，无法手动设置

Get请求和post请求的区别：

1.get把数据追加在url后面，以?参数名=参数值&参数名=参数……形式，post请求把数据放到请求正文中

2.get由于受到url长度限制，发送数据量小，post发送数据几乎无限制

3.get明文发送数据，不安全，post数据放到请求正文中，安全

4.get发送中文困难，post发送中文容易

为什么post会比get安全：

Get请求的URL会保存在服务器端的日志和浏览器也能查到历史记录

&nbsp;get 请求的url是在服务器上有日志记录，在浏览器也能查到历史记录，但是post请求的参数都在body里面，服务器日志记录不到

常用内置函数：

parseInt：字符串转为整数

parseFloat：字符串转为浮点数

isNaN：判断是否是一个非数字

eval：动态执行JavaScript语句字符串

escape/ unescape：基本编码解码，是unicode编码，不是url编码

encodeURI/ decodeURI：url编码解码，常用

encodeURIComponent/ decodeURIComponent：url编码解码，和上面的不同的是，&=?也会被编码

JS能够动态读取设置一切HTML属性 元素对象.属性 例如 t1.value

注意：有两个html属性不能直接直接用原始属性名做动态属性名

class 需要写成 className

for 需要写出 htmlFor

单一属性，例如checked selected disabled动态属性是布尔值true和false

JS能够动态读取设置一切CSS样式 元素对象.**style**.样式 例如 t1.style.backcolorColor

这种写法操作的是行内样式

**Js获得对象的方式：**

**document.getElementById方法**：通过元素的id返回元素对象

**document.getElementsByName方法**，通过元素的name返回一组元素对象，返回的数据类型是一个类数组（不是真正的数组，只具有下标和length属性，没有其他的api方法）

**document.getElementsByTagName方法**：通过元素的标签名称返回一组元素对象，返回类型也是一个类数组

document.getElementsByClassName方法：通过元素应用的class类返回一组元素对象，返回类型是类数组，这个方法有兼容性问题，高版本浏览器支持

html允许静态或者动态的设置**自定义属性，自定义属性就是html本身没有的属性，也**可以通过js动态读取和设置，例如 &lt;p abc=”123”&gt;，在html5中规定，只要是自定义属性，必须用data-开头，例如data-abc比较规范

自定义属性最好用以下方法操作，保证兼容性：

设置属性值：对象.setAttribute(‘属性名’,属性值)

返回属性值：对象.getAttribute(‘属性名’)

### 事件

事件=事件源 + 事件类型 + 事件处理（事件回调函数）

注册事件的方式：

0级事件：

行内写法：在标签中注册事件 例如 &lt;p oncliclk=”xxxx”&gt;，只能调用全局函数

代码写法：事件源对象.事件名称 = 事件回调，推荐使用，耦合度低，调用灵活

2级事件：

W3C标准写法：事件源对象.addEventListener(‘事件类型’,事件回调函数\[,是否为捕获型\])

IE专用写法：事件源对象.attachEvent(‘事件类型’, 事件回调函数)

移除2级事件：

W3C标准写法：事件源对象.removeEventListener(‘事件类型’,事件回调函数\[,是否为捕获型\])

IE专用写法：事件源对象.detachEvent(‘事件类型’, 事件回调函数)

常用事件：

onload：当对象加载完毕 例如window.onload代表网页资源加载完毕，包括外部引用的资源也加载完毕才触发事件

onclick：单击

ondblclick：双击

onmouseover：鼠标移上，鼠标穿过子元素，会重新触发事件

onmouseout：鼠标离开，鼠标穿过子元素，会重新触发事件

onmousedown：鼠标按下

onmouseup：鼠标抬起

onmouseenter：类似onmouseover，但是鼠标穿过子元素不会重复触发事件

onmouseleave：类似onmouseout，但是鼠标穿过子元素不会重复触发事件

onmousemove：鼠标移动

onfocus：获得焦点

onblur：失去焦点

onchange:当内容被改变，一般用在列表框中

onselect：当内容被选中

onkeydown：键盘按下

onkeyup：键盘抬起

this关键字在事件中：

行内事件里的语句中用this，代表当前标签元素对象

代码事件的**回调函数**中用this，代表当前事件源对象（是当前注册事件的那个对象）

事件对象：event对象，本身代表当前事件的一些状态，不同的事件状态也是不一样

IE和w3c标准标准获得事件对象的方式不一致，w3c标准下：回调函数的参数就代表事件对象，IE下：window.event代表事件对象

事件对象常用属性和方法：

type属性：事件类型

事件源对象：target标准写法 srcElement IE写法

clientX, clientY属性：鼠标坐标位置

button属性：返回鼠标的按键，不同的浏览器返回值不一致

keyCode属性：返回键盘按键的unicode码

ctrlKey,altKey,shiftKey属性：返回是否按下ctrl,alt,shift键

事件流：事件传播的顺序

捕获型：从父元素传播到子元素（IE不支持）

冒泡型：从子元素传播到父元素（默认）

阻止事件冒泡：

W3C标准写法：事件对象.stopPropagation()

IE专用写法：事件对象.cancelBubble=true

e.stopPropagation?e.stopPropagation():e.cancelBubble=true;

阻止事件的默认行为：

W3C标准写法：事件对象.preventDefault()

IE专用写法：事件对象.returnValue=false

行内事件，直接在最后加上return false；就可以阻止事件默认行为

代码事件，直接写上return false也可以组织事件的默认行为

#### 事件委托：利用事件冒泡的原理，通过父元素来捕获子元素的事件加以处理  

<br/>浏览器的事件流  
事件捕获阶段

处于目标阶段

事件冒泡阶段

动态添加的元素注册事件方式：

方式1：每次添加元素后直接注册事件

方式2：采用事件委托机制

方式3：直接用行内事件

滚轴事件：

非火狐浏览器：事件onmousewheel，通过wheelDelta属性获得滚轴状态，向上滚轴值为正数，向下滚轴，值为负数

火狐浏览器：必须使用2级事件注册，事件名DOMMouseScroll，通过detail属性获得滚轴状态，向上滚轴值为负数，向下滚轴，值为正数

手动产生事件行为：大多数的事件都可以通过程序产生，例如 click() focus() select()……

DHTML：dynamic html动态htmnl，js提供了对某些元素的对应的api，例如Image类Option类，innerHTML属性等

DOM：document object model文档对象模型，js提供了通用的动态操作元素的api，dom编程思想认为网页中每一个元素都是一个对象，也是一个节点，根节点就是document，唯一的子节点就是html，html有两个子节点，head和body，以此类推

DOM主要就是用来创建，插入，修改，删除节点的

**DOM操作的常用属性和方法：**

createElement方法：在内存中创建一个元素节点

createTextNode方法：在内存中创建一个文本节点

appendChild方法:在父节点中添加子节点

setAttribute/getAttribute方法：设置读取节点的属性

insertBefore方法：有两个参数，参数1表示插入的节点，参数2表示某个节点对象，参数1插入到参数2节点之前，如果省略参数1，功能和appendChild一致（IE下好用）

removeChild方法：通过父节点删除子节点，必须是直接子节点，不能间接子节点

replaceChild(新节点,旧节点)方法：替换节点

parentNode属性：返回当前对象的父节点

childNodes属性：返回当前对象的所有子节点，返回类数组，注意的是行内的文本也算子节点

firstElementChild属性：返回第一个元素子节点（不包含文本节点）

lastElementChild属性：返回最后一个元素子节点

nextElementSibling属性：下一个兄弟元素节点

previousElementSibling属性：上一个兄弟元素节点

childElementCount属性：返回所有的子元素节点的个数

nodeType属性：返回节点的类型，返回值是9代表document节点，1代表元素节点，3代表文本节点，8代表注释节点，11代表文档碎片节点

nodeName属性：返回节点的名称（一般用于元素节点）

nodeValue属性：返回节点的值（一般用于文本节点或注释节点）

querySelector(css选择器)：根据选择器返回dom对象，只返回匹配的第一个对象，兼容到IE8

querySelectorAll(css选择器)：同上，但是返回所有匹配的元素对象，返回类数组，兼容到IE8

表格相关的dhtml方法

表格对象.createCaption()：创建表格标题对象

表格对象. createTHead()：创建表格头部

表格对象. insertRow()：创建并插入行

行对象. insertCell()：创建并插入单元格

表格对象.rows：返回所有的行的类数组

行对象.cells：返回当前行的所有单元格的类数组

文档碎片：createDocumentFragment()创建一个临时的容器对象，可以在减少渲染次数的同时，不产生垃圾标签

BOM（Browser Object Model）浏览器对象模型：不属于任何脚本语法，属于浏览器本身的对象，可以被任何脚本调用

最大的对象是window对象，代表当前的浏览器窗口

常用属性和方法：

alert()：对话框

prompt()：输入框

confirm()：确认框，确定返回true，取消返回false

close()：关闭当前窗口

open()：开启新窗口

print()：调用浏览器打印

scrollTo(水平滚动条位置,纵向滚动条位置)：动态设置窗口的滚动条位置

showModalDialog(窗口参数)：模特窗口

document对象：代表当前文档窗口

navigator对象：代表当前客户端的信息 最重要的属性userAgent包含了客户端操作系统和浏览器信息

screen对象：代表客户端的屏幕

height,width：垂直和水平的屏幕分辨率

dpi像素密度：电子屏幕一平方英寸里的物理像素数量 ppi打印机像素密度

history对象：代表浏览历史，注意操作就是前进和后退

back()方法：后退按钮

forward()方法：前进按钮

go(参数)方法：前进(正数)或后退(负数)几个页面

location对象：代表地址对象

reload()：刷新当前网页

replace()：替换当前文档内容（不可后退）  
assign()：加载一个新的文档内容（可以后退）

hash属性：可以设置或者读取锚点

href属性：设置或者读取当前url

search属性：代表url的？号后面的请求参数

获得body对象：document.body

获得html对象：document.documentElement

**元素的大小和位置：**

视口的宽度和高度：

document.documentElement.clientWidth

document.documentElement.clientHeight

网页的实际宽度和高度：

document.body.scrollWidth

document.body.scrollHeight

网页元素的实际宽度和高度

元素对象. clientWidth元素对象. clientHeight （内容+padding）

元素对象. offsetWidth 元素对象. offsetHeight（内容+padding+border）

网页元素距离父元素的偏移量：如果有父元素且父元素设置了postion:relative absolute fixed，相对于父元素的偏移量，否则相对于网页原点的偏移量

元素对象. offsetLeft 元素对象. offsetTop

网页元素距离视口原点的偏移量：

元素对象. getBoundingClientRect() 返回对象，通过这个对象top left right bottom四个属性可以返回四个边界距离视口原点的偏移量

获得窗口滚动条卷去的距离

垂直滚动条 document.documentElement.scrollTop || document.body

水平滚动条 document.documentElement.scrollLeft || document.body.scrollLeft

鼠标相对于事件源的位置

事件对象. offsetX 事件对象. offsetY

鼠标的横坐标竖坐标

e.clientX,

e.clientY

表单元素相关操作：

获得表单元素对象

document.表单元素name名称

document.forms\[下标\]

document.getElementById('表单id')

表单对象的常用属性方法

length属性:返回表单元素的个数

elements属性：返回所有表单元素的类数组

reset()方法：重置表单

submit()方法：提交表单

文本框对象：

value属性：代表当前用户在网页中输入的值

defaultValue属性：代表文本框的默认值

列表框对象：

value属性：当前选择的option的value值

selectedIndex属性：当前选择的option的下标，如果没有选择任何option，返回-1

length属性：当前option的数量

options属性：所有option的集合类数组

Option对象

动态增加option：

var opt = new Option(‘option文字’,’value值’);

select对象.add(opt); //添加方法1

select对象. options\[终止下标+1\] = opt; //添加方法2

修改option：

select对象. options\[指定下标\] = option对象;

删除option：

select对象.remove(指定下标); //删除方法1

select对象. options\[指定下标\] = null;//删除方法2

清空option：

select对象. options.length = 保留数量;

value属性：value值

text属性：标签的文字

表单验证：验证表单中的输入数据是否合法，验证分为前端和后端

前端验证：用户体验好，不需要走网络请求，效率好，很容易被绕开验证

后端验证：需要每次验证，都发送网络请求，效率低，用户体验差，优点不容易被绕开验证，相对比较安全

表单提交事件 onsubmit

正则表达式：用一系列的特殊字符来做字符串的规则匹配

创建正则表达式对象的两种方式：

var 变量 = new RegExp(‘匹配模式’,’参数’); //正常创建正则表达式对象

var 变量 = /匹配模式/参数; //字面量写法

参数g：全局匹配，一般用在replace方法

参数i：忽略大小写

### 正则的方法

test()：判断字符串是否匹配模式

exec()：返回一个对象，包含三项数据，匹配的字符串，下标，原始字符串，找不到返回null，匹配的字符串是按数组返回，如果有子表达式，每个子表达式匹配的内容也会加到数组中

String中支持正则表达式的方法：

replace(要替换的字符串或者模式，替换为的字符串)方法：替换字符串，默认只会替换第一个匹配的，如果要全局替换，必须用Doctype表达式配合g参数

match()方法：返回一个数组，存储所有匹配的值，如果没有任何匹配，返回null

search()方法：返回第一个匹配的内容的下标，如果没有匹配的，返回-1

正则表达式元字符

\\ 转义字符

^ 表示开始 例如 /a/ 匹配 bab 但 /^a/ 匹配ab 不匹配bab

$ 表示结束

表示匹配某些字符的元字符

. 表示任意字符 包括中文

\[abc\] 表示a或b或c其中一个字符

\[^abc\] 必须不是其中任何一个字符

\[a-z\] 小写字符 \[A-Z\]大写字母 \[a-zA-Z\]所有字母 也可以是\[c-e\]\[X-Z\]

\[0-9\] 数字

\[a-zA-Z0-9\] 字母和数字

\[^a-z\] \[^A-Z\]\[^0-9\] 非字母，非数字

\\s 空白（空格，制表位，换行，换页，回车）

\\S 非空白

\\d 数字 相当于\[0-9\]

\\D 非数字 相当于\[^0-9\]

\\w 字母或数字或下划线 \[0-9\]\[a-z\]\[A-Z\]_

\\W 非字母数字下划线

表示匹配次数的元字符

\* 0次到多次

\+ 1次到多次

? 0次或1次

{n} 正好n次

{n,} 至少n次

{n,m} n次到m次

其他元字符

| 逻辑或 要打小括号

(表达式) 子表达式,改变优先级

? 非贪婪模式，一般用于replace方法，尽可能的少匹配

Cookie：通用的客户端数据存储技术，在浏览器端以纯文本的**键值对**形式存储数据，必须基于服务器运行实现（本地运行无法实现）

Cookie分为两种形式：

会话级：存储在浏览器的会话进程中，生命周期和会话一致

硬盘级：永久存储在浏览器的缓存文件夹中，是一个文本文件，但是需要设置失效时间，否则默认就是会话级。失效时间必须以;expires=GMT时间格式

一个域写入的cookie数据，只能被相同的域读取，不能被其他的域读取，例如百度无法读取搜狐写入的cookie，搜狐无法读取新浪写入的cookie，如果写入的是中文数据，需要进行编码，然后读取的时候进行解码。

Cookie: 同源限制，大小限制，服务器和浏览器传递，每次请求都会把cookie放到请求报头发送到服务器。

Cookie在浏览器中有容量限制，有条数限制，每次网络请求都会放到请求报头中一起发给服务器。

JS中操作cookie的语句：document.cookie属性

**HTTP网络通信协议**

TIP/IP：传输控制协议/网际协议 有很多子协议 http ftp https

HTTP：超文本传输协议 简单说就是传输html数据的，HTTP协议是无连接，无状态的，客户端发出**请求**，连接服务器，得到**响应**，立即断开。

请求request-响应response：必须由客户端主动发出请求，服务器才能产生响应，一般来说，请求是客户端向服务器端发送数据，而响应是服务器端向客户端发送数据

如果请求的是一个静态资源，服务端会直接响应数据到客户端，如果请求的是一个动态资源，比如java,php,asp，服务器端会先在服务器端执行完毕这些动态内容，然后把执行的结果响应到客户端。

HTTP请求的三部分组成：

请求行：请求方法（GET POST PUT DELETE）请求的URI 协议和版本 例如http1.1

消息报头：客户端的一些相关信息，例如语言，浏览器，操作系统，压缩方式……

请求正文：GET请求没有请求正文，POST的请求正文存储了发送的数据

响应状态码：

200 请求响应

304 从浏览器本地缓存读取数据 (Last Modified)

404 资源找不到

405 无法请求对应的get和post处理程序

429 limit

401 unthrization

403 forbidden

500 服务器程序运行错误

301 永久重定向

302 暂时重定向

增删改查的四大操作（CRUD）：restful风格

GET 查询

POST 增加

PUT 修改

DELETE 删除

### 数据交换标准

1. 字符串用特殊符号分割
2. CSV格式
3. Xml格式
4. Json格式

Xml（Extensive Makeup Language）可扩展的标记语言，特点是自定义标签，而不是像html那种固定标签，主要用途做通用数据交换格式和配置文件，缺点是标签本身占用流量太多，解析xml数据比较困难 xml多用于做配置文件

语法特点：

1. 文件头部声明 &lt;?xml version="1.0" encoding="UTF-8"?&gt;
2. 标签区分大小写
3. 文档中必须且只能有一个根元素
4. 属性值必须加双引号或者单引号
5. 如果有应用dtd或者schema规则文件，必须符合dtd或者schema规则
    1. Dtd是早期规则语法
    2. Schema是后期规则语法，和dtd语法并存

JSON：基于JavaScript语言的轻量级的数据交换格式(JavaScript Object Notiation)，最常见的就是和后台的数据通信

基本语法特点：就是和字面量的对象语法非常类似，用{}表示一个json对象，用\[\]表示json数组对象，但是属性名称需要加双引号，只能有属性，不能有方法

Json字符串转换为json对象： .parse() //ie8或以上支持

Json字符串转换为json对象：eval( ‘(’ + json字符串 + ‘)’ ) //ie6或以上支持

Eval：动态执行字符串

Json对象转换为json字符串：JSON.stringify() //ie8或以上支持

### 函数高级扩展

函数本身就是一个对象，可以作为参数传递，也可以作为返回值返回

重载的概念：就是方法（函数）的名称相同，参数列表不同

在JS中没有重载这一说，重复的函数或者方法声明，以最后声明的为准

arguments对象：在function内部可以获得一个arguments 对象，通过这个对象就可以获得所有的实参数据，这个对象是一个类数组

获得形参的数量：函数对象.length

函数对象的call方法: 函数对象.call(上下文对象,可变长参数……)，改变函数的调用者对象的上下文对象

函数对象的apply方法：函数对象.apply(上下文对象,参数数组……)，功能同上

//类数组转换为数组

var arg = Array.prototype.slice.call(arguments);

callee是arguments对象的一个对象，通过callee可以调用本身的函数，简单的说，callee代表当前函数本身

caller是函数对象的一个属性对象，永远代表调用了当前函数的函数对象

一个function中的变量，不论声明在什么位置，在实际运行期间，都会提升到函数的开始位置声明

#### 闭包

一个正常的function调用，里面所有的局部变量在function调用结束之后，都会被销毁，但是如果局部变量被内层作用域所引用，即时外层函数执行完毕也不释放，这就是闭包，缺点是会造成内存泄露（内存使用完不及时释放，就叫内存泄露）  
<br/><http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html>

**闭包用途：**

**1\. 就是能够读取其他函数内部变量的函数。**

**2\. 变量始终保持在内存中**

**缺点：**

**1.内存泄漏**

2.会在父函数外部改变内部变量的值

例子  
　　function f1(){

　　　　var n=999;

　　　　nAdd=function(){n+=1}

　　　　function f2(){  
　　　　　　alert(n);  
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999

　　nAdd();

　　result(); // 1000

Error异常处理：如果js代码出现运行错误，默认js引擎就会终止程序，错误行下面的代码是没有机会执行的。

手动异常处理：在发生异常之后，程序可以继续向下执行

try {

可能会发生异常的代码

} catch(e) {

异常处理代码（如果发生异常，执行的语句） e就是当前的错误对象

}

手动抛出（发生）异常：手动创建错误对象，抛出给js引擎，让程序发生错误

throw 异常对象；

### 原型prototype

每个类型（例如Date,Error,Array,Number……包括自定义类型例如Person）都有一个属性，这个属性的名字叫做prototype，这个prototype指向一个对象，这个对象就是这个类的原型对象，里面默认有两个属性，constructor，\__proto_\_，如果把属性或者方法定义到类的原型对象中，不管创建多少个对象，这些属性和方法仅存在一次，比较节省内存，一般来说，只 会把方法定义到原型对象中。不放属性，因为属性值一样，无法实现面向对象。

\__proto_\_任何对象实例都拥有这个属性，这个属性指向这个对象的类的原型对象，不建议在程序中直接使用_\_proro_\_这个属性引用，很多浏览器不允许直接调用。  
<br/>  
prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.\__proto__ === Foo.prototype。

constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。

f1.constructor === Foo

constructor：此属性只有原型对象才有，它默认指回prototype属性所在的构造函数。

原型对象本身的类型是一个Object类的对象

原型链：基本原理就是对象的_\_proto_\_，当一个对象调用某个成员（属性，方法）的时候，首先先查找当前对象实例，没有再查找当前的原型对象，如果还没有，在继续向上层查找，会一直查找到Object类型，如果还没有，直接报错

### In 和 hasOwnProperty

in语法：检测某个对象中（包括原型对象）是否拥有某个成员 ‘属性或者方法名称’in 对象

hasOwnProperty方法：判断一个对象中（不包括原型对象）是否拥有某个成员

如果希望任何一个对象都能拥有某个方法，那么这个方法应该定义到Object类的原型中，但是这样做对团队开发会有影响。

**作用域链**：一个function中使用一个变量数据，如果当前作用域没有，就会向外层作用域查找，直至查找到全局作用域，要尽量减少对外层作用域的查找，比较耗费资源，尽量用传参来代替作用域查找。

继承：一个类（子类）从另一个类（父类）中获得属性和方法，优点就是避免重复定义同样的属性和方法。继承实现：原型链，和 （基于伪装call的继承方式）构造器

function Person(name,age) {}

Student.prototype = new Person();

isPrototypeOf方法：判断当前对象是否继承了某个类的原型

propertyIsEnumerable方法：判断对象的某个成员是否允许被遍历，默认的成员都是可以被遍历的，如果不想被遍历，需要对成员单独做特殊设置。

第三方技术：在原生的程序基础上扩展出来的技术，大多数都是由某些公司和个人开发的开源产品

如果一个第三方技术成了规模，已经完全代替原生的程序，就可以称作是一个框架，框架的主要目的就是简化开发

## Jquery

Jquery是一个JavaScript库，有些时候也成为JS框架，目的就是简化原生JS开发，集成了JS的常用功能，类似的框架还有ExtJS，Dojo，Prototype，YUI，

核心函数（全局函数）是jQuery，和$是等价的，传入对应的参数，返回Jquery对象，用jquery对象才能调用jquery的API

Jquery对象不能直接调用原生对象的任何API，例如innerHTML click() focus()

Jquery对象并不是原生js对象，它是封装了原生对象并且附加了一些功能，产生的一个新的对象实例

Jq的文档就绪事件

写法1：$(document).ready(回调函数);

写法2：$(回调函数);

window.onload和$(document).ready的区别：

window.onload：只能注册一次，必须当前html的dom全部加载并且所有的外部资源（图片，音频，视频）全都加载完毕才会触发

$(document).ready：注册多次，仅仅html的dom全部加载完毕就会触发，原理是JS的document.onreadystatechange事件

****选择器****：

- - $(selector)：选择与给定选择器匹配的所有元素。
    - $('#id')：选择具有特定 ID 的元素。
    - $('.class')：选择具有特定类名的所有元素。
    - $('element')：选择指定类型的元素。
    - $('parent > child')：选择父元素下的直接子元素。

****DOM 操作****：

- - append(content)：向每个匹配的元素内部追加内容。
    - prepend(content)：向每个匹配的元素内部前置内容。
    - html(content)：设置或获取匹配元素的内容。
    - text(content)：设置或获取匹配元素的文本内容。
    - attr(name, value)：设置或获取属性值。
    - addClass(className)：添加类名。
    - removeClass(className)：移除类名。
    - toggleClass(className)：切换类名。

****事件处理****：

- - click(handler)：绑定点击事件。
    - hover(handlerIn, handlerOut)：绑定鼠标进入和离开事件。
    - on(event, selector, data, handler)：绑定事件处理器。
    - off(event, selector, handler)：移除事件处理器。

****动画效果****：

- - show(duration, callback)：显示隐藏的元素。
    - hide(duration, callback)：隐藏可见的元素。
    - fadeIn(duration, callback)：逐渐显示元素。
    - fadeOut(duration, callback)：逐渐隐藏元素。
    - animate(properties, duration, easing, complete)：自定义动画效果。

****Ajax 支持****：

- - $.ajax(options)：发送异步 HTTP 请求。
    - $.get(url, data, success, dataType)：发送 GET 请求。
    - $.post(url, data, success, dataType)：发送 POST 请求。

通过下标访问元素：eq返回jq对象 get返回js对象

大多数的选择器语法都有对应的方法实现

操作属性

attr：如果属性不存在，读取属性，返回undefined，适合非单一属性和自定义属性

prop：适合单一属性

Jquery的循环遍历语句

$.each(对象或者数组,function(index, el) {});

JQ对象.each(function(index, el) {});

## HTML5

Html的两大版本：

Html4.01 对应时代的css版本css2.1

Html5 对应时代的css版本 css3.0

Html5在html5的基础之上，增加了一些标签，增加一些API（6万多个），不兼容低版本浏览器，在手机浏览器上支持相对良好

语义化标签：例如table img ，但是使用最多的排版标签div没做语义化，html中针对于div新增同样功能但是带语义的标签 语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用 直观认识的标签

article 文章

section 区块

aside 侧边栏

header 头部

footer 底部

nav 导航

hgroup 标题组

低版本的IE浏览器不兼容新增标签，需要用第三方js来实现兼容，例如IE8

低版本的IE浏览器不兼容新增标签，需要用第三方js来实现兼容，例如IE8

**新增表单元素：在移动端浏览器，会根据不同表单元素，弹出不同的虚拟键盘**

搜索框 search

列表提示 datalist

数字框 number

滑动条 range

颜色框 color

电话框 tel

网址输入 url

日期框 date

时间框 time

日期时间框 datetime-local

度量meter

进度条 progress

**多媒体**

在html4中播放多媒体（音频，视频）需要第三方插件支持（例如QQ影音，暴风影音，……），浏览器本身没有任何播放能力，使用的embed

在html5中，浏览器本身就有播放音频视频的能力（高版本支持H5的），音频audio标签，视频video

Audio标签：音频播放

html属性：

controls 显示控制面板

autoplay 自动播放

loop 循环播放

src 文件路径

Video标签：视频播放 html属性同上

音频和视频的API:

**相关方法**

play()：播放

pause()：暂停

**相关属性**

paused：是否当前是暂停状态

currentTime：设置或者返回当前播放的进度时长

playbackRate：播放速度，默认是1

muted：是否静音

volume：音量0~1

duration：返回播放总长度

**相关事件**

play 播放

pause 暂停

ended 播放结束

BASE64图片：把二进制图片转换为base64编码的文本，然后在img标签中使用，优点可以减少外部图片的文件的请求次数，一般用于的小的图片文件

画面Canvas和SVG图形图像

Canvas是位图图像，一整幅画布，由像素点组成，放大失真，不能单独调整画布中的元素

SVG 是矢量图图像，每个元素都是单独的dom节点，可以单独调整设置。

**拖放**

draggable="true" 允许元素被拖放

ondragstart 当元素开始被拖动

ondragover 当拖动到元素上方

ondrop 在元素中释放鼠标（放下被拖动的元素）

ondragenter 鼠标拖放对象进入到拖放区域

ondragleave鼠标拖放对象离开拖放区域

事件对象中有一个属性dataTransfer，这个对象存储传输一些数据 setData（）设置数据 getData读取

**文件操作**

Html5为我们提供一种和本地文件（客户端文件）的方式，一些文件操作API

操作文件：最常见的方式用表单中的文件域选取文件，默认只能选择一个文件，如果需要多选，要增加multiple属性，如果要控制选取文件的类型，需要增加accept属性，设置MIME类型，通过onchange事件来检测是否选择完毕

另一种方式，就是利用html5拖放获得文件信息。

读取文件内容：

FileReader类：文件读取对象，异步读取文件内容

主要方法：

readAsDataURL () 读取二进制内容

readAsText() 读取纯文本内容

地理定位：HTML5中唯一能够调用硬件的功能，可以通过PC的IP地址（至今未实现），或者手机移动端的GPS模块（最常用的），来得到用户的经纬度坐标

通过navigator.geolocation对象的g etCurrentPosition方法来获得用户位置

### 新增API

Cookie 发请求会发到服务器端，后端可以操作。

通过navigator.geolocation对象的getCurrentPosition方法来获得用户位置

// 对象转换为字符串

var pStr = JSON.stringify(p);

obj = JSON.parse(val); //转换为json对象

Localstorage 是前端操作.。

**WEB本地存储**：为了代替Cookie实现客户端数据存储，相对于Cookie的区别是，不会在每次请求的时候，把数据自动发送到服务器端，节省流量。

localStorage方式：永久性存储，没有失效时间

sessionStorage方式：会话级存储，会话关闭就销毁  
localStorage 与 sessionStorage 的唯一一点区别就是 localStorage 属于永久性存储，而 sessionStorage 属于当会话结束的时候，sessionStorage 中的键值对会被清空。

和Cookie一样，WEB本地存储的数据同源限制

相关的API:

length属性：返回数据的条数

setItem()：设置或增加数据

removeItem()：删除指定key的数据

getItem()：返回指定key的值

key()：返回指定下标的key

**应用缓存：**利用html5设定某些文件缓存，需要通过单独的配置文件进行配置

如果缓存的文件进行了修改，必须修改配置文件，否则文件在浏览器端不更新

&lt;!-- manifest="config.appcache" 指定应用哪个缓存配置文件 --&gt;

IndexedDB

本地数据库， 存储空间大， 不仅存储字符串。搜索和索引功能，支持事务（transaction）

Service woker

基于基于web worker，不能访问dom

可以拦截当前网站的所有请求，进行判断,如果需要像服务器发起请求就转给服务器，如果可以使用缓存就返回缓存，提高浏览体验。

**WebWorker多线程**

CPU在同一时刻只能运行一个程序（单核），一个应用程序可以由多个独立的进程组成，一个进程可以由多个独立的线程组成，线程是独立的程序的最小单位，可以并发执行。

没有DOM访问权限：Web Worker 在创建时没有访问 DOM 的权限

需要额外的代码编写

不支持跨域请求

JS默认没有真正意义上的多线程，setTimeout setInverval只是模拟了多线程，并不能真正并发执行，如果JS有任何代码在执行中，定时器语言必须等待JS代码执行结束才能执行。

WebWorker技术是真正意义上的多线程，可以在其他JS脚本运行期间并发同时执行，不影响页面效率，一般我们会把比较耗费时间的代码放到WebWorker里面运行。

需要注意：WebWorker代码不能直接操作dom，需要把值回传给主程序（调用postMessage方法），通过主程序的回调函数（onmessage）来操作dom。

/ 定时器需要等待循环全部结束，没有任何其他代码在运行中，才有机会执行

推送（push）：服务器在客户端没有主动发出请求的情况下，向客户端发送消息

常见的WEB推送技术：(<https://www.cnblogs.com/echoppy/p/6265107.html>)

1. 长连接技术，推翻http协议的无状态的特征，不是请求响应结束之后立即断开连接，而是客户端浏览器和服务器端一直保持连接，缺点就是服务器压力太大。
2. HTML5的服务器发送事件（server-sent event），属于单向服务器发送数据到客户端，注意响应的数据格式必须是data:xxxx，否则客户端无法接收。SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。
3. 短轮询：用定时器每隔一段时间发送一个ajax请求，得到响应，兼容性最好，缺点是耗费很多无用的ajax请求浪费资源，响应的及时性不如真正的推送技术。
4. 长轮询:客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求
5. WebSocket双向通信的推送，需要服务器本身支持，客户端需要使用WS协议发送请求
    1. 完成一次握手的动作，浏览器和服务器就可以创建持久性的链接。
6. WebRTC: **WebRTC** (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。

WEB SQL ：第一代客户端浏览器数据库，目前已经被淘汰，和正常服务器端数据库类似

IndexedDB：索引数据库，和WEB SQL 数据库相比，用key和value方式存储数据，和本地存储非常类似，操作比较繁琐，用的较少

## BootStrap

BootStrap是一个css框架，内置了大量的写好的样式，有两个核心功能：栅格布局和响应式布局，2.x版本和3.x版本语法差别非常，最新的是4.x

BootStrap也提供了很多js功能，例如轮播图，模态层，按钮提示等，但是功能比较弱

布局最外层容器

.container 固定宽度 1170px 970px 750px 和视口等宽通栏

.container-fluid 通栏宽度

栅格布局：把整体容器分成12列，然后控制子元素的列数，形成布局

分为 lg md sm xs四个临界点宽度，只有大于等于临界点宽度，才能维持栅格布局，否则会自动堆叠排列

数据库 database，简称db，数据库管理系统dbms

数据库常见厂商：甲骨文Oracle IBM DB2 微软Sql Server 甲骨文Mysql

数据表N

数据表2

数据表1

数据库N

数据库2

数据库1

数据库服务器

数据表的组成：列（字段） 行（记录） 列值（字段值）

数据表设计原则：每个表必须有一个id列，表示唯一值（在表中不能重复），这个列一般都设置为主键列（自动限制重复值），作为其他表引用的列值

自增列：自动产生列值，不需要用户手动输入，是一个流水号，一般主键列的id都是自增列。

数据操作：

查询操作：

select \* from 表名; 查询一个表中的所有列

select 列名1,列名2,…… from 表名; 查询一个表中某些列

select \* from 表名 where 条件表达式; 按照条件过滤数据

select \* from 表名 order by 排序字段 \[desc\]; 排序desc表示降序

插入数据操作：

insert into 表名 \[(列1，列2，……)\] values (值1，值2，……);

列列表可以省略，默认就是所有列

如果列值是自动生成，需要用default关键字代替

修改数据操作：

update 表名 set 列名=列值,列名=列值,…… where 条件表达式

删除数据操作：

delete from 表名 where 条件表达式;

软件开发的前后端结合方式分为两种：

一、传统开发，由后端代码（java php .net）直接生成数据画面，利用jsp asp动态网页技术，在网页中直接嵌入后端代码，缺点是耦合度太高，页面制作人员必须得前后端都写。

二、分离式开发，前后端的代码完全分离，前端用ajax对后端进行数据访问

## 三层架构

分为:表现层(UI)、业务逻辑层(BLL)、数据访问层

[MVC](http://baike.baidu.com/view/31.htm)全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写

background-size: cover;

APP开发的三种形式：

1.纯原生开发（NativeApp）：利用Java开发安卓，利用ObjectC，Swift开发苹果，缺点不能跨平台（需要做安卓版和IOS版），开发周期过长，UI开发过于繁琐，优点用户体验流畅，可以调用手机原生功能（硬件加速GPU，摄像头，通讯录，麦克风，重力感应，蓝牙传输，GPS，SD卡读写）

2.纯WEB开发（WebApp）：利用HTML5，CSS3，JavaScript开发网页的APP，一般需要通过手机浏览器打开，其实本质上是手机网站，优点跨平台，开发周期快，不需要升级APP，缺点，用户体验差，尤其是低端安卓手机（随着手机硬件的提示，将来不是问题），无法调用手机原生功能，费流量（因为网页都是在服务器端，每次打开界面都需要下载）

3混合开发(HybridApp)：在APP中嵌入浏览器组件（安卓WebView IOS UiWebView），通过这个组件直接在app中访问网页，网页中的UI组件可以通过JS接口访问原生的安卓和IOS功能

移动端开发框架

纯UI框架：bootstrap JqueryMobile mui ionic

调用原生功能混合开发框架：

**Phonegap（cordorva） js调用框架封装好的原生功能**

**React Native js转换为原生代码**

Html5plus 国产混合开发框架 开发工具hbuilder

ApiCloud 云平台直接生成app再下载到本地

Appcan 国产混合开发框架

Weex 阿里出品混合开发框架

其他：zepto.js 移动端的jquery，去除了一些移动端用不到的功能，减小体积，增加了移动端的事件，例如触摸，滑动，长按

## MVC

MVC 模型，视图，控制器

M：model，模型层。代表数据库中的数据源。

V：view，视图层。代表能看到的客户端页面，是根据模型数据创建的。

C：controller，控制层。代表业务逻辑，是模型层和视图层之间的桥梁，建立两者之间的关系。控制层本身是不会处理数据以及输出数据，他只是用来接受请求并决定用那个模型去处理请求，然后再确定用哪个视图来显示返回的数据。  


MVVM 模型视图 视图模型。 数据模型数据双向绑定 的思想为核心。  


ViewModel：视图模型，可实现数据的双向绑定，连接View和Model的桥梁，当数据变化时，ViewModel够监听到数据的变化（通过Data Bindings），自动更新视图，而当用户操作视图，ViewModel也能监听到视图的变化（通过DOM Listeners），然后通知数据做改动，这就实现了数据的双向绑定

## AngularJS

angularJS是谷歌出品的一个基于MVVM架构的JS框架，比较有特点的地方：MVC、模块化、自动化双向数据绑定、语义化标签（自定义指令）、依赖注入，页面路由等等。

AngularJS版本分为1.x和2.x，语法几乎完全不一样，2.x主要特点是适合移动端开发，语法变得简单。

**类似的框架**：knockout（最早期） backbone react.js（facebook出品） vue.js avalon（国产框架） ember.js

Ng中一切都是基于数据模型（model）！  

**Jquery适合做页面的动态效果，AngularJS更适合做增删改查的数据操作。**

**大型系统设计**

基于Angularjs的系统

过滤器

Filter

指令

Directive

指令模块

Module

服务模块

Module

控制器模块

Module

服务

Service

控制器

Controller

视图

View

模块N

ModuleN

模块2

Module2

模块1

Module1

**小型系统设计**

基于Angularjs的系统

过滤器

Filter

视图不是angularjs的js代码一部分，它就是网页的html代码。

在页面的dom范围中应用angulajs的功能，必须在指定范围应用**ng-app**指令，一般都是放到最外层的html标签（是一个html的自定义属性）

**数据绑定：**

用{{表达式}} ，表达式可以是变量，属性，带返回值的函数

ng-model指令：双向绑定表单元素的数据

控制器Contorller：在老版本中，可以有全局控制器，控制器可以不属于任何模块，新版本的控制器必须要基于某个模块。

创建module模块：angular.module("模块名",\[依赖的其他模块名称\]);

在html中通过ng-app指令设定使用的模块名称

创建控制器：模块对象.controller(‘模块名称’,函数对象($scope));

$scope 代表当前控制器的作用域范围对象，在这里设置的数据模型，才能被视图使用

在视图中，使用ng-controller指令指定使用的控制器对象，尽量不要使用控制器嵌套（ng-controller），会使作用域混乱

根作用域，作用域范围包含了所有控制器，是全局数据模型，需要通过模块对象的run方法初始化全局的数据，$rootScope代表全局作用域范围对象

依赖注入：

依赖：一个功能A调用了另个一个功能B，就可以理解为A依赖了B

注入：功能A直接获得了功能B的对象

在控制器中，经常需要注入一些对象，比如$scope,$http，但是这些对象的参数名称不能变化，为了防止代码压缩之后，参数名发生变化，ng提供了两种注入对象的方式

、把视图看做一个模板，模板中的动态数据由控制器提供，在视图中通过指令操作视图的数据

ng-repeat指令：在视图中遍历集合或对象，循环生成dom结构，$index返回当前下标

ng-disabled指令：动态设置元素的disabled属性

ng-bind指令：避免在视图绑定控制器数据之前，用户看到{{语法}}，通过一个额外html标签设置ng-bind来输出数据

ng-init指令：初始化数据，给数据赋值

脏检查：angularjs会对数据模型进行监控，当数据模型发生变化的时候，会及时更新视图的数据，这个过程就是脏检查。

一般来说，直接调用ng的指令，默认就会做脏检查，如果ng没有自动做脏检查，需要手动调用$apply方法做脏检查。

$interval和$timeout对象是ng自带的定时器，默认就会触发脏检查。

通过$watch方法检测数据模型的数据变化，触发回调函数，可以得到修改前的值和修改后的值，也可以强制给数据模型赋值

$watch方法，如果检测的数据模型是一个对象类型，对象中的属性值变化默认不会触发回调函数，如果希望能触发，必须多加一个参数true

ng-model-options指令：设置模型数据变化的时机，设置{updateOn:’blur’} 表示只有失去焦点才会进行数据更新（变化）

ng-show指令：动态显示元素

ng-hide指令：动态隐藏元素

在NG中，使用服务作为MVC中的M层，创建服务的方式：

1. 利用$provide.provider方法注册服务（语法不常用）
2. 利用$provide.factory方法注册服务
3. 利用$provide.service方法注册服务

factory相对于service方法注册服务，区别在于factory可以返回任何类型，甚至是基本类型，而service只能返回对象类型

多个控制器共享相同的数据，有两种方案：

1. 嵌套控制器（不推荐，会使作用域的数据混乱）
2. 利用服务，让多个控制器注入同一个服务对象（推荐使用）

在模块中定义一些常量（只赋一次值，不会在程序运行中变化）

用value方法定义**常量**

用constant方法定义**常量**

config方法：初始化模块的配置，定义config方法的两种方式：

方式1：在创建module的第三个参数

方式2：直接用模块对象.config方法

config只能注入constant常量，无法注入value定义的常量，config中唯一能注入的服务对象就是provider定义的服务，其他的factory和service定义的服务无法注入

run方法：程序启动以后，页面对用户可用之前执行，在config方法之后执行，可以注入provider，factory，service注册的服务，也可以注入value,constant设置的常量

angular.bootstrap方法：和那个css框架bootstrap没有半毛钱关系，这是用来动态应用模块的语句，可以代替ng-app设置，不能重复应用模块。

过滤器Filter：主要作用格式化数据和过滤数据，格式：表达式|过滤器名称

数字格式化过滤器：number

货币格式化过滤器：currency

日期格式化过滤器：date

大小写格式化过滤器：lowercase uppercase

过滤数据：

limitTo：过滤数组的前几位或后几位

filter：进行关键字模糊匹配过滤

orderBy：按照属性排序

可以在代码中使用内置的过滤器，但是需要注入$filter服务对象

自定义过滤器：独立在控制器，服务之外的单独对象，用模块对象.filter方法创建

ng-class指令：动态设置应用样式类

angularjs发出异步ajax请求（ng没有同步请求），必须注入$http服务，ng的ajax请求默认都是promise风格的，请求都会返回一个promise对象，然后通过这个对象这调用成功和失败的回调函数。

PayLoad 请求和FormData请求的区别：

PayLoad不会把数据按照键值对的形式发送给服务器，而是产生一个完整的固定字符串直接发送给服务器，需要服务器自己做解析。

AngualrJs的post请求默认就是payload形式，如果想按照FormData发送请求，需要对模块做额外的配置

Angularjs提供默认路由和第三方路由两种方式，自带的默认路由没有嵌套视图功能，一般我们使用都是第三方路由

ng-view指令：指定某个容器为显示路由页面的容器

url重写形式传递参数的两种方式：

1. url?参数名称=参数值&参数名称=参数值
2. /xxx/xxx/xxx rest风格的url

内置指令：

ng-bind-template：等价于ng-bind，但是需要写{{xxx}}，可以写多个表达式

ng-init指令：初始化数据，给数据赋值，在双层嵌套循环中非常有用

ng-repeat指令：遍历一个对象或者数组，内置值 $index遍历的下标 $first是否第一个元素 $last是否最后一个元素 $middle是否最后一个元素

ng-cloak指令：等价于ng-bind的功能，避免闪烁，但是还是可以使用{{}}绑定数据

ng-non-bindable指令：转义{{}}语法变为普通文本

ng-bind-html指令：不转义html语法，直接在浏览器执行，需要angular-sanitize.js插件支持和依赖ngSanitize模块

几乎所有的普通的html属性，都可以写成ng指令，例如ng-style ng-href ng-src等等，或者ng-attr-xxxx写法

大部分的js事件，都可以作为ng的指令，例如ng-click ng-focus ng-mouseover等等，$event代表当前事件对象

ng-show ng-hide指令：显示和隐藏

ng-class指令：应用样式类

ng-class-even：偶数应用样式

ng-class-odd：奇数应用样式

ng-if指令：类似if语句，只有为true才执行，如果false就不执行

ng-switch指令：类似switch语句，判断等值条件，执行内容

ng-copy指令：当复制内容触发事件

ng-cut指令：当剪切内容触发事件

ng-paste指令：当粘贴内容触发事件

ng-include指令：包含其他文件内容，需要基于服务器或者本地ajax测试

ng-open指令：折叠指令，配合details标签使用

自定义指令：通过模块对象. directive方法，开发人员可以自定义指令，自定义指令不要用ng开头，很容易和内置的指令搞混，自定义指令的主要作用就是编写一些可复用的组件。

在AngularJS内置了一个jquery，称作JQLite，能够实现最基本的JQ功能

自定义指令分为四种情况：

**E 元素**

C 样式

M 注释

**A 属性**

创建自定义指令的两种方式：

方式1：模块的配置中，使用 $compileProvider创建

方式2：直接使用模块对象.directive方法

指令在创建的时候，命名是驼峰写法xxXxxXxx，使用的时候是匈牙利命名法xxx-xxx-xx

指令的具体设置：

restrict：指令的类型，四种类型 **E 元素** C 样式 M 注释 **A 属性，**可以写一个到多个

template：模板内容

replace：如果为true，模板内容直接替换掉指令本身，如果为false，保留原始指令内容，模板内容必须有且只能有一个根标签

templateUrl：动态引入外部文件内容作为模板内容，但是模板内容必须有且只能有一个根标签

transclude：是否保留原始，ng-transclude指令：配合template或者templateUrl使用，代表保留下来的原始内容

compile方法：在指令执行的时候回调一次（尽量不要调用，否则link方法会失效）

link方法：在指令执行的时候回调多次，一般我们在link方法里直接操作dom

controller：属于指令自己的控制器

controllerAs：给控制器起个名字，在控制器中用this创建的方法，可以在视图中调用

require：依赖的其他指令，有三种依赖的形式

1. 直接写指令名，默认是在当前指令中查找
2. ^指令名，在父指令中找
3. ?指令名，表示找不到指令，创建指令本身不会抛异常

scope:控制器的独立作用域的设置，如果不设置，和父控制器共享作用域

\= 和父作用域的数据做双向数据绑定

@和父作用域的数据做单向数据绑定

&把父作用域的数据封装为一个函数，通过函数的返回值获得数据

表单和表单验证：

表单元素包括表单本身一定要加上name(不是id)

表单验证相关的属性

xxx. $dirty 如果表单或者输入框有使用到则为True

xxx. $pristine 如果表单或者输入框没有使用则为True

xxx. $valid 这一项表单元素是否验证通过

xxx. $invalid这一项表单元素是否验证未通过

xxx.$error 表单元素验证是否成功的数据模型

相关的表单验证的样式：

has-error：错误样式，表示验证失败

相关的验证规则：

required：必填

ng-minlength：最少几位字符

ng-maxlength：最多几位字符

ng-pattern：正则表达式验证

Angular 2 应用程序应用主要由以下 8 个部分组成：

- 1、模块 (Modules)
- 2、组件 (Components)
- 3、模板 (Templates)
- 4、元数据 (Metadata)
- 5、数据绑定 (Data Binding)
- 6、指令 (Directives)
- 7、服务 (Services)
- 8、依赖注入 (Dependency Injection)

## 跨域请求

一个域名下的程序发出一个请求，请求的url是另一个域名下的资源，这就是跨域请求，所有的浏览器默认都不允许ajax跨域请求。

**不同的域、协议或端口**请求一个资源时，资源会发起一个**跨域 HTTP 请求**。

同源策略的限制包括以下几个方面：

1\. Cookie、LocalStorage和IndexDB等存储在浏览器中的数据只能被同源网页访问，不能被其他源的网页访问。

2\. XMLHttpRequest和Fetch等网络请求API只能向同源网址发送请求，不能向其他源发送请求。这样可以防止跨域请求攻击。

3\. DOM操作也受到同源策略的限制。一个网页只能修改同源网页的DOM，不能修改其他源的DOM。

#### 解决跨域问题的方案

1. 在服务器端增加允许跨域请求的响应报头，设置Access-Control-Allow-Origin为\*
2. 利用jsonp技术，前端和后端配合实现跨域ajax

所谓的jsonp技术，就是利用浏览器并不禁止外联js是另一个域的js，所以jsonp跨域请求原理就是&lt;script src=”其他域的js”&gt;，而被外联的js是一个函数调用语句，通过实参把数据传递给请求客户端 动态创建script标签，  
 只支持GET请求；存在脚本注入以及跨站请求伪造等安全问题

1. Postmessage
2. Node 中间层代理
3. Ngix反向代理
4. Websocket

#### WebSocket

WebSocket是一种在单个TCP连接上进行全双工通信的协议。它被设计用于替代传统的HTTP请求/响应模型，以实现更高效、实时的通信。WebSocket使得服务器和客户端可以在建立连接后，双向发送数据，而无需每次发送数据前进行握手，这大大提高了数据传输的效率和速度。

1.2 WebSocket与HTTP的区别

连接方式：HTTP是基于请求/响应的模型，每次通信都需要建立新的连接（无状态的交互），而WebSocket在连接建立后，可以持续进行双向通信。

数据传输：HTTP传输数据时，需要封装成HTTP请求或响应，包含额外的头部信息，而WebSocket传输的数据更轻量(WebSocket 消息头较小)，没有HTTP头部的开销。

实时性：由于WebSocket的持续连接特性，它能够实现真正的实时通信，而HTTP则需要轮询或长轮询来模拟实时性，效率较低。

安全性：HTTPS：HTTP 可以通过 HTTPS 提供加密传输，确保数据的安全性。

WebSocket 可以通过 WSS（WebSocket Secure）提供加密传输，确保数据的安全性。

1.3 WebSocket的工作原理

WebSocket的工作流程如下：

握手：客户端通过HTTP发起一个WebSocket连接请求，服务器响应并完成握手过程。

连接建立：握手成功后，客户端和服务器之间的连接建立，此时可以开始双向通信。

数据传输：客户端和服务器可以发送任意类型的数据，包括文本和二进制数据。

关闭连接：任何一方都可以发送关闭帧来关闭连接，另一方接收到关闭帧后，会进行相应的处理并关闭连接。

##### WebSocket 升级握手过程

1. ****客户端发送升级请求****
2. ****服务器响应升级请求****
3. ****连接升级为 WebSocket****

###### 1\. 客户端发送升级请求

客户端通过发送一个 HTTP 请求来请求将连接升级为 WebSocket 协议。这个请求包含了一些特定的头部信息，用于标识这是一个 WebSocket 升级请求。

####### 请求头部

- ****Upgrade****: websocket — 表示请求将连接升级为 WebSocket 协议。
- ****Connection****: Upgrade — 表示这是一个升级请求。
- ****Sec-WebSocket-Key****: 一个由客户端生成的 Base64 编码的随机字符串，用于验证握手过程。
- ****Sec-WebSocket-Version****: 客户端支持的 WebSocket 协议版本，通常是 13。
- ****Sec-WebSocket-Protocol****（可选）: 客户端支持的子协议列表。

###### 2\. 服务器响应升级请求

服务器收到客户端的升级请求后，会验证请求的合法性，并生成一个响应。如果验证成功，服务器会发送一个 101 Switching Protocols 状态码的响应，表示连接已经成功升级为 WebSocket 协议。

####### 响应头部

- ****Upgrade****: websocket — 确认连接已升级为 WebSocket 协议。
- ****Connection****: Upgrade — 确认这是一个升级请求。
- ****Sec-WebSocket-Accept****: 服务器根据客户端提供的 Sec-WebSocket-Key 计算出的一个 Base64 编码的字符串，用于验证握手过程。
- ****Sec-WebSocket-Protocol****（可选）: 服务器选择的子协议。

##### 加密

使用 WSS (WebSocket Secure)：WSS 是基于 TLS/SSL 的 WebSocket 协议，确保数据在传输过程中加密。客户端和服务器之间的所有通信都经过加密，防止数据被窃听或篡改。

#### Node.js 中间层代理

使用 http-proxy-middleware



#### Nginx 反向代理

安装 Nginx

安装 Nginx 可以在多种操作系统上进行，下面分别介绍在 Ubuntu、CentOS 和 macOS 上安装 Nginx 的步骤。

Nginx 官方并不直接提供 Windows 版本的安装包，但你可以从其官方网站下载 Windows 版本的二进制文件，并手动进行安装和配置







配置  
  
使用：GET <http://localhost/api/users>



使用GET <http://localhost/static/images/logo.png>

#### 区别

**设置 Access-Control-Allow-Origin 为 \*：**

**优点：简单快捷，适用于简单的应用场景。**

**缺点：安全性较低，不适合涉及敏感数据的场景。**

**Node 中间层代理：**

**优点：灵活性高，可以在代理层进行复杂的逻辑处理。**

**缺点：增加了一层代理，可能会引入性能开销，系统复杂性增加。**

**Nginx 反向代理：**

**优点：高性能，配置灵活，适合处理大量并发请求和静态资源。**

**缺点：配置复杂，需要编写和维护配置文件**

**typescript笔记**

面向对象的基本特征：　抽象，继承，封装，多态性。{不同类对象对相同行为的不同反应}

typescript特征：类classes，接口interfaces,模块Modules ,类型注解Typeannotation,，编译时类型检查，箭头表达式，

let声明的变量存在于块级作用域，块级作用域变量在包含他们的块或for循环之外是不能被访问的．

for (let i = 0; i < 10 ; i++) { setTimeout(function() {console.log(i); }, 100 \* i); }

每次迭代都会生成新的作用域

代替

for (var i = 0; i < 10; i++) {

// capture the current state of 'i' // by invoking a function with its current value (function(i) { setTimeout(function() { console.log(i); }, 100 \* i); })(i); }

编译器会生成相应的供Node.js ([CommonJS](http://wiki.commonjs.org/wiki/CommonJS))，Require.js ([AMD](https://github.com/amdjs/amdjs-api/wiki/AMD))，isomorphic ([UMD](https://github.com/umdjs/umd)), [SystemJS](https://github.com/systemjs/systemjs)或[ECMAScript 2015 native modules](http://www.ecma-international.org/ecma-262/6.0/#sec-modules) (ES6)模块加载系统使用的代码

文件只有一个export class或export function （考虑使用export default）

Umd模块是指那些可以作为模块使用又可以作为全局（没有模块加载器的环境下）使用的模块

UMD的实现很简单，先判断是否支持NodeJS模块格式（exports是否存在），存在则使用NodeJS模块格式。

再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开的全局（window或global）。

修改的模块通常需要调用require来激活它们的效果。

## D3

-  d3.svg.axis()：D3 中坐标轴的组件，能够在 SVG 中生成组成坐标轴的元素。
- scale()：指定比例尺。
- orient()：指定刻度的朝向，bottom 表示在坐标轴的下方显示。
- ticks()：指定刻度的数量。





## JS

### Objec.Assgin



### 值类型和引用类型

值类型：

1保存与复制的是值本身

2使用typeof检测数据的类型

3基本数据类型是值类型

引用类型：

1保存和赋值的是指向对象的一个指针。

2使用instanceof检测数据类型

3使用new()方法构造出的对象是引用型

### **call()、apply()、bind()**

“call” 是每个函数都有的一个方法，它允许你在调用函数时为函数指定上下文。

**都是用来重定义 this 这个对象的！**



以上出了 bind 方法后面多了个 () 外 ，结果返回都一致！

由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。



手写bind

<https://zhuanlan.zhihu.com/p/54285383>

多次绑定bind是无效的

function.prototype.bind = function (context){  
var self = this;

return function() {

self.apply(context. argument)  
}

}

function getMax(arr){  
    var arrLen=arr.length;  
    for(var i=0,ret=arr\[0\];i<arrLen;i++){  
        ret=Math.max(ret,arr\[i\]);
    }  
    return ret;  
}

function getMax2(arr){  
    return Math.max.apply(null,arr)  
}

### super





**第一种情况**，super作为**函数**调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 是因为子类需要继承父类的构造函数，并确保正确设置this。在调用 super() 或 super(props) 之前，不能访问 this 上的属性，因为此时 this 尚未被完全初始化。  


上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。

注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。

### call





使用call方法调用父构造函数





严格模式： 禁止拼写错误，禁用with方法。可以编写”更安全”的JS,减少性能损耗。为ES版本打好基础。

### New操作符

New操作符创建一个空对象，用this指代该对象。同时继承该函数的原型。属性和方法被加到this 引（1）首先创建了一个新的空对象

（2）设置原型，将对象的原型设置为函数的 prototype 对象。

（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）

（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。用的对象中。

### Object.create()

Object.create = function (o) {

var F = function () {};

1. prototype = o;

return new F();

};

#### 区别

·创建的新函数并没有继承构造函数的属性和方法，只继承了原型方法和原型属性  


### 模块化

在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。

前者用于服务器，后者用于浏览器。

CommonJS 是一种主要用于 Node.js 环境的模块化规范

Es6的设计思想是， 是尽量的静态化，是的编译时就能确定模块的依赖关系，以及输入和输出的变量。Commonjs和AMD模块 都只在运行时确定这些东西，

比如commonjs模块就是对象，输入时必须查找对象属性



上面代码的实质时整体加载fs模块，（即加载fs所有方法），生成一个对象 \_fs,然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”。导致没办法在编译时做“静态优化”。

ES6模块不是对象，而是通过export命令显示指定输出的代码，输出时也采用静态命令的形式。



上面的代码是从fs模块加载3个方法，模块加载3个方法，其他方法不加载

，这种加载称为“编译时加载”。但是这也导致了没法引用模块本身，因为它本身不是对象



上面代码单独想租写法，第一组使用export default时。对应的import语句不需要使用大括号。第二组是不使用export default时，需要使用

export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。

本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。

ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。也就是说

Commonjs: 一旦输出一个值。模块内部的变化就影响不到这个值，

Es6: ES6模块是动态引用，



CommonJs和AMD:

CommonJs:  
1定义模块，根据CommJs规范，一个单独的文件就是一个模块。

2：模块输出,模块只有一个出口。Module.exports对象。

3：加载模块,加载模块使用require方法

AMD:

异步模块的定义，它是浏览器端模块开发的规范。由于不是js的原生支持，需要用到对应的库函数。Require.js.

Require.js主要解决两个问题：多个js有依赖问题。被依赖的文件需要早于依赖它的文件加载。2.js文件加载会停止页面渲染。

RequireJs定义了一个函数define，它是全局变量，用来定义模块。

Define(id？,dependencies?, factory) id可选参数，定义标识模块，工厂方法，模块初始化要执行的函数和方法。

Require(\[dependencies\],function(){}) Require函数是异步加载的，这样浏览器不会失去响应。

CMD通用模块定义。有个浏览器的实现Seajs. Sea.js要实现的和require实现一样，模块定义方式和模块加载有所不同。 sea.use()来加载模块

### 库

go.js 提供一整套的JS工具 ，支持各种交互式图表的创建

d3可谓是最好的可视化基础库，提供方面的DOM操作，非常强大

构造函数的缺点是每次实例化一个对象，都会把属性和方法复制一遍，避免方法。在构造函数的原型中定义属性和方法

Webpack WebPack是一种模块化的解决方案，模块打包机，构建本地服务器。

和gulp :文件压缩，less/sass预编译,启动server,版本控制 。gulp强调的是前端开发流程

### This 绑定

foo() ---> foo.call(window)

obj.foo() --> obj.foo.call(obj)

**this永远指向函数执行时的上下文**

执行上下文： 是评估和执行js代码环境的抽象概念,每当js代码在运行的时候，它都在执行上下文中运行。

全局执行上下文： 基础的上下文， 1创建全局的window对象，并设置this等于这个全局对象。一个程序中只有一个全局执行上下文

函数执行上下文：每当函数调用时，都会为函数创建一个新的上下文

在全局执行上下文中，this的值指向全局对象

在函数执行上下文中，this的值取决于该函数是如何被调用的，  
如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undifined,



**匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。**

**匿名函数最大的用途是创建闭包**，并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。

Let foo = {

Baz: function(){

Console.log(this)

}

}

Foo.baz() //”this” 引用’foo’因为 ‘baz’ 被对象’foo’调用

Let bar = foo.baz; bar(); //’this’指向全局window对象,因为没有指定引用对象



调用setTimeout的对象是window.

箭头函数的this始终指向函数定义时的this,



### IEEE标准754浮点数

是当今计算机上实数的最常见表示

IEEE浮点数有三个基本组成部分： 符号，指数和尾数

JavaScript 内部，所有数字都是以64位浮点数形式储存

### 立即执行函数IIFE

<https://zhuanlan.zhihu.com/p/74440468>  
1.function (){/\* code \*/}() // error

js代码解释时，遇到function关键字会默认把它当作一个函数声明，如果没有显式的表达成函数表达式，就会报错，因为函数声明需要函数名。

2\. function foo{/\* code \*/}() //error

加上函数名也会报错，因为（）被识别成分组操作符。实际如下：

function foo{/\* code \*/}

() //error

3.

（ function (){/\* code \*/}()）或者（function (){/\* code \*/}）()

括号里面不能包含语句，将function关键字识别为函数表达式。

#### 立即执行函数的作用

1：不必为函数命名，避免了污染全局变量

2：立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量

3：封装变量



#### 立即执行函数的参数

如果立即执行函数需要全局变量，变量会作为参数传递给立即执行函数 i是实参，j是立即执行函数中的形参。

（Function（j）{

//代码中可以使用j

}）（i）

#### 立即执行函数的返回值



### 声明提升

函数才会创建新的作用域  
1.变量提升只会提升变量名的声明，而不会提升变量的赋值初始化。

2.函数提升优先于变量提升，即函数提升在变量提升之上。

3.函数声明会将函数提升（包括声明function和赋值=），函数表达式只会将变量var提升。



function fn() {

&nbsp;   getValue = function () { console.log(1); };

&nbsp;   return this;

}

fn.getValue = function () { console.log(2);};

fn.prototype.getValue = function () {console.log(3);};

var getValue = function () {console.log(4);};

function getValue() {console.log(5);}

var getValue = function () {console.log(4);};

function getValue() {console.log(5);}

//请写出以下输出结果：

getValue();

//4

fn().getValue();

//1

getValue();

//1

new fn.getValue();

//2

new fn().getValue();

//3

#### 块级作用域的函数声明

if(true){

&nbsp; a = 10;

&nbsp; console.log(a,window.a);

&nbsp; function a(){};

&nbsp; console.log(a,window.a);

}

//10 undefined

//10 10

if(true){

&nbsp; console.log(a,window.a);

&nbsp; function a(){};

&nbsp; a = 10;

&nbsp; console.log(a,window.a);

}

//ƒ a(){} undefined

//10 ƒ a(){}

[https://github.com/lgwebdream/FE-Interview/iss](https://github.com/lgwebdream/FE-Interview/issues/96)[ues/96](https://github.com/lgwebdream/FE-Interview/issues/96)  

在块级作用域中默认声明的变量，只有代码执行到声明语句之后，才可以进行访问，否则会报错。  
块级作用域中默认声明的变量会被提升到全局作用域。

ECMAScript的作用域只有两种：全局作用域；和函数作用域。

但ES6的到来，为我们提供了‘块级作用域’。凡是带{}都是块级作用域

window.a只有等块级作用域中函数声明的定义的那行代码执行过之后，才会被映射到全局作用域。

函数声明中，整个函数体也都会被提升，而函数表达式中只会提升名称







等于



  
<br/><br/>var x = 3;

let result = {

x: 2,

baz: {

x: 1,

bar: function() {

return this.x;

}

}

}

let go = result.baz.bar;

console.log(result.baz.bar())

console.log(go())

### 避免全局变量

1： 立即执行函数

2： 声明命名空间

3： 模块化

### 递归

一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法

### 算法的时间复杂度和空间复杂度

<https://blog.csdn.net/qq_41523096/article/details/82142747>  
算法的效率主要由以下两个复杂度来评估：

时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。

空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。

时间复杂度：

一个算法中语句执行次数称为语句频度或时间频度 记为T(n)

若有某个辅助函数f(n) 使得当n趋近无穷大时， T(n)/f(n)的极限值为不等于零的常数。则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称**时间复杂度**。

### 继承

#### 通过子类的原型prototype对象实例化来实现



缺点是：子类之间相互影响。所有子对象共享同一个原型对象，对原型对象的修改会影响到所有子对象

#### 构造函数式继承

构造函数继承是通过在子构造函数中调用父构造函数来实现继承。在构造函数继承中，通过在子构造函数中使用\*\*call()或apply()\*\*方法，将父构造函数的上下文设置为子对象的上下文，从而实现继承。

  
使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。Parent.call(this ,name),所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中。

#### 组合式继承



但是父类的构造函数会被创建两次（一次是在设置原型时，一次是在创建子对象时）



// 继承父类的实例属性

SuperType.call(this, name);

// 继承父类的原型方法

SubType.prototype = Object.create(SuperType.prototype);

#### 寄生组合继承



####  ES6中的继承 extends

在 ES2015 中有了 class 语法糖，有了 extends、super、static 这样的关键字，更像强类型语言中的“类”了。

### 字符相加

<https://2ality.com/2012/01/object-plus-object.html>  
[https://blog.csdn.net/jian_zi/a](https://blog.csdn.net/jian_zi/article/details/105137258)[rticle/details/105137258](https://blog.csdn.net/jian_zi/article/details/105137258)

！可将变量转换成boolean类型，null、undefined、NaN以及空字符串('')取反都为true，其余都为false。

\[\] + {} "\[object Object\]"

{} + \[\] => + \[\] 0

通过Number()将值转换为数字

Number(Undifined) NaN

Number({}) NaN

\> 1 + 'string'

'1string'

\> 1 + undefined

NaN

\> 1 + null

1

\> 1 + \[2,3,\]

"12,3"

\> 1 + {name: 'andyyou'}

"1\[object Object\]"

1 + true = 2;

- var a = (2, 3, 5);

5

Math.max(\[2,3,4,5\])

NaN

.1+.2

0.3

_// 上面的範例我們得知，除了 undefined 和 null，基本上 js 會把物件先 \`toString()\` 再相加。_

### **聚合运算符**

\*\*??\*\*是聚合运算符，如果左值为 null 或 undefined，就返回右值。默认返回左值。

const test= null ?? 'default';

console.log(test);

// expected output: "default"const test1 = 0 ?? 2;

console.log(test1);

// expected output: 0

纯函数：

1. 纯函数是那些返回值仅取决于其参数值的函数。

### 发布订阅实现  

• 观察者模式里，只有两个角色 —— 观察者 + 被观察者

• 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— 经纪人Broker

往更深层次讲：

观察者和被观察者，是松耦合的关系

发布者和订阅者，则完全不存在耦合

从使用层面上讲：

观察者模式，多用于单个应用内部

发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件

1： 声明一个全局发布-订阅对象

Const Observer = (function() {

// 订阅器

const \_observer = {}

// 订阅

const subscribe = function (type, callback) {

if (\_toString.call(callback) !== '\[object Function\]') return

// 订阅器中是否存在订阅行为；

if (!\_observer\[type\]) \_observer\[type\] = \[\]

\_observer\[type\].push(callback)

return this

}

// 发布

const publish = function () {

// 获取发布行为

let type = \_shift.call(arguments)

// 获取发布主题

let theme = \_slice.call(arguments)

// 记录发布主题

if (!\_cache\[type\]) {

\_cache\[type\] = \[theme\]

} else {

\_cache\[type\].push(theme)

}

// 获取相关主题所有订阅者行为

let subscribes = \_observer\[type\]

// 发布主题

if (!subscribes || !subscribes.length) return

subscribes.forEach(callback => {

callback.apply(this, theme)

})

return this

}

// 取订

const unsubscrible = function (type, callback) {

if (!\_observer\[type\] || !\_observer\[type\].length) return

let subscribes = \_observer\[type\]

subscribes.some((item, index, arr) => {

if (item === callback) {

arr.splice(index, 1)

return true

}

})

return this

}

li

})

### Object 数据劫持

声明一个对象。把要监听的数据作为它的属性，再更改的时候，改变对象的值，然后写一个Observer 方法监听这个数据。再把 data 和key 和value 传递到 数据监听方法，用object。DefineProperty监听更改， 在set方法里面 执行渲染方法。

1 &lt;input type="text" name="" id="demo"&gt;

2 &lt;div id="show"&gt;&lt;/div&gt;

3 &lt;script&gt;

4 var oDiv = document.getElementById('show');

5 var oInput = document.getElementById('demo');

6 var oData = {

7 valueObj:{

8 value:'duyi'

9 },

10 name:'haha'

11 }

12 //输入框事件：触发数据修改(写入)

13 oInput.oninput = function(){

14 oData.name = this.value;

15 // oData.valueObj.value = this.value;

16 }

17 //修改DOM数据（页面渲染）

18 function upDate(){

19 oDiv.innerText = oData.name;

20 // oDiv.innerText = oData.valueObj.value;

21 }

22 upDate();//初始数据渲染

23 //给数据绑定监听

24 function Observer(data){

25 if(!data || typeof data != 'object'){

26 return data;

27 };

28 // Object.keys(data)不能获取数组的索引，所以Observer无法实现数据数据监听

29 Object.keys(data).forEach(function(item){

30 definedRective(data,item,data\[item\]); //

31 })

32 }

33 //数据监听：当setter被触发时，修改数据并渲染到页面

34 function definedRective(data,key,val){

35 Observer(val); //使用递归深度监听对象数据变化，例如：示例数据oData.valueObj.value的监听

36 Object.defineProperty(data,key,{

37 get(){

38 return val;

39 },

40 set(newValue){

41 if(newValue == val) return;

42 val = newValue;

43 upDate(); //数据渲染到DOM

44 }

45 })

46 }

47 Observer(oData);//给数据绑定监听方法

48 &lt;/script&gt;

### 数组数据劫持

不能使用getter setter. 所以劫持常用的数组方法

&nbsp;&lt;input type="text" name="" id="demo"&gt;

&nbsp;   &lt;div id="show"&gt;&lt;/div&gt;

&nbsp;   &lt;script&gt;

&nbsp;       var oDiv = document.getElementById('show');

&nbsp;       var oInput = document.getElementById('demo');

&nbsp;       let arr = \["duyi"\];

&nbsp;       let {

&nbsp;           push

&nbsp;       } = Array.prototype;

&nbsp;       console.log(push);

&nbsp;       function upArrData() {

&nbsp;           oDiv.innerText = arr\[arr.length - 1\];

&nbsp;       }

&nbsp;       upArrData();

&nbsp;       oInput.oninput = function() {

&nbsp;           arr.push(this.value);

&nbsp;       }

&nbsp;       Object.defineProperty(Array.prototype, 'push', {

&nbsp;           value: (function() {

&nbsp;               return function(...arg) {

&nbsp;                   push.apply(arr, arg);

&nbsp;                   upArrData();

&nbsp;               }

&nbsp;           })()

&nbsp;       });

&nbsp;   &lt;/script&gt;

或者重写push 方法。

&nbsp;       var oDiv = document.getElementById('show');

&nbsp;       var oInput = document.getElementById('demo');

&nbsp;       let arr1 = \["duyi"\];

&nbsp;       function upArrData() {

&nbsp;           oDiv.innerText = arr1\[arr1.length - 1\];

&nbsp;       }

&nbsp;       upArrData();

&nbsp;       oInput.oninput = function() {

&nbsp;               arr1.push(this.value);

&nbsp;           }

&nbsp;

&nbsp;       var arr = \['push', 'slice', 'shift', 'unshift'\];

&nbsp;       arr.forEach(method => {

&nbsp;           let oldPush = Array.prototype\[method\];

&nbsp;           Array.prototype\[method\] = function(value) {

&nbsp;               oldPush.call(this, value)

&nbsp;               upArrData();

&nbsp;           }

&nbsp;       })

### Optional chaining

**当 ?. 前面的变量值为 null 或 undefined 时，?. 返回的结果为 undefined**。

a?.b // undefined if \`a\` is null/undefined, \`a.b\` otherwise.

a == null ? undefined : a.b

a?.\[x\] // undefined if \`a\` is null/undefined, \`a\[x\]\` otherwise.

a == null ? undefined : a\[x\]

a?.b() // undefined if \`a\` is null/undefined

a == null ? undefined : a.b() // throws a TypeError if \`a.b\` is not a function

// otherwise, evaluates to \`a.b()\`

a?.() // undefined if \`a\` is null/undefined

a == null ? undefined : a() // throws a TypeError if \`a\` is neither null/undefined, nor a function

// invokes the function \`a\` otherwise

### 前端资源加载失败优化

1\. 加载失败时，刷新页面 (reload）

2.针对加载失败的文件进行重加载

保证 JS 按顺序执行

1.我们可以给 script 标签添加上 onerror 属性，这样在加载失败时触发事件回调，从而捕捉到异常。



借助构建工具 ( 如 webpack 的 [script-ext-html-webpack-plugin](https://www.npmjs.com/package/script-ext-html-webpack-plugin) 插件) ，我们可以轻易地完成对所有 script 标签自动化注入 onerror 标签属性



1. window.addEventListener

因为 onerror 的事件并不会向上**冒泡**，window.onerror 接收不到加载失败的错误。**冒泡虽不行，但捕获可以**！我们可以通过捕获的方式全局监控加载失败的错误，虽然这也监控到了脚本错误，但通过 !(event instanceof ErrorEvent) 判断便可以筛选出加载失败的错误。



### V8

即时编译（JIT）：V8 在运行时将 JavaScript 代码转换成机器码，而不是字节码。这种方式可以提高执行速度，因为机器码可以直接由处理器执行。

快速执行：由于 V8 在运行时直接生成本地代码，这使得 JavaScript 能够更快地执行。此外，V8 还包括了一个称为“Crankshaft”的优化编译器，它可以进一步优化热点函数，使其执行速度更快。

垃圾回收机制：V8 使用了一种称为标记-清除（Mark-Sweep）的垃圾回收算法来管理内存。这意味着当不再有引用指向某个对象时，该对象占用的内存会被自动释放。

全速调试工具：V8 提供了调试工具，允许开发者在不影响性能的情况下检查和修改 JavaScript 代码。

JavaScript 对象直接属性访问：在 V8 中，JavaScript 对象直接存储它们的属性，而不是通过查找表，这提高了访问速度。

跨平台支持：V8 可以在多个操作系统上运行，包括 Windows、macOS 和 Linux。

独立于浏览器：虽然 V8 最初是为了浏览器而设计的，但它也可以作为一个独立的模块被集成到任何 C++ 应用程序中，这样可以在桌面应用程序或者服务端程序中使用 JavaScript。优化资源加载失败

### Ajax

- 1. 创建XMLHttpRequest对象。
  2. 创建一个新的http请求，并制定http请求的方法，URL 及验证信息（是否支持异步。默认为true）
  3. 设置响应Http请求状态变化的函数变化的函数。
  4. 发送HTTP请求

Let xhr = new XMLHttpRequest();

Xhr.open(“GET”, url, true)

Xhr.responseType = “json”

Xhr.setRequestHeader(“Accept”, “application/json”)

Xhr.onreadystatechange = function() {}

xhr.onerror = function () {}  
xhr.send(null);

Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。

### Fetch

avaScript 中发起 HTTP 请求的库

与ajax的不同

1 API 设计风格

Fetch API：采用了 Promise 的模式来处理异步操作，更加符合现代 JavaScript 的编程习惯。Fetch API 的 API 设计简洁明了，易于理解和使用。

AJAX：通常依赖于 XMLHttpRequest 对象，它提供了多个状态码和事件来处理请求和响应。尽管 XMLHttpRequest 也可以使用 Promise 包装，但它的原生 API 更加繁琐。

2返回值

Fetch API：总是返回一个 Promise，无论请求是否成功，都需要通过 .then() 方法来处理结果。如果请求失败，会返回一个带有错误状态码的 Response 对象。(当接收到错误的Http 状态码时 返回的promise 不会标记为reject.只有网络故障和请求被阻止才会标记为reject)

AJAX：使用 XMLHttpRequest 时，可以通过 onreadystatechange 事件来处理请求完成的状态变化，也可以使用 responseText 或 responseXML 属性来获取响应内容。

3 全局错误处理

Fetch API：如果请求过程中出现了网络错误或者其他类型的错误，Promise 会被 reject，因此可以通过 .catch() 来处理这些错误。

AJAX：需要为 XMLHttpRequest 设置 onerror 和 onabort 事件来处理错误



1. ****缺少拦截器****：没有内置的请求和响应拦截器。
2. ****手动处理JSON****：需要手动将响应数据转换为JSON。
3. ****错误处理****：fetch 不会因为HTTP错误状态码（如404或500）而reject Promise，需要手动检查响应状态。

### Axios

#### **Axios**

##### **优点**

1. ****跨浏览器兼容性****：axios 支持所有现代浏览器，包括IE11。
2. ****Promise-based****：基于Promise，使得异步操作更加简洁和易于处理。
3. ****拦截器****：可以设置请求和响应的拦截器，方便进行请求和响应的预处理。
4. ****自动转换****：自动将响应数据转换为JSON（如果响应类型为JSON）。
5. ****支持多种请求方法****：GET、POST、PUT、DELETE等。
6. ****错误处理****：提供了统一的错误处理机制。
7. ****取消请求****：支持取消请求，可以用于处理用户取消操作或超时情况。

##### **缺点**

1. ****需要额外安装****：需要通过npm或其他包管理工具安装。
2. ****体积较大****：相比原生的fetch，axios的体积稍大一些。





### 柯里化

<https://www.jianshu.com/p/2975c25e4d71>

主要用于将接受多个参数的函数转换为接受单个参数的函数，并返回一个新函数，该新函数接受余下的参数并返回结果

// 普通的add函数

function add(x, y) {

return x + y

}

// Currying后

function curryingAdd(x) {

return function (y) {

return x + y

}

}

add(1, 2) // 3

curryingAdd(1)(2) // 3

###  Logical Assignment Operators

&&=

first value is truthy(_falsy_), the second value will be assigned to it.

**let firstNumber = 5;  
let secondNumber = 20;firstNumber &&= secondNumber; //output: 20  
console.log(firstNumber); //output: 20//Here is an equivalent to it:  
if(firstNumber){  
firstNumber = secondNumber;  
}**

||=

first value is not truthy(_falsy_), the second value will be assigned to it.

**let firstNumber = null;  
let secondNumber = 10;  
firstNumber ||= secondNumber; //output: 10  
console.log(firstNumber); //output: 10  
//Here is an equivalent to it:  
if(!firstNumber){  
firstNumber = secondNumber;  
}**

??=  
checks if the first value is null or undefined. If it is, the second value is assigned to it.

**//when first value is null or undefined  
let firstNumber = null;  
let secondNumber = 10;  
firstNumber ??= secondNumber; //output: 10  
console.log(firstNumber); //output: 10//when first value is truthy  
firstNumber = 9;  
firstNumber ??= secondNumber; //output: 9  
console.log(firstNumber); //output: 9//Here is an equivalent to it:  
if(firstNumber == null || firstNumber == undefined){  
firstNumber = secondNumber;  
}**

## Aurelia

Aurelia: 用新一代的Es,技术向前兼容。没有外部依赖，高度模块化的开发。更强大的双向绑定，可拓展的HTML

### 生命周期



### DOM事件

Trigger：将事件处理程序直接附加到元素。触发事件时，将调用表达式。

Delegate: 将单个处理程序附加到文档，该文档处理冒泡阶段中指定类型的所有事件。

capture：将单个事件处理程序附加到文档（或最近的影子DOM边界），该处理阶段处理捕获阶段中指定类型的所有事件

call: 在开发自定义元素或自定义属性时，您可能会遇到一种情况，即您拥有@bindable需要引用函数的属性。使用callbinding命令声明函数并将函数传递给bindable属性。该call命令优于bind此用例的命令，因为它将在正确的上下文中执行该函数，确保this您期望它。

Self

mousedown.delegate='onMouseDown($event) & self'

使用self绑定行为，您可以指定事件处理程序仅响应附加侦听器的目标，而不是其后代。





＆符&代表一个BindingBehavior（而不是按位AND）

条形|代表一个ValueConverter（而不是按位OR）

当我们使用时model.bind，内容被传递给activate。

要定义输入的“值”，请绑定输入的model属性：model.bind="product.id"。



### Referencing Elements

- element.ref="expression": create a reference to the DOM element (same as ref="expression").
- attribute-name.ref="expression": create a reference to a custom attribute's view-model.
- view-model.ref="expression": create a reference to a custom element's view-model.
- view.ref="expression": create a reference to a custom element's view instance (not an HTML Element).
- controller.ref="expression": create a reference to a custom element's controller instance.

### ValueConverter

1: 创造value converter. 用toview 方法将value应用到视图上

import numeral from 'numeral';

export class CurrencyFormatValueConverter {

toView(value) {

return numeral(value).format('($0,0.00)');

}

}

2:在view里面require the converters 、

3：Finally, we applied the converter in the binding using the pipe | syntax

${currentDate | dateFormat} &lt;br&gt;

${netWorth | currencyFormat}

#### Toview的参数

1：convert的value 或者repeat的数组

其它参数partFilter: 'name' : modelSearch.value

或者 {propertyName: 'open_issues', direction: 'descending'}

#### Fromview



当a global parameter that is unobservable by Aurelia is used inside a value converter可以用signalBindings

[https://aurelia.io/do](https://aurelia.io/docs/binding/value-converters)[cs/binding/value-converters](https://aurelia.io/docs/binding/value-converters)

### computer property

当我们使用藏检查时 会调用太多次

所以可以用到 @computedFrom decorator

@computedFrom tells the binding system which expressions to observe

export class Person {

firstName: string = 'John';

lastName: string = 'Doe';

get fullName(): string {

return \`${this.firstName} ${this.lastName}\`;

}

}

import {computedFrom} from 'aurelia-framework';

export class Person {

firstName: string = 'John';

lastName: string = 'Doe';

@computedFrom('firstName', 'lastName')

get fullName(): string {

return \`${this.firstName} ${this.lastName}\`;

}

}

### Binding Behaviors

updateTrigger

Update trigger allows you to override the input events that cause the element's value to be written to the view-model. The default events are change and input.

Here's how you would tell the binding to only update the model on blur:

&lt;input value.bind="firstName & updateTrigger:'blur'&gt;

Update with multiple events:

&lt;input value.bind="firstName & updateTrigger:'blur':'paste'&gt;

#### Signal

作用

The signal binding behavior enables you to "signal" the binding to refresh. This is especially useful when a binding result is impacted by global changes that are outside of the observation path.

使用

In the binding expression above we're using the signal binding behavior to assign the binding a "signal name" of my-signal. Signal names are arbitrary, you can give multiple bindings the same signal name if you want to signal multiple bindings at the same time.

### Observing Collections

Use the Collection Observer to observe changes to a collection. Collection types that can be observed are Array , Map , and Set . Create a subscription by providing the collection to observe and a callback function.

import {BindingEngine, autoinject, ICollectionObserverSplice} from 'aurelia-framework';

@autoinject

export class App {

myCollection: Array&lt;string&gt; = \["foo"\];

constructor(private bindingEngine: BindingEngine) {

let subscription = this.bindingEngine.collectionObserver(this.myCollection)

.subscribe(this.collectionChanged.bind(this));

}

collectionChanged(splices: Array&lt;ICollectionObserverSplice<string&gt;>) {

// This will fire any time the collection is modified.

}

}

### 依赖注入

假设我们CustomerEditScreen需要Customer通过Web从Web服务加载实体。我们不希望将AJAX实现的所有细节都放在我们的CustomerEditScreen类中。相反，我们希望将其分解为CustomerService我们CustomerEditScreen或任何其他类在需要加载时可以使用的类Customer。Aurelia的依赖注入容器允许您通过声明CustomerEditScreen需要CustomerService在创建时注入来实现此目的。

## ES6

### Let

<https://zhuanlan.zhihu.com/p/74099086?from_voters_page=true&utm_id=0>

###   

const



### ESLint

<https://github.com/lgwebdream/FE-Interview/issues/1132>  
<https://github.com/markerikson/react-redux-links/blob/master/es6-features.md>  

### AST抽象语法树（Abstract Syntax Tree）

**解析和验证**：通过解析源代码，将其转换为AST之后，可以对代码进行验证和静态分析。这包括检查语法错误、类型错误、变量引用等，并发现潜在的问题或优化机会。

**优化和转换**：AST可以用于执行各种优化操作，例如消除冗余代码、提取共享表达式、内联函数调用等。它还能够进行代码转换，例如将ES6代码转换为ES5兼容的代码、将模板编译为渲染函数等。

**生成代码**：从AST中可以再次生成目标代码，如JavaScript、HTML、CSS等。这使得可以将源代码翻译为其他语言、在不同平台上执行代码等。

### 将ES6代码转换成es5的实现思路

1.将代码解析成抽象语法树，即AST

2 对AST进行处理，这个阶段可以对Es6进行相应转换，即转成es5代码

3 根据处理后的AST再生成代码字符串

### 基础

let和const,变量的解构，字符串的拓展（模板字符串），数组的拓展，字符串的拓展， symbol类型，迭代器：array，map,set,for in ,for of”,promise, async, generator.

Bable转码let 给var加_

1.let 和 const: let具有块级作用域的特性，

for 循环时产生的闭包 可以使用let,



### 箭头函数

箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。

导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

箭头函数不支持 arguments 对象，但可以通过使用剩余参数（...）来实现类似的功能。

const arrowFunc = (...args) => {

console.log(args);

};

arrowFunc(1, 2, 3); // 输出 \[1, 2, 3\]

### 泛型

组件不仅能支持当前数据类型，也能支持未来的数据类型。使用泛型创建可重用的组件。支持多种数据类型

function identity(arg: number): number {

return arg;

}

或者，我们使用any类型来定义函数：

function identity(arg: any): any {

return arg;

}

使用any类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。

因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 类型变量，它是一种特殊的变量，只用于表示类型而不是值。

function identity&lt;T&gt;(arg: T): T {

return arg;

}

### Symbol

Es6 引入了新的原始数据 symbol, 表示独一无二的值

Let s = Symbol();

#### 因为symbol是一个原始数据的值。 不是对象 所以不能使用new命令

创建 Symbol 的时候，可以添加一个描述。

const sym = Symbol('foo');

sym.description // "foo"

#### 由于每一个symbol的值都是不想等的，所以symbol值可以作为标识符

Let mysym = Symbol();

Let a = {};

a\[mysym\] = “hello”;

let a = {};

Object.defineProperty(a, mySymbol, {value: “Hello”})

#### Symbol.for(), Symbol.keyFor()

Symbol.for("bar") === Symbol.for("bar")

// true

Symbol("bar") === Symbol("bar")

// false

### Proxy

Proxy 是一个构造函数，它能够创建一个代理对象，用于拦截并定义基本操作。

用于修改某些操作的默认行为，等同于在语言层面做出修改。

var proxy = new Proxy(target, handler);

Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为.

使其在数据验证、日志记录、权限控制、虚拟代理和懒加载等场景中非常有用。通过

get方法用于拦截某个属性的读取操作  
set方法用来拦截某个属性的赋值操作





判断对象中是否有某个对象

### Reflect

Reflect对象上可以拿到语言内部的方法。

- **)将 Object 对象一些内部的方法，放到 Reflect 对象上。比如 Object.defineProperty**

现阶段这些方法存在于 object 和 Reflect 对象上，未来只存在于 Reflect 对象上。

意义：也就是说，从 Reflect 对象上可以拿到语言内部的方法。

- **2)操作对象时出现报错返回 false**



比如：Object.defineProperty(obj,name,desc) 在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj,name,desc)则会返回 false,这样会更合理一些。

- **3)让操作对象的编程变为函数式编程**

说明：老写法有的是命令式编程，比如下面这个例子



- **4)保持和 Proxy 对象的方法一一对应**

说明：Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。



Reflect 和 Proxy 都是用来控制和操作 JavaScript 对象，Reflect 提供了一组标准的方法来执行语言内部的操作，而 Proxy 则允许你自定义这些操作的行为

### Array

#### **Array.from()**

**Array.from()** 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

console.log(Array.from('foo'));

// Array\[“f”, “o”, “o”\]

console.log(Array.from(\[1,2,3\], x=> x + x);

//Array\[2,4,6\]

#### Flat()

Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维数组。该方法返回一个新数组，对原数据没有影响。  
\[1, 2, \[3, 4\]\].flat()

// \[1, 2, 3, 4\]

flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。

如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。

\[1, \[2, \[3\]\]\].flat(Infinity)

// \[1, 2, 3\]

#### flatMap()

flatMap()方法对原数组的每个成员执行一个函数，相当于执行Array.prototype.map(),然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。

### Set 和 Map 数据结构

#### Set

Set结构类似于数组，但是成员都是唯一的没有重复的值。

Set本身是一个构造函数，用来生成set数据结构。

Set实例的属性和方法：

##### 属性

1. Set.prototype.constructor：构造函数，默认是就是set函数
2. Set.prototype.size：返回Set实例的成员总数。

##### 操作方法

- Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
- Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
- Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
- Set.prototype.clear()：清除所有成员，没有返回值。

##### 遍历操作

- Set.prototype.keys(): 返回键名的遍历器
- Set.prototype.values()：返回键值的遍历器
- Set.prototype.entries()：返回键值对的遍历器
- Set.prototype.forEach()：使用回调函数遍历每个成员

由于set结构没有键名 没有键值。所以keys方法和value方法行为完全一致

#### Map

Object本质上是键值对的集合但是传统上只能用字符串当做键

Map结构是一种更为完善的hash结构

##### Size 属性

方法：

- Set
- Get
- Delete
- has
- clear

### Promise 对象

Promise 有三种状态：

1. ****Pending（待定）****：初始状态，既不是成功也不是失败。
2. ****Fulfilled（已成功）****：表示操作成功完成。
3. ****Rejected（已失败）****：表示操作失败。

‌[Promise](https://www.baidu.com/s?sa=re_dqa_generate&wd=Promise&rsv_pq=bc40ca850089fbff&oq=promise%E7%BC%BA%E7%82%B9%E5%91%A2&rsv_t=ce2emq0rkb8rRLNcciAetxFNoVM5P1OY90gxsnsN6KilhyJNkB6+xTOJ9sMvMdhKMslw&tn=baiduhome_pg&ie=utf-8"%20\t%20"https://www.baidu.com/_blank)**的主要缺点包括**‌：

1. ‌**链式调用的可读性**‌：虽然Promise通过链式调用提高了代码的可读性，但当链过长时，可能会导致代码难以理解和维护‌12。
2. ‌**无法取消**‌：Promise对象在创建后会立即执行，并且无法中途取消。这意味着如果有一个长时间运行的异步操作，我们无法在需要时停止它‌12。
3. ‌**无法得知当前状态**‌：Promise对象有三种状态：pending(进行中)、fulfilled(成功)和rejected(失败)。然而，一旦Promise的状态从pending变为fulfilled或rejected，我们就无法再获取到其当前的状态或进度。这意味着我们无法得知异步操作何时完成，或者已经完成了多少‌12。
4. ‌**错误处理不够灵活**‌：如果不设置回调函数，Promise内部抛出的错误不会反应到外部。如果忘记添加catch方法，Promise内部的错误可能会被忽略，这可能导致难以调试的问题‌

function timeoout(ms){

return new Promise((resolve,reject) =>{

setTimeout(resolve, ms , "e");

})

}

timeoout(100).then(value =>console.log(value))

then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。

promise resolve调用后，后面的代码还是会会继续执行的!!!!



Promise.prototype.finally()

#### Promise.all

（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。

（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

手写实现  


#### **Promise.race()**

如果参数中某个promise解决或拒绝，返回的 promise就会解决或拒绝。

#### Promise.allSettled()

也就是说当Promise全部处理完成后我们可以拿到每个Promise的状态

#### 写法

New Promise((resolve, reject) => {

setTimeout(() => {}  
, 5000)

})

省略 reject的写法

New Promise(resolve ={  
})

Promise.resolve(promise) 会将 promise 转换为一个 Promise。如果 promise 本身已经是一个 Promise，则直接返回它



### Genertor

Genertor : 函数是 ES6 提供的一种异步编程解决方案。 可以理解为是一个状态机，封装了多个内部状态

执行Geneator函数会返回一个遍历器对象。依次遍历函数内部的每一个状态/。。

特征： function 关键字与函数名之间有个\*， 函数内部使用yield表达式。只有next才会执行下一步  
调用resolve或reject并不会终结 Promise 的参数函数的执行。

- **Generator **函数****：一种可以暂停和恢复执行的函数，使用 function\* 语法声明。
- **yield **表达式****：用于暂停 Generator 函数的执行，并返回一个值。



async/await 是 Generator 的更高层次抽象：async/await 的实现可以基于 Generator 和 Promise 来构建。而 Generator 则需要更多的手动控制  
<br/>

#### Generator 实现async/await



### Async 和 await

- async 函数返回一个 Promise。
- await 表达式会使异步函数暂停执行，直到 Promise 解析完成。

Array.of方法用于将一组值，转换为数组。

console.log(Array.of(1, 2, 3)); // \[1, 2, 3\]

console.log(Array.of('a', 'b', 'c')); // \['a', 'b', 'c'\]

console.log(Array.of(7)); // \[7\]

Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。

### 遍历方法

Map.prototype.keys()

Map.prototype,values()

Map.prototype.entres() 返回所有成员的遍历器

Map结构转为数组结构，较快的方法是使用拓展运算符（…）

const map = new Map(\[

\[1, 'one'\],

\[2, 'two'\],

\[3, 'three'\],

\]);

\[...map.keys()\]

// \[1, 2, 3\]

\[...map.values()\]

// \['one', 'two', 'three'\]

\[...map.entries()\]

// \[\[1,'one'\], \[2, 'two'\], \[3, 'three'\]\]

\[...map\]

// \[\[1,'one'\], \[2, 'two'\], \[3, 'three'\]\]

Foreach 方法，与数组的foreach 类似，

map.forEach(function(value, key, map) {

console.log("Key: %s, Value: %s", key, value);

});

也可以 接受第二个参数，用来绑定this

const reporter = {

report: function(key, value) {

console.log("Key: %s, Value: %s", key, value);

}

};

map.forEach(function(value, key, map) {

this.report(key, value);

}, reporter);

对象转化为 map 和 map转为obj

function objToMap(obj){

let map = new Map();

for(let k in Object.keys(obj)){

map.set(k, obj\[k\])

}

return map

}

function mapToObj(map){

let obj = Object.create(null);

for( let \[k,v\] of map){

obj\[k\] = v;

}

return obj;

}

Promise.prototype.finally()

### Weakmap

只接受对象作为键名

WeakMap 是一个键值对的集合，其中的键必须是对象，而值可以是任意类型。这些键是弱引用的，意味着如果对象没有其他引用，垃圾回收器会自动回收这些对象，即使它们作为 WeakMap 的键存在。

### Weakset

Weakset结构和set结构类似；区别在于

- 1. weakset结构只能是对象。
  2. weakset中的引用都是弱引用；只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。(所以weakset不可以遍历)

### get()

get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。

### set()

set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。

许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。类的修饰，方法的修饰

Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。

### Generator

它们可以暂停和恢复执行，从而实现更复杂的控制流

当 Generator 函数被调用时，它并不会立即执行，而是返回一个迭代器对象。每次调用迭代器对象的 next() 方法时，Generator 函数会从上一次执行的位置继续执行，直到遇到下一个 yield 表达式或函数结束。此时，Generator 函数将返回一个包含当前值和执行状态的对象，其中 value 属性表示 yield 表达式的结果，done 属性表示是否执行完毕。

可以依次遍历 Generator 函数内部的每一个状态

函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因

Yield 关键字来暂停函数的执行，直到外部代码通过 next 方法恢复执行。

function\* helloWorldGenerator() {

yield 'hello';

yield 'world';

return 'ending';

}

var hw = helloWorldGenerator();  
hw.next() // { value: 'hello', done: false }

hw.next() // { value: 'world', done: false }

hw.next() // { value: 'ending', done: true }

hw.next() // { value: undefined, done: true }

async函数是Generator函数的语法糖，将Generator的星号换成async将yield换成await

Generator函数的this返回的总是遍历器对象，而不是this对象。

### Iterator

遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable

let arr = \[1, 2, 3\];

// 自定义数组的 @@iterator 方法

arr\[Symbol.iterator\] = function\* () {

let index = 0;

while (index < this.length) {

yield this\[index++\];

}

};

// 使用 for...of 循环遍历数组

for (let value of arr) {

console.log(value); // 输出 1, 2, 3

}

我们通过调用集合对象上的Symbol.iterator方法获取到该集合对象对应的默认迭代器。



### script标签之type = module





### ES6中Class的基本语法及与ES5中Cass的区别

<https://www.jb51.net/article/199300.htm>

ES6以前的生成实例对象的传统方法是通过构造函数：



上面的例子用ES6改写成如下：



ES5 的构造函数Point，对应 ES6 的Point类的构造方法。

ES6 的类，完全可以看作构造函数的另一种写法：



上面代码说明，类的数据类型就是函数，类本身就指向构造函数。

使用的时候也是直接new一下，和构造函数的用法完全一致：

## .NET

NET Core 是开放源代码通用开发平台

### .NET Framework

（.net的主要实现）. NET Framework 是用于为 Web、Windows、Windows Phone、Windows Server 和 Microsoft Azure 构建应用的开发平台，它包含公共语言运行时 (CLR) 和 .NET Framework 类库

### .Net

NET是一个免费的，跨平台的开源开发人员平台，用于构建许多不同类型的应用程序。

## Webpack

<https://www.jianshu.com/p/42e11515c10f>  
<https://github.com/petehunt/webpack-howto>  
<https://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-12%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD.html>

WebPack是模块化的解决方案：它做的事情是，分析你的项目结构，将一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。大部分的时候能替换gulp  
<br/>“webpack打包原理是根据文件间的依赖关系对其进行静态分析，将这些模块按指定规则生成静态资源，当webpack处理程序时，它会递归地构建一个依赖关系图，将所有这些模块打包成一个或多个bundle。”

<https://segmentfault.com/q/1010000015200625>

**Core concepts:**

### Entry

指示 webpack 应该使用哪个模块，来作为构建其内部_依赖图_的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

module.exports = {

entry: './path/to/my/entry/file.js'

};

Vendor: 就需要将vendor中的代码抽离出来。

### Output

告诉 webpack 在哪里输出它所创建的 _bundles_，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：const path = require('path');

module.exports = {

entry: './path/to/my/entry/file.js',

output: {

path: path.resolve(\__dirname, 'dist'),

filename: 'my-first-webpack.bundle.js'

}

};

### Loaders

让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效[模块](https://www.webpackjs.com/concepts/modules)，然后你就可以利用 webpack 的打包能力，对它们进行处理。更高层面，在 webpack 的配置中 **loader** 有两个目标：

1. test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。
2. use 属性，表示进行转换时，应该使用哪个 loader。

const path = require('path');

1. module.exports = {
2. output: {
3. filename: 'my-first-webpack.bundle.js'
4. },
5. module: {
6. rules: \[
7. { test: /\\.txt$/, use: 'raw-loader' }
8. \]
9. }
10. };

需要格外注意到loader顺序，是先写style-loader，再写css-loader,但是执行的时候是先加载css-loader，将css解析好后再将css传递给style-loader；

### Plugins loader

Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：

test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）

loader：loader的名称（必须）

include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；

query：为loaders提供额外的设置选项（可选）

resolve: <https://segmentfault.com/a/1190000013176083?utm_source=tag-newest>.

被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。[插件接口](https://www.webpackjs.com/api/plugins)功能极其强大，可以用来处理各种各样的任务。

const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm

const webpack = require('webpack'); //to access built-in plugins

module.exports = {

module: {

rules: \[

{ test: /\\.txt$/, use: 'raw-loader' }

\]

},

plugins: \[

new HtmlWebpackPlugin({template: './src/index.html'})

\]

};

- **Loader**在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）
- **Plugin**在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。

。runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。

### 生成Source Maps（使调试更容易）

### 使用webpack构建本地服务器

### 如何提高webpack构建速度

#### **优化 Loader 配置**

- ****缓存 Loader 输出****：使用 .cacheDirectory 选项来启用 loader 的缓存机制。这可以在增量构建时显著加快速度。
- ****并发执行 Loader****：使用 Webpack 5 的 threading 插件来利用多核 CPU 并行处理 loader 任务。
- ****减少 Loader 数量****：尽量减少 loader 的数量和复杂度，因为每一个 loader 都会增加构建时间。

####  **优化输入输出**

- ****多入口****：如果你的应用有多个入口文件，可以考虑将它们分别打包成不同的 chunks，这有助于并行构建。
- ****减少输入文件****：确保只导入真正需要的模块，避免不必要的导入。
- ****外部化某些依赖****：使用 externals 配置来排除那些已经通过全局变量提供的库，这样它们就不会被包含在你的 bundle 中。

#### **2\. 使用高效的插件**

- - 1. 多入口的情况下使用SplitChunksPlugin 提取公共代码
        2.  通过externals配置构建过程中排除某些模块
        3.  利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。
        4.  使用Happypack 实现多线程加速编译
        5.  使用TerserPlugin来提升压缩速度(Terser 是一个功能强大的 JavaScript 压缩器，可以移除无用的空白、注释，并进行代码优化)。

#### **Tree-shaking**

Tree-shaking 是一种基于 ES Module (ESM) 规范的 Dead Code Elimination 技术1

。它通过静态分析模块之间的导入导出关系，识别并移除那些从未被引用过的代码（即死代码），以此来优化打包后的代码体积。

##### **启用条件**

为了在 Webpack 中启用 Tree-shaking 功能，必须满足以下三个条件：

1. 使用 ESM 规范编写模块代码。
2. 配置 optimization.usedExports 为 true，以启动标记功能。
3. 启动代码优化功能，例如配置 mode: "production" 或者设置 optimization.minimize: true1

##### **工作流程**

Webpack 在 Make 阶段收集模块导出变量并记录到模块依赖关系图 ModuleGraph 中；Seal 阶段遍历 ModuleGraph 标记哪些模块导出变量未被使用；最后，在生成产物时，如果变量没有被其他模块使用，则删除对应的导出语句1

。此外，对于 CSS 文件的 Tree-shaking，需要配合 MiniCssExtractPlugin 插件一起使8

#### **TerserPlugin**

TerserPlugin 是 Webpack 内置的一个插件，它使用 Terser 库来进行 JavaScript 代码的压缩

。当 Webpack 处于 production 模式时，默认会开启此插件进行代码压缩

##### **主要功能**

- ****压缩****：移除不必要的字符，如空格、换行符等，以减小文件大小。
- ****丑化****：重命名变量和函数名称为更短的形式，进一步缩小文件尺寸。
- ****删除未使用的代码****：结合 Tree-shaking 结果，彻底移除那些已经标记为无用的代码片段



- - 1. 使用Tree-shaking和Scope Hoisting来剔除多余代码

### Manifest

\* manifest, 管理模块之间的交互

\* - 当 compiler 开始执行、解析和映射应用程序时, 会保留所有模块的详细要点, 这个数据集合称为 manifest。

\* - 当完成打包并发送到浏览器时, 会在运行时通过 manifest 来解析和加载模块

\* - 通过使用 manifest 中的数据, runtime 能够查询模块标识符, 检索出背后对应的模块

runtime包含：在模块交互时，连接模块所需的加载和解析逻辑，包括浏览器中已加载模块的连接以及懒加载模块的执行连接。

1. 应用程序代码要求 HMR runtime 检查更新。
2. HMR runtime（异步）下载更新，然后通知应用程序代码。
3. 应用程序代码要求 HMR runtime 应用更新。
4. HMR runtime（异步）应用更新。

你可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。

1. 更新后的 [manifest](https://www.webpackjs.com/concepts/manifest)(JSON)
2. 一个或多个更新后的 chunk (JavaScript)

manifest 包括新的编译 hash 和所有的待更新 chunk 目录。每个更新 chunk 都含有对应于此 chunk 的全部更新模块（或一个 flag 用于表明此模块要被移除）的代码。

编译器确保模块 ID 和 chunk ID 在这些构建之间保持一致。通常将这些 ID 存储在内存中（例如，使用 [webpack-dev-server](https://www.webpackjs.com/configuration/dev-server/) 时），但是也可能将它们存储在一个 JSON 文件中。

#### 在 HMR Runtime 中

这些事情比较有技术性……如果你对其内部不感兴趣，可以随时跳到 [HMR API 页面](https://www.webpackjs.com/api/hot-module-replacement)或 [HMR 指南](https://www.webpackjs.com/guides/hot-module-replacement)。

对于模块系统的 runtime，附加的代码被发送到 parents 和 children 跟踪模块。在管理方面，runtime 支持两个方法 check 和 apply。

check 发送 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，待更新 chunk 会和当前加载过的 chunk 进行比较。对每个加载过的 chunk，会下载相对应的待更新 chunk。当所有待更新 chunk 完成下载，就会准备切换到 ready 状态。

apply 方法将所有被更新模块标记为无效。对于每个无效模块，都需要在模块中有一个更新处理函数，或者在它的父级模块们中有更新处理函数。否则，无效标记冒泡，并也使父级无效。每个冒泡继续直到到达应用程序入口起点，或者到达带有更新处理函数的模块（以最先到达为准）。如果它从入口起点开始冒泡，则此过程失败。

之后，所有无效模块都被（通过 dispose 处理函数）处理和解除加载。然后更新当前 hash，并且调用所有 "accept" 处理函数。runtime 切换回闲置状态，一切照常继续。

##### 模块热替换 hot module replacement

<https://www.jianshu.com/p/db9c035eafb1>  
如果已经通过 [HotModuleReplacementPlugin](https://www.webpackjs.com/plugins/hot-module-replacement-plugin) 启用了[模块热替换(Hot Module Replacement)](https://www.webpackjs.com/concepts/hot-module-replacement)，则它的接口将被暴露在 [module.hot 属性](https://www.webpackjs.com/api/module-variables"%20\l%20"module-hot-webpack-specific-)下面。通常，用户先要检查这个接口是否可访问，然后再开始使用它。举个例子，你可以这样 accept 一个更新的模块

if (module.hot) {

module.hot.accept('./library.js', function() {

// 使用更新过的 library 模块执行某些操作...

})

}

### webpack多个入口

#### **多页面应用（Multi-Page Application）**

在构建多页面应用（Multi-Page Application, MPA）时。通过配置多个入口点，Webpack 可以生成多个输出文件，每个文件对应一个页面或一个功能模块。这样可以确保每个页面只加载必要的代码，提高加载速度和性能。



#### **2\. 代码分割（Code Splitting）**

代码分割是指将代码分成多个小块，以便按需加载，从而提高应用的初始加载速度。Webpack 提供了多种代码分割的方法，包括动态导入（import()）和多入口点。

#### **4\. 公共代码提取（Commons Chunk）**

在多个入口点的情况下，可以提取公共代码到一个单独的文件中，以减少重复代码的体积。

### Webpack 代码分割

optimization.splitChunks 配置可以自动进行代码分割

#### 动态导入 import() 语法可以按需加载模块



#### 多入口点（Multiple Entry Points）

#### optimization.splitChunks 配置可以自动进行代码分割

### 怎么实现怎么实现webpack插件

#### **1：创建插件文件**

#### **2：定义插件类**

在 MyPlugin.js 文件中，定义一个类来实现你的插件。这个类需要有一个 apply 方法，该方法接收一个 compiler 对象，你可以通过这个对象来监听 Webpack 的生命周期事件。



定义插件类：

constructor(options)：构造函数用于接收插件的配置选项。

apply(compiler)：这是插件的核心方法，接收一个 compiler 对象。compiler 对象提供了访问 Webpack 生命周期事件的方法。

监听生命周期事件：

compiler.hooks.compile.tap('MyPlugin', (params) => { ... })：监听 compile 事件，在编译开始时执行自定义逻辑。

compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => { ... })：监听 emit 事件，在生成输出文件之前执行自定义逻辑。注意，tapAsync 方法需要在完成任务后调用回调函数 callback。

修改输出文件：

在 emit 事件的回调函数中，你可以修改或添加输出文件。通过 compilation.assets 对象，你可以访问和修改输出文件。

在 Webpack 配置中使用插件：

在 webpack.config.js 文件中，引入你创建的插件，并在 plugins 数组中实例化它，传入所需的配置选项。

### DLL (Dynamic Link Library)

动态链接库文件，又称”应用程序拓展”，许多应用程序并不是一个完整的可执行文件，他被分割成一些相对独立的动态链接库

程序集是应用程序的部署单元。.NET应用程序包含一个或多个程序集。通常扩展名是EXE或DLL 的.NET可执行程序称为程序集。.NET程序集包含元数据,这些元数据描述了程序集中定义的所有类型及其成员的信息,即方法、属性、事件和字段。

## C\#

<https://dandelioncloud.cn/article/details/1438700787122900994>

CLR([公共语言运行库](https://www.baidu.com/s?wd=%E5%85%AC%E5%85%B1%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E5%BA%93&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao"%20\t%20"_blank)) common language runtime:能管理内存，能够轻松地设计其对象可以跨语言互动的组件和应用程序，编译一次，并可以在任何支持运行库的CPU和[操作系统](https://www.baidu.com/s?wd=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao"%20\t%20"_blank)上运行，跨语言集成（特别是跨语言继承）JIT编译器(just in time)

IL([中间语言](https://www.baidu.com/s?wd=%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao"%20\t%20"_blank)) intermediate language:可用于语言互操作性，IL不是字节代码，但很接近字节代码，因此执行应用程序时，IL到机器代码的转换要快很多。独立于CPU的指令集。由CLR转换为特定于CPU的代码。

编译器将IL和元数据转换为CLR =》 机器代码=》然后代码执行，

.net被运行两次，第一次较慢

.Net Framework 两个主要组件

- - - 1. 通用语言运行时（clr）
            2.  统一的类库集

.Net 的类库：

1. 线程
2. 文件输入输出（I/0）
3. 数据库支持
4. XML解析
5. 数据结构

### 数据类型

#### 引用类型

类： 对象类，数组类，字符串类等，

接口

#### 值类型

基本类型：数值类型和布尔类型，数值类型又细分为：整数类型，字符类型，浮点数类型和十进制类型。

结构类型

枚举类型

#### 指针类型

结构类型和类最根本的区别是结构是值类型，类是引用类型。结构不能从另外结构和类派生，也不能被继承，因此不能定义抽象结构，但是能继承接口

#### 类型转换

隐式转换：隐式转换就是默认的，不需要加声明就可以进行的转换，比如 int i = 10

显式转换：强制类型转换。需要明确的指定转换类型。可能会导致信息丢失。

加框：将值类型变量转换成对象类型

消框：将对象类型转换为值类型

装箱是将值类型转换为引用类型

#### New 运算符

New操作符可以创建值类型变量。引用类型对象。同时自动调用构造函数。

Int x = new int()//用new 创建整型变量x，调用默认构造函数

Person c1= new Person()//用new 建立的Person 类对象 person变量C对象的引用。

Int \[\] arr = new int\[2\] //数组也是类，创建数组类对象，arr是数组对象的引用。

CLS common language specification

CTS common Type System

使用命名空间 using 类似于#include

C#的预处理器指令

预处理器指令是C#编译器在词法分析阶段读取的语句。这些语句可以指示编译器包含或者不包含某些代码，预处理器由#标识，并且字符#必须是改行的第一个非空字符。常见的三个用途是完成条件编译，增加诊断来报告错误和警告。定义代码域。

Define #undef用于定义一个符号，后取消对一个符号得定义。如果定义了一个符号，那么在#if指令中使用时这个符号计算为true.

line 改变行号序列，并且可以识别改行的源文件。

region #endregion 用于指定一个代码块。vs.net可以展开或折叠这个代码块

error 导致编译器报告一个致命错误

warming 导致编译器报告一个警告，并继续处理。

类成员的访问性：

Protected 访问仅限于包含类或从包含类派生的类型

Internal 访问仅限于当前程序集

Protected internal 访问仅限于从包含类派生的当前程序集或类型

类或结构的默认访问类型时internal

类中所有成员默认访问类型是private

构造函数：

构造函数是一种用于对象初始化的特殊方法，有以下特点。

构造上述只能在对象创建时调用，即和new运算符一起被调用。

构造函数和类具有相同的名字。

构造函数没有返回值。

每个类可以有多个构造函数。至少一个。

如果没有为类定义构造函数，系统会自动为其定义一个缺省的构造函数。作用是将是将变量都清零。

C#中构造函数有三种：实例构造，私有构造和静态构造。

构造函数可以通过关键字this调用同一个类的另一个构造函数，例如

Public point() : this(0,20)

{}



#### Base用法

base关键字用于从派生类中访问基类的成员；  
\* 指定创建派生类实例时调用基类构造函数；  
\* 调用基类上已被重写的方法  
\* 注意：不能从静态方法中使用base关键字，base关键字只能在实例构造函数、实例方法或实例访问器中使用

#### 类访问修饰符

#### Private

私有成员，只能被类内部的函数使用和修改

##### Protected

##### Public

##### Internal

：声明内部成员，内部成员只能在同一程序集中

用const修饰符声明的字段为常量，常量只能在声明中初始化，以后不能再修改

##### 抽象类

抽象类表示一种抽象的概念，只是希望以它为基类的派生类有共同的函数成员和数据成员

1.抽象类只能作为其它类的基类，它不能直接被实例化。

2.抽象类允许包含抽象成员，虽然这不是必须的。抽象成员用abstract修饰符修饰。

3.抽象类不能同时又是密封的。

4.抽象类的基类可以是抽象类。如果一个非抽象类的基类时抽象类，则该类必须通过override 来实现所有继承而来的抽象方法，

##### **Virtual**

关键字用于修饰方法、属性、索引器或事件声明，并使它们可以在派生类中被重写。

#####   

密封类

不希望类被继承，或者已有的类没有被继承的必要 sealed class.密封类不能同时被继承。抽象类总是希望被继承。

##### 接口

接口可以定义一个或多个方法，属性，索引指示器和事件。但是与类不同的时 接口仅仅时他们的声明 而不提供实现。因此接口时函数成员声明的集合。C#不支持多继承，因此如果某个类需要继承多个类的行为时，只能使用多个接口加以说明

##### 静态方法

用修饰符static 声明,不管类生成或未生成对象，类的静态方法都可以被使用，静态方法只能使用静态方法所在类的静态数据和静态方法。 这是因为使用静态方法时，该静态方法所在类可能还没有对象，即使有对象，由于用类名.静态方法名方式调用静态方法，静态方法没有this指针来存放对象的地址，无法判定应访问哪个对象的数据成员。在类创建对象后，实例方法才能被使用

私有构造函数

在某些特殊的情况下，使用私有构造函数能够达到意想不到的效果。比如想建立这样一个类： 不允许被其他类实例化，但是提供对外的静态接口成员。如System.Math不能实例化，所有成员都是静态的



系统的资源分为托管资源和非托管资源。

如简单的int，string,float,DateTime等等是不需要人工干预回收的

。net中超过80%的资源都是托管资源。

通过构析函数可以自动生成Finalize()方法和对基类Finalize方法的调用。

析构函数的名字由符号“～”加类名组成

Public class chair //如果既编写够细函数又编写Finalize方法，编译器出错

{

Public Chair(){…}

~Chair() {…}

Void Finalize(){….}

}

非托管资源： dispose方法

需要显示调用或者using语句，调用时机是在显示调用或者离开using程序块时

一般不要提供构析函数，因为不能及时的执行。

实现dispose方法的时候，一定要加上GC.SuppressFinalize(this)语句。



类变量是在所有类的实例（对象）中共享的变量，在变量声明中用static关键字表示。

类方法只能访问静态变量，访问非静态变量的尝试会引起编译错误。

静态方法不能被覆盖成非静态的。

Main是静态的，因为它必须在实例化前被访问

静态构造函数既没有访问修饰符，也没有参数

无法调用静态构造函数。

在程序中，用户无法控制何时执行静态构造函数。

典型用途是：当类使用日志文件时，将使用这种构造函数向日志文件中写如项

方法重载：

方法名相同，方法的参数列表不同：参数的个数，参数的数据类型

**参数传递**

1值传递： 方法中的变量是传入变量的一个拷贝，方法中对形参做修改，不会影响方法外面的实参

1. 对于值类型的数据，值传递就是传递了变量的值
2. 对于引用类型数据，值传递的是引用的值，即方法中形参和方法外的实参将指向同一对象，因此 通过形参也能修改对象的实际内容

2地址传递： 方法中变量是传入变量的一个引用，方法中对形参做的修改，也会影响方法外面的实参

1. Ref:由调用方法初始化参数值。
2. Out 由调用方法初始化参数值，可以不用初始化就作为参数传递给方法。





**属性成员**

**：主要用于描述和维护对象的状态**

创建一个属性包括两步：

声明一个字段来存储属性值

编写一个属性声明，提供访问接口

属性的建立要使用属性声明，语法如下

【访问修饰符】类型名属性名

{get

{return 字段；}

Set{私有字段 = value}

}



属性说明：

可以创建只读或只写属性。即只有get 或set 方法。

可以创建静态属性，用static关键字

静态属性不与特定实例有关联，因此在静态属性的get和set方法内引用this是错误的

静态属性使用类名访问，并且与静态属性相配合的私有字段应该也是静态的



静态函数没有this关键字

可将对象作为参数传递到其他方法

**索引器**

参数化成员属性 包括set，get 方法

与成员属性不同：可以接受多个参数 使用this 作为索引器的名字

语法：

\[访问修饰符\] 数据类型 this\[数据类型 标识符\]

{

Get{}

Set{}

}

Public p hoto this\[int index\]

{

Get

{

Return photos\[index\]

}

Set

{

photos\[index\] = value

}

}

**Is运算符**

检查对象与类之间的关系 当obj为classname类或其子类的对象时，运算符返回true;

**As运算符**

先用is检查，再执行对象类型转换。

构造函数必须带参数，且必须对字段进行赋值

**结构：**

结构时一种用struct声明的自定义数据类型。它和类相似，可以包含构造函数，字段，属性，方法等。

一般结构只是一些数据，需要定义方法，将它定义成类。

结构不支持继承，但可以继承接口。



##### 事件

定义事件

为对象订阅该事件

将发送的事件通知给订阅人

定义事件

: 访问修饰符 event委托名 事件名

Public delegate void delegateMe()

Private event delegateMe eventMe;







事件订阅对象

eventMe += new delegateMe(objA.Method);

去掉事件

eventMe -= new delegateMe(objA.Method);

通知订阅对象

If(condition)

{

eventMe()

调用订阅特定事件的对象的所有委托  
}

GetHashCode方法为对象生成一个Int32类型的散列码。.net要求两个相同的对象必须有相同的散列码。Euals方法必须和GetHashCode方法成对出现

克隆来创建对象副本

Object 中的MemberwiseClone():默认返回对象的一个副本，是一种浅拷贝

可以实现自己的克隆方法进行深拷贝

不能克隆基本类型。可克隆的类必须实现Icloneabke接口

Public interface Icloneanle

Public interface Icloneable

{

Object Clone();

}

##### 序列化

序列化是将对象的状态存储到特定介质的过程

1.描述性关键字

2.对程序中的元素：类，字段，方法，属性。

3.命名时以Attribute结尾：SerializableAttribute 使用时省略Attribute

\[Serializable\]

Abstract class FeedBase

Public sealed class SerializableAttribute





反射

可以ILDasm反编译工具浏览一个dll和exe的构成

##### 设计模式

模式是得到很好研究的范例

设计模式是软件开发过程中经验的积累

定义一个创建对象的接口，让子类决定实例化哪一个工厂类，

####### 简单工厂模式da担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象。往往由一个具体的类实现



抽象产品角色：担任这个角色的类是由工厂方法模式所创建的对象的父类。或她们共同拥有的接口，一般由接口或抽象类实现

具体产品角色：工厂方法模式所创建的任何对象都是这个角色实例，有具体类实现

####### 设计模式的意义

- 1. 提高软件的可复用性
  2. 灵活，适应软件设计的变化
  3. 面向对象在实际应用中的集中体现



####### 抽象工厂设计模式

抽象工厂角色：担任这个角色的是工厂方法模式的核心，它是与应用系统的商业逻辑无关的，通常使用接口或抽象类实现

具体工厂角色：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适产品对象的逻辑，与应用系统的商业逻辑紧密相关的，通常使用具体的类实现

抽象产品角色：担任这个角色的类是抽象工厂方法模式所创建的对象父类。或它们共同拥有的接口。通常使用接口或抽象类实现这一角色

具体产品角色：抽象工厂模式所创建的任何产品对象都是某一具体产品类的实例。这是客户端最终需要的东西。通常使用具体类实现这个角色。



### 优化，压缩，缓存以及分离CSS和JS

##### HashTable类

哈希表（HasTable）

由一对（key,value）类型元素组成集合

Add(key，value)



##### Stream类

是派生出各种类的抽象类 处理字节流

其中的一些派生类包括

FileStream

MemoryStream

BuffredStream

CryptoStream

**FileStream类构造函数**

FileStream(stream FilePath, FileMode)

FileStream(stream FilePath, FileMode,FileAccess)

FileStream(stream FilePath, FileMode)

**与FileStram类一起使用的枚举数**

FileMode 枚举数

:Append, Create, CreateNew, Poen,OpenOrCreate,Trucate

FileAccess枚举数

:Read, Write,ReadWrite

FileShare枚举数

:None,Read,Write,ReadWrite

可以用filestream来读写文本文件，但是fileStream是用过字节形式来读写数据的，要把字节数据转换为文本要自己处理编码转换。

对于文本文件的读写，通常用stramReader类和StreamWriter类更方便。其底层是通过fileStream实现读写文本文件的

###### 读取文本文件

构造函数

Public streamReader(string path, Encoding encoding)

其中path制定要读取的完整文件路径encoding制定要使用的字节编码。例如GB2312，UTF8等

###### 写入文本

Public streamWriter(string path,bool append,Encoding encoding)

其中path制定要写入的完整路径，append为false则该文件被改写，如果该文件存在，并且append为true.则数据被追加到该文件中。否则创建新文件。

#### API

写接口的时候需要考虑到UI层和数据库层

#### 控制序列化

使用可控制 JSON 序列化程序的工作方式的_特性_对 repo 类型添加批注。 在此示例中，将使用这些特性来定义 JSON 键名和 C## 类名及成员名称之间的映射。 使用 DataContract 和 DataMember 这两个特性。 按照约定，所有特性类均以后缀 Attribute 结尾。 不过，在应用特性时无需使用此后缀。

将特性的 Name 属性设置为映射到此类型的 JSON 节点的名称：\[DataContract(Name="repo")\]

public class Repository

#### 命名空间

[System.Runtime.Serialization](https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.serialization)

using System.Net.Http;

using System.Net.Http.Headers;

using System.Collections.Generic;

using System.Runtime.Serialization.Json;

using System.Globalization;

## Webpack 配置

Webpack 的配置主要为了这几大项目：

- entry：js 入口源文件
- output：生成文件
- module：进行字符串的处理
- resolve：文件路径的指向
- plugins：插件，比 loader 更强大，能使用更多 webpack 的 api

“\__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。

const path = require('path');

const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {

&nbsp;   mode: 'development',

&nbsp;   entry: path.join(\__dirname, './src/index'),

&nbsp;   output: {

&nbsp;       filename: '\[hash\].bundle.js',

&nbsp;       path: path.resolve(\__dirname, './dist')

&nbsp;   },

&nbsp;   module: {

&nbsp;       rules: \[{

&nbsp;               test: /\\.tsx$/,

&nbsp;               loader: 'babel-loader',

&nbsp;               exclude: /node_modules/,

&nbsp;               query: {

&nbsp;                   presets: \['es2015', 'react'\]

&nbsp;               }

&nbsp;           },

&nbsp;           {

&nbsp;               test: /\\.\[(png)|(obj)|(json)\]$/,

&nbsp;               loader: "file-loader"

&nbsp;           },

&nbsp;           //样式加载 css

&nbsp;           {

&nbsp;               test: /\\.css$/,

&nbsp;               use: \['style-loader', 'css-loader'\]

&nbsp;           },

&nbsp;           //解析url

&nbsp;           {

&nbsp;               test: /\\.(woff|woff2|jpg|png)$/,

&nbsp;               use: {

&nbsp;                   loader: 'url-loader',

&nbsp;                   options: {

&nbsp;                       name: 'imanges/\[hash\].\[ext\]',

&nbsp;                       limit: 5000,

&nbsp;                       mimetype: 'application/font-woff'

&nbsp;                   }

&nbsp;               },

&nbsp;           },

&nbsp;           {

&nbsp;               test: /\\.less$/,

&nbsp;               use: \[{

&nbsp;                       loader: "style-loader"

&nbsp;                   },

&nbsp;                   { loader: 'css-loader', options: { sourceMap: false } },

&nbsp;                   {

&nbsp;                       loader: "less-loader",

&nbsp;                       options: {

&nbsp;                           strictMath: true,

&nbsp;                           noIeCompat: true

&nbsp;                       }

&nbsp;                   }

&nbsp;               \]

&nbsp;           },

&nbsp;       \]

&nbsp;   },

&nbsp;   resolve: {

&nbsp;       //下面后缀的文件导入时可以省略文件名，js必须要有，否则会react.js文件会无法被解析

&nbsp;       extensions: \[".ts", ".tsx", ".js"\]

&nbsp;   },

&nbsp;   devtool: 'source-map',

&nbsp;   devServer: {

&nbsp;       //告诉服务器从哪个目录中提供内容。只有在你想要提供静态文件时才需要

&nbsp;       contentBase: path.resolve(\__dirname, "dist"),

&nbsp;       compress: true, //是否压缩

&nbsp;       port: 8080, //端口号

&nbsp;       host: '0.0.0.0', //外部服务器可以访问

&nbsp;       open: true //是否运行时打开浏览器

&nbsp;   },

&nbsp;   plugins: \[

&nbsp;       //该插件将为你生成一个HTML5文件，其中包括使用script标签的body中的所有webpack包

&nbsp;       new HtmlWebpackPlugin({ template: \__dirname + '/index.html' }),

&nbsp;   \]

}

### 配置

const webpack = require("webpack");

// 引入webpack插件 生成index.html文件

const HtmlWebpackPlugin = require("html-webpack-plugin");

const path = require("path")

// 把模块导出

module.exports = {

// 以前是jsx，因为我们用typescript写，所以这里后缀是tsx

entry:"./src/index.tsx",

// 指定模式为开发模式

mode:"development",

// 输出配置

output:{

// 输出目录为当前目录下的dist目录

path:path.resolve(\__dirname,'dist'),

// 输出文件名

filename:"index.js"

},

// 为了方便调试，还要配置一下调试工具

devtool:"source-map",

// 解析路径，查找模块的时候使用

resolve:{

// 一般写模块不会写后缀，在这里配置好相应的后缀，那么当我们不写后缀时，会按照这个后缀优先查找

extensions:\[".ts",'.tsx','.js','.json'\]

},

// 解析处理模块的转化

module:{

// 遵循的规则

rules:\[

{

// 如果这个模块是.ts或者.tsx，则会使用ts-loader把代码转成es5

test:/\\.tsx?$/,

loader:"ts-loader"

},

{

// 使用sourcemap调试

// enforce:pre表示这个loader要在别的loader执行前执行

enforce:"pre",

test:/\\.js$/,

loader:"source-map-loader"

}

\]

},

// 插件的配置

plugins:\[

// 这个插件是生成index.html

new HtmlWebpackPlugin({

// 以哪个文件为模板，模板路径

template:"./src/index.html",

// 编译后的文件名

filename:"index.html"

}),

new webpack.HotModuleReplacementPlugin()

\],

// 开发环境服务配置

devServer:{

// 启动热更新,当模块、组件有变化，不会刷新整个页面，而是局部刷新

// 需要和插件webpack.HotModuleReplacementPlugin配合使用

hot:true,

// 静态资源目录

contentBase:path.resolve(\__dirname,'dist')

}

}

## Gulp

<https://www.cnblogs.com/2050/p/4198792.html>

Gulp是通过task对整个开发过程进行构建。

### **gulp.src()**

方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息

gulp.src(globs\[, options\])

**globs**参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。

**options**为可选参数。通常情况下我们不需要用到。

Gulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：

\* 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾

\*\* 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。

? 匹配文件路径中的一个字符(不会匹配路径分隔符)

\[...\] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法

!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的

?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)?

+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+

\*(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)\*

@(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern)

下面以一系列例子来加深理解

\* 能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js

\*.\* 能匹配 a.js,style.css,a.b,x.y

\*/\*/\*.js 能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js

\*\* 能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,能用来匹配所有的目录和文件

\*\*/\*.js 能匹配 foo.js,a/foo.js,a/b/foo.js,a/b/c/foo.js

a/\*\*/z 能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/z

a/\*\*b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单\*\*单独出现才能匹配多级目录

?.js 能匹配 a.js,b.js,c.js

a?? 能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符

\[xyz\].js 只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符

\[^xyz\].js 能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js

使用数组的方式来匹配多种文件 gulp.src(\['js/\*.js','css/\*.css','\*.html'\])

使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上!即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式

gulp.src(\[\*.js,'!b\*.js'\]) //匹配所有js文件，但排除掉以b开头的js文件

gulp.src(\['!b\*.js',\*.js\]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中

#### gulp.dest()

gulp.dest()方法是用来写文件的，其语法为：

gulp.dest(path\[,options\])

**path**为写入文件的路径  
**options**为一个可选的参数对象，通常我们不需要用到

要想使用好gulp.dest()这个方法，就要理解给它传入的路径参数与最终生成的文件的关系。  
gulp的使用流程一般是这样子的：首先通过gulp.src()方法获取到我们想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到gulp.dest()中，gulp.dest()方法则把流中的内容写入到文件中，这里首先需要弄清楚的一点是，我们给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以**生成的文件名是由导入到它的文件流决定的**，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当做是目录名，例如：

var gulp = require('gulp');

gulp.src('script/jquery.js')

.pipe(gulp.dest('dist/foo.js'));

//最终生成的文件路径为 dist/foo.js/jquery.js,而不是dist/foo.js

下面说说生成的文件路径与我们给gulp.dest()方法传入的路径参数之间的关系。  
gulp.dest(path)生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径。例如：

var gulp = reruire('gulp');

//有通配符开始出现的那部分路径为 \*\*/\*.js

gulp.src('script/\*\*/\*.js')

.pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/\*\*/\*.js

//如果 \*\*/\*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js

再举更多一点的例子

gulp.src('script/avalon/avalon.js') //没有通配符出现的情况

.pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/avalon.js

//有通配符开始出现的那部分路径为 \*\*/underscore.js

gulp.src('script/\*\*/underscore.js')

//假设匹配到的文件为script/util/underscore.js

.pipe(gulp.dest('dist')); //则最后生成的文件路径为 dist/util/underscore.js

gulp.src('script/\*') //有通配符出现的那部分路径为 \*

//假设匹配到的文件为script/zepto.js

.pipe(gulp.dest('dist')); //则最后生成的文件路径为 dist/zepto.js

通过指定gulp.src()方法配置参数中的base属性，我们可以更灵活的来改变gulp.dest()生成的文件路径。  
当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如：

gulp.src('app/src/\*\*/\*.css') //此时base的值为 app/src

上面我们说的gulp.dest()所生成的文件路径的规则，其实也可以理解成，用我们给gulp.dest()传入的路径替换掉gulp.src()中的base路径，最终得到生成文件的路径。

gulp.src('app/src/\*\*/\*.css') //此时base的值为app/src,也就是说它的base路径为app/src

//设该模式匹配到了文件 app/src/css/normal.css

.pipe(gulp.dest('dist')) //用dist替换掉base路径，最终得到 dist/css/normal.css

所以改变base路径后，gulp.dest()生成的文件路径也会改变

gulp.src(script/lib/\*.js) //没有配置base参数，此时默认的base路径为script/lib

//假设匹配到的文件为script/lib/jquery.js

.pipe(gulp.dest('build')) //生成的文件路径为 build/jquery.js

gulp.src(script/lib/\*.js, {base:'script'}) //配置了base参数，此时base路径为script

//假设匹配到的文件为script/lib/jquery.js

.pipe(gulp.dest('build')) //此时生成的文件路径为 build/lib/jquery.js

用gulp.dest()把文件流写入文件后，文件流仍然可以继续使用。

#### gulp.task()

gulp.task方法用来定义任务，内部使用的是[Orchestrator](https://github.com/robrich/orchestrator)，其语法为：

gulp.task(name\[, deps\], fn)

**name** 为任务名  
**deps** 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数  
**fn** 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。

gulp.task('mytask', \['array', 'of', 'task', 'names'\], function() { //定义一个有依赖的任务

// Do something

});

gulp.task()这个API没什么好讲的，但需要知道执行多个任务时怎么来控制任务执行的顺序。  
gulp中执行多个任务，可以通过任务依赖来实现。例如我想要执行one,two,three这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：

如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。  
但是如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：

gulp.task('one',function(){

//one是一个异步执行的任务

setTimeout(function(){

console.log('one is done')

},5000);

});

//two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行

gulp.task('two',\['one'\],function(){

console.log('two is done');

});

上面的例子中我们执行two任务时，会先执行one任务，但不会去等待one任务中的异步操作完成后再执行two任务，而是紧接着执行two任务。所以two任务会在one任务中的异步操作完成之前就执行了。

gulp.task('one',function(cb){ //cb为任务函数提供的回调，用来通知任务已经完成

//one是一个异步执行的任务

setTimeout(function(){

console.log('one is done');

cb(); //执行回调，表示这个异步任务已经完成

},5000);

});

//这时two任务会在one任务中的异步操作完成后再执行

gulp.task('two',\['one'\],function(){

console.log('two is done');

});

第二：定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况。

gulp.task('one',function(cb){

var stream = gulp.src('client/\*\*/\*.js')

.pipe(dosomething()) //dosomething()中有某些异步操作

.pipe(gulp.dest('build'));

return stream;

});

gulp.task('two',\['one'\],function(){

console.log('two is done');

});

第三：返回一个promise对象，例如

var Q = require('q'); //一个著名的异步处理的库 <https://github.com/kriskowal/q>

gulp.task('one',function(cb){

var deferred = Q.defer();

// 做一些异步操作

setTimeout(function() {

deferred.resolve();

}, 5000);

return deferred.promise;

});

gulp.task('two',\['one'\],function(){

console.log('two is done');

});

#### gulp.watch()

gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为

gulp.watch(glob\[, opts\], tasks)

**glob** 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。  
**opts** 为一个可选的配置对象，通常不需要用到  
**tasks** 为文件变化后要执行的任务，为一个数组

gulp.task('uglify',function(){

//do something

});

gulp.task('reload',function(){

//do something

});

gulp.watch('js/\*\*/\*.js', \['uglify','reload'\]);

gulp.watch()还有另外一种使用方式：

gulp.watch(glob\[, opts, cb\])

**glob**和**opts**参数与第一种用法相同  
**cb**参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径

gulp.watch('js/\*\*/\*.js', function(event){

console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变

console.log(event.path); //变化的文件的路径

});

Del: 删除文件

#### 4.10 自动刷新

使用[gulp-livereload](https://github.com/vohof/gulp-livereload)插件，安装:npm install --save-dev gulp-livereload。  
当代码变化时，它可以帮我们自动刷新页面  
该插件最好配合谷歌浏览器来使用，且要安装[livereload chrome extension](https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei)扩展插件,不能下载的请自行FQ。

var gulp = require('gulp'),

less = require('gulp-less'),

livereload = require('gulp-livereload');

gulp.task('less', function() {

gulp.src('less/\*.less')

.pipe(less())

.pipe(gulp.dest('css'))

.pipe(livereload());

});

gulp.task('watch', function() {

livereload.listen(); //要在这里调用listen()方法

gulp.watch('less/\*.less', \['less'\]);

});

const { watch, series } = require('gulp');

function clean(cb) {

// body omitted

cb();

}

function javascript(cb) {

// body omitted

cb();

}

function css(cb) {

// body omitted

cb();

}

// You can use a single task

watch('src/\*.css', css);

// Or a composed task watch('src/\*.js', series(clean, javascript));

不要用Gulp3的方式指定依赖任务，你需要使用**gulp.series**和**gulp.paralle**l，因为gulp任务现在只有两个参数。

gulp.series：按照顺序执行  
gulp.paralle：可以并行计算

1. gulp.task('my-tasks', gulp.series('a', 'b', 'c', function() {
2. _// Do something after a, b, and c are finished._
3. }));

### Question

### 居中的四中方式

Display: flex;

Justify-content: center;

Align-items:center;

.parent{

Display: table-cell;

Vertical-middle: center;

.son{

Margin: o auto;

}

}

.parent{

Position: relative;

.son{

Position: absolute;

Top: 0;

Left:0;

Bottom: 0;

Right: 0;

Margin: auto;

}

}

.parent{

Position: relative;

.son{

Position: absolute;

Left: 50%;

Top: 50%;

Margin-left: -100px;// 或者 transform: translate(-50%, -50%);

Margin-top: -100px;

}

}

作用域：

\--save 会把依赖包名称添加到 package.json 文件 dependencies 键下，

\--save-dev 则添加到 package.json 文件 devDependencies 键下

dependencies是运行时依赖，devDependencies是开发时的依赖

ts

set and get

伪类选择器：：link, : visit, : hover: active. :first-child, last-child, :enabled, :checked等等

CSS 伪类用来定义一个元素的不同状态

[Less](http://www.lesscss.org/"%20\t%20"_blank)是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数.

内存泄露：内存使用完不及时释放： 闭包, setTimeout第一个参数使用字符串而非函数会造成内存泄漏

200响应成功， 304浏览器缓存， 404资源找不到，405 没有对应的get/post请求，500服务器端错误，301永久重定向，302暂时重定

Src和 link标签： src是soucre的缩写，是引入。浏览器解析该元素时会暂停其他资源的下载和处理。 link是建立当前元素和文档的联系,link并行下载

this： 函数级调用： this代表window全局对象，对象级调用： 指代该对象.

通过接口可以类型检查，满足传统面向对象思想。利于有效开发，避免类型转化问题。

抽象类作为其他派生类的基类使用。一般不会实例化。

1：抽象类的抽象方法不具体实现，必须在派生类中实现

2：抽象方法必须包含abstract关键字并包含访问修饰符。

Umd模块是指那些可以作为模块使用又可以作为全局（没有模块加载器的环境下）使用的模块

Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。

**面向对象编程  
**面向对象编程可以看作是使用一系列对象相互协作的软件设计

类：**抽象**上的定义，不具体代表任何一个实例

对象：必须是一个**具体**的对象实例

类和对象是一对多关系，一个类可以创建多个对象实例，通过类创建对象的过程叫做实例化

垂直margin失效问题的解决办法：

1. 父元素有内边距或者有内容
2. 父元素有border
3. 父元素position设置absolute或者fixed，或者float浮动，脱离文档输出流

substr方法：返回指定下标范围的子字符串 第二个参数代表长度

substring方法：类似substr，但是第二个参数代表终止下标

所谓同源是指，域名，协议，端口相同。

for var a = (2, 3, 5); what is the value of a?

**Answer:** 5. The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand. ref: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)

请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式)：\`function foo(){ }();\`.

以function关键字开头的y语句会被解析成函数声明，函数声明是不允许直接运行的，只有解析器把这句话解析成函数表达式，才能直接运行。

### Seo优化

代码结构清楚 有利于搜索引擎抓取。

重要的内容优先加载，搜索引擎抓取的顺序是从上到下，从左到右。

Tille和h1标签，每个页面设置不同的title, h1标签不宜过多

图片的alt属性。

页面内容不要做成flash和图片。

减少Ajax的动态加载

js 继承

原型链

构造函数继承： 可以传递参数

组合式继承 ；：  
<br/><br/>调用栈是解释器追踪函数执行流的一种机制。

mixins就是定义一部分公共的方法或者计算属性,然后混入到各个组件中使用,方便管理与统一修改

[写一个判断数据类型的方法](https://github.com/haizlin/fe-interview/issues/27)

const typeCheck = (obj) => {

const typeStr = Object.prototype.toString.call(obj);

return typeStr.toLowerCase().slice(8, typeStr.length - 1);

};

console.log(typeCheck("str"));

console.log(typeCheck(1));

console.log(typeCheck(() => null));

console.log(typeCheck({a: 1}));

console.log(typeCheck(\[1, 2, 3\]));

console.log(typeCheck(new Set(\[1,2,3\])));

### async defer

async和defer的相同点

都是异步加载script,加载的过程都不会阻塞html的解析。



不同点

1.async和defer的执行时机不同,async是在加载完后立即执行,执行的过程仍会阻塞后续html的解析。defer是在html解析完,DomCOntentLoaded之前执行。

2.asyny不能保证script标签的执行顺序(谁先加载完谁先执行),await在html解析完之后按顺序执行。

总结

通常情况下defer的使用频率较高,它能保证script之间的变量依赖。

需要注意的是:async script的资源请求时异步的,但script的执行仍然会阻塞后续渲染(单线程),defer是在html渲染完之后执行的所以不会阻塞后续html的解析。

### BOM

Browser object model

Window是它的顶级对象 window.Open/close

History

Document

Location

Navigator

Screen

Cookie

Settimeout

### 浏览器渲染原理

上图是webkit内核的渲染流程，和总体渲染流程差不多，要构建HTML的DOM Tree，和CSS规则树，然后合并生成Render Tree，最后渲染。

### Rem

css中的body中先全局声明font-size=62.5%，这里的%的算法和rem一样。

**因为100%=16px，1px=6.25%，所以10px=62.5%，**

这是的1rem=10px，所以12px=1.2rem。px与rem的转换通过10就可以得来，很方便了吧！

-  **使用方法**

注意，rem是**只相对于根元素htm的font-size**，即只需要设置根元素的font-size，其它元素使用rem单位设置成相应的百分比即可；

一般情况下，是这样子使用的

1 html{font-size:62.5%;}

2 body{font-size:12px;font-size:1.2rem ;}

3 p{font-size:14px;font-size:1.4rem;}

### New 操作符

New操作符创建一个空对象，用this指代该对象。同时继承该函数的原型。属性和方法被加到this 引用的对象中。

### 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

####  **体积小，传输效率高**

#### **隐藏性好**

####  **兼容性好**

#### **浏览器自动请求**

### Object.defineProperty的缺陷

- - - 1. 无法检测到对象属性的新增或删除
            2.  无法监听数组变化
            3.  只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。

Object.defineProperty 是 ES5 中引入的一个方法，用于定义或修改对象的属性，并返回该对象。它主要用于精细地控制对象的属性。  

### Promise.finally原理实现

Promise.finally本质上是一个then 方法。

### 在 map 中和 for 中调用异步函数的区别

### 由于 map 中的异步调用可以并发执行，所以它们的结果顺序可能与它们在数组中的顺序不同

在 for 循环中使用 await 关键字可以确保每个异步操作按顺序执行。当前一个异步操作完成后，

for in可以遍历对象/数组/字符串，遍历的是索引或对象的属性名

for of 只能遍历数组，可以遍历伪数组，遍历的是值，不能遍历对象（可迭代对象的值）  
for...of需要实现iterator接口，对象没有实现iterator接口

### map 和 forEach 有什么区别？

map()会返回一个全新的数组

由于 forEach 和 map 是同步函数，它们并不支持 await 语句；使用break或continue会报错

for循环、for...in,for...of，支持await，for和for...of中可以使用break和continue；for...in会忽略continue和break  

### 为何\[0\]==true 返回false, if(\[0\]){alert('1')}可以被判断为真弹出1?

​ javascript在做if(condition)判断的时候会把condition转换成boolean然后做判断，\[0\]是一个有值的list，所以转成boolean是true

javascript在做 A == B的比较时，如果A和B的type不一样，会先把A和B转化成相同的type，通常是number，然后再作比较

\[0\] == true;

//分成以下步骤

//把true转化成number，true变成1

\[0\] == 1;

//list是object

//先看\[0\].valueOf()，结果还是\[0\]

//再看\[0\].toString()，结果是“0” type是string

"0" == 1;

//把“0” string转化成number，“0”变成0，0不等于1

0 == 1; //结果是false

### \[\] == !\[\] 结果是什么

左边\[\] == 0

右边!\[\] == false

False == 0

所以0 == 0为true

### ！可将变量转换成boolean类型，null、undefined、NaN以及空字符串('')取反都为true，其余都为false

//catch创建的块作用域，只对catch的参数有效。对于在内部声明的变量，catch并没有创建一个新的作用域，只是一个普通的代码块

。// let x, y;

// try {

//   throw new Error();

// } catch (y) {

//   x =1;

//   y=2;

//   console.log(x);

// }

// console.log(x);

// console.log(y);

-
    <br/><br/><https://github.com/lgwebdream/FE-Interview/issues/73>
- let length = 10;
- function fn() {
-   console.log(this.length);
- }
- var obj = {
-   length: 5,
-   method: function(fn) {
-     fn();
-     arguments\[0\]();
-   }
- };
- obj.method(fn,1);

function getName(){

&nbsp; return

&nbsp; {

&nbsp;   name:'京程一灯'

&nbsp; }

}

console.log(getName());

//undifined

return后换行了,JavaScirpt会在return语句后自动插入了分号。  
// 对象地址

1  
var a = { k1: 1 };

var b = a;

a.k3 = a = { k2: 2 };

console.log(a); // ?

console.log(b); // ?

2  
let a = {n: 1};

let b = a;

a.x = a = {n: 2};

console.log(a.x)  

console.log(b.x)

### Setinterval 不准确

原因：setInterval 的定时可能不准确的原因主要包括事件循环的影响、回调函数的执行时间、浏览器的节能模式、系统负载和用户操作

1\. 使用 setTimeout 递归调用



1. 使用 requestAnimationFrame



1. Webworker

Ca

如果setInterval 的回调函数执行时间较长时，可能会导致后续的回调被跳过  

### JSBridge

##### **1. **URL Scheme****

原理

- 通过在 WebView 中加载一个特定的 URL 来触发原生方法。
- 原生应用监听这些 URL 并解析其中的参数，执行相应的操作。

##### **2. **JavaScript Injection****

原理

- 原生应用向 WebView 注入 JavaScript 代码，提供一个全局对象或方法，供 JavaScript 调用。
- JavaScript 通过调用这些方法来触发原生操作。

### Vite

#### **1. **原生 ES 模块支持****

- ****无打包启动****：Vite 利用了浏览器对原生 ES 模块的支持，开发过程中无需打包整个项目。这意味着启动开发服务器时，Vite 只需读取和解析模块图，而不是像 Webpack 那样将所有文件打包成一个或多个 bundle。
- ****按需编译****：只有在实际请求某个模块时，Vite 才会编译和转换该模块。这大大减少了启动时间和热更新的时间。

#### **2. **开发服务器优化****

- ****快速冷启动****：由于 Vite 使用了原生 ES 模块，开发服务器的启动时间非常短，通常只需几秒钟。
- ****热模块替换（HMR）****：Vite 提供了高效的热模块替换（HMR）机制，可以在不刷新页面的情况下实时更新代码。HMR 的实现更加精细，只更新实际发生变化的部分，而不是整个模块。

#### **3. **依赖预构建****

- ****预构建依赖****：Vite 会自动预构建项目中的依赖项，将它们转换为 ES 模块格式。这样可以避免在开发过程中重复编译第三方库，进一步加快了开发速度。
- ****缓存机制****：预构建的依赖会被缓存起来，下次启动时可以直接使用，进一步减少了启动时间。

#### **4. **内置开发服务器****

- ****内置开发服务器****：Vite 自带了一个开发服务器，基于 Node.js 的 esbuild 和 rollup，提供了开箱即用的开发环境。开发服务器支持多种开发工具和插件，如 TypeScript、CSS 预处理器等。
- ****自动重启****：开发服务器会监听文件变化，自动重启以反映最新的代码变更。

#### **5. **生产构建优化****

- ****高效构建****：虽然 Vite 在开发模式下不进行打包，但在生产构建时，Vite 会使用 Rollup 进行高效的打包。Rollup 的构建速度通常比 Webpack 更快，尤其是在处理大型项目时。
- ****Tree Shaking****：Vite 通过 Rollup 进行 Tree Shaking，移除未使用的代码，减小最终的包体积
- ****原生 ES 模块支持****：开发过程中无需打包，按需编译。
- ****开发服务器优化****：快速冷启动和高效的 HMR。
- ****依赖预构建****：预构建和缓存依赖，减少重复编译。
- ****内置开发服务器****：开箱即用的开发环境，自动重启。
- ****生产构建优化****：高效的 Rollup 构建和 Tree Shaking。
- ****现代化的开发体验****：支持现代 JavaScript 语法和丰富的插件系统。

### 怎么实现地图

#### **1\. 数据准备**

##### **1.1 地图数据**

- ****矢量数据****：使用 GeoJSON 格式的数据，包含点、线、多边形等地理要素。
- ****栅格数据****：使用 TIFF、PNG、JPEG 等格式的卫星图像或地图瓦片。

##### **1.2 数据来源**

- ****公开数据****：可以从 OpenStreetMap、Natural Earth 等网站获取免费的地理数据。
- ****自采数据****：使用 GPS 设备或无人机采集数据。

#### **2\. 前端开发**

##### **2.1 选择框架**

- ****纯 JavaScript****：使用原生 JavaScript 和 HTML5 Canvas 或 SVG。
- ****Web GIS 框架****：使用 Leaflet、OpenLayers 等成熟的地图库。

##### 2.2 基本地图显示

使用 Leaflet

****1引入 Leaflet****：

2 创建地图容器  
3 初始化地图：

使用Canvas  


#### GeoJSON 是一种强大且灵活的地理数据格式

大多数现代地图库（如 Leaflet、OpenLayers、Mapbox）都支持直接使用 GeoJSON 数据。

coordinates 是一个包含多个数值的数组，表示经度和纬度。

GeoJSON 对象可以包含以下几种类型：

1. ****几何对象（Geometry）****：表示地理形状，如点、线、多边形等。
2. ****特征（Feature）****：包含几何对象和属性信息。
3. ****特征集合（Feature Collection）****：包含多个特征对象。



### Mutation Observers

在DOM4 规范中引入，DOM Mutation Observers将取代 Mutation Events  
<https://developers.google.com/web/updates/2012/02/Detect-DOM-changes-with-Mutation-Observers>

var insertedNodes = \[\];  
document.addEventListener("DOMNodeInserted", function(e) {  
  insertedNodes.push(e.target);  
}, false);  
console.log(insertedNodes);  

var insertedNodes = \[\];  
var observer = new MutationObserver(function(mutations) {  
 mutations.forEach(function(mutation) {  
   for (var i = 0; i < mutation.addedNodes.length; i++)  
     insertedNodes.push(mutation.addedNodes\[i\]);  
 })  
});  
observer.observe(document, { childList: true });  
console.log(insertedNodes);

### shadowdom

<https://developers.google.com/web/fundamentals/web-components/shadowdom>

Shadow DOM 被设计为用于构建基于组件的应用程序的工具。因此，它带来了Web开发中常见问题的解决方案：

- **隔离 DOM**：组件的 DOM 是自包含的（例如， document.querySelector()不会返回组件影子 DOM 中的节点）。
- **作用域 CSS**：在 shadow DOM 中定义的 CSS 是作用域的。样式规则不会泄露，页面样式也不会渗入。
- **组合**：为您的组件设计一个声明性的、基于标记的 API。
- **简化 CSS** - Scoped DOM 意味着您可以使用简单的 CSS 选择器、更通用的 id/class 名称，而不必担心命名冲突。
- **生产力**\- 以 DOM 块而不是一个大（全局）页面来考虑应用程序。

Defining a new element

To define a new HTML element we need the power of JavaScript!

The customElements global is used for defining a custom element and teaching the browser about a new tag. Call customElements.define() with the tag name you want to create and a JavaScript class that extends the base HTMLElement.

Example - defining a mobile drawer panel, &lt;app-drawer&gt;:

class AppDrawer extends HTMLElement {...}

window.customElements.define('app-drawer', AppDrawer);

// Or use an anonymous class if you don't want a named constructor in current scope.

window.customElements.define('app-drawer', class extends HTMLElement {...});

## 协议

### UDP

UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是[OSI](https://baike.baidu.com/item/OSI"%20\t%20"_blank)（Open System Interconnection，[开放式系统互联](https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BA%92%E8%81%94/562749"%20\t%20"_blank)） 参考模型中一种无连接的[传输层](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82"%20\t%20"_blank)协议，提供面向事务的简单不可靠信息传送服务

在[网络](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C/143243"%20\t%20"_blank)中它与[TCP](https://baike.baidu.com/item/TCP"%20\t%20"_blank)协议一样用于处理数据包，是一种无连接的协议。在[OSI](https://baike.baidu.com/item/OSI"%20\t%20"_blank)模型中，在第四层——[传输层](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536"%20\t%20"_blank)，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP用来支持那些需要在[计算机](https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338"%20\t%20"_blank)之间传输数据的网络应用。包括[网络视频会议](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE"%20\t%20"_blank)系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议  

#### TCP（传输控制协议）和 UDP区别

连接方式：TCP 是面向连接的协议，需要在通信前建立连接，而 UDP 是无连接的协议，可以直接发送数据包。

可靠性：TCP 保证传输数据的可靠性，能够保证所有数据到达目的地且顺序正确；UDP 不保证传输数据的可靠性，可能会出现数据丢失或乱序等问题。

开销：TCP 在传输过程中要维护连接状态、进行流量控制、拥塞控制等操作，因此开销较大；UDP 没有这些机制，传输开销较小。

速度：由于 TCP 需要保证数据的可靠性，因此传输速度可能会受到一定的影响；UDP 没有这个限制，传输速度快。

适用场景：TCP 适用于对可靠性要求较高的应用场景，如文件传输、邮件传输等；而 UDP 适用于实时性要求较高的应用场景，如语音、视频、游戏等。

### TCP

（Transmission Control Protocol [传输控制协议](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/9727741"%20\t%20"_blank)）是一种面向连接的、可靠的、基于字节流的[传输层](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536"%20\t%20"_blank)通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内<sup>\[1\]</sup>  另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。 <sup>\[1\]</sup>

应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（ \[1\]  MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体 \[1\]  的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（[RTT](https://baike.baidu.com/item/RTT"%20\t%20"_blank)）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验

TCP相比UDP为什么是可靠的  
\[1\] 确认和重传机制

建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础  
传输过程中，如果Checksum校验失败、丢包或延时，发送端重传  
\[2\] 数据排序

TCP有专门的序列号SN字段，可提供数据re-order  
\[3\] 流量控制

窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量  
\[4\] 拥塞控制

TCP的拥塞控制由4个核心算法组成。

“慢启动”（Slow Start）

“拥塞避免”（Congestion avoidance）

“快速重传 ”（Fast Retransmit）

“快速恢复”（Fast Recovery）

以上就是TCP比UDP传输更可靠的原因。

#### TCP 拥塞

的主要原因是网络带宽限制、缓冲区溢出、慢启动、拥塞避免、快重传和快恢复机制，以及拥塞控制算法的选择

### Ip

<https://draveness.me/whys-the-design-ipv6-replacing-ipv4/>

### ‌TCP/IP协议

‌TCP/IP协议‌（Transmission Control Protocol/Internet Protocol）是互联网的基本协议，也是国际互联网络的基础。它不仅仅指的是TCP和IP这两个协议，而是一个由多个网络协议组成的协议族，包括FTP、SMTP、UDP、ICMP、ARP等协议。TCP/IP协议定义了计算机操作系统如何连入互联网，以及数据传输的标准‌12。

TCP/IP协议的层级结构

TCP/IP协议采用四层的层级结构，每一层都呼叫它的下一层所提供的服务来完成自己的需求：

‌链路层‌：处理与电缆或其他传输媒介的物理接口细节。

‌网络层‌：处理分组的选路和转发，主要包括IP协议。

‌传输层‌：提供端到端的通信控制，主要包括TCP协议和UDP协议。

‌应用层‌：提供各种应用服务，如HTTP协议、FTP协议、SMTP协议等‌

### OSI 七层模型

OSI（Open Systems Interconnection）模型是由国际标准化组织（ISO）提出的理论框架，旨在为网络通信提供一个标准化的参考模型。OSI 模型将网络通信功能划分为七个层次，每一层都有明确的功能和职责：

1\. 物理层（Physical Layer）

功能：定义了网络传输媒介的技术规范，包括电压、频率、信号强度、电缆接口、传输速率等。

示例：同轴电缆、光纤、双绞线。

2\. 数据链路层（Data Link Layer）

功能：负责在物理层提供的服务之上建立逻辑链路，提供可靠的数据传输，包括帧同步、错误检测和纠正等。

示例：以太网、PPP（点对点协议）。

3\. 网络层（Network Layer）

功能：负责路由选择和寻址，确保数据包从源地址正确地传输到目的地址。

示例：IP 协议、ICMP 协议、ARP 协议。

4\. 传输层（Transport Layer）

功能：负责端到端的数据传输，提供可靠的数据传输服务。

示例：TCP（传输控制协议）、UDP（用户数据报协议）。

5\. 会话层（Session Layer）

功能：负责建立、管理和终止会话，提供会话管理和同步功能。

示例：RPC（远程过程调用）、NFS（网络文件系统）。

6\. 表示层（Presentation Layer）

功能：负责数据的表示形式和加密解密，处理数据编码、压缩、加密等。

示例：JPEG、MPEG、ASCII 等。

7\. 应用层（Application Layer）

功能：提供应用程序之间的通信，为用户提供网络服务。

示例：HTTP、FTP、SMTP、DNS 等。

### TCP/IP 四层模型

TCP/IP（Transmission Control Protocol/Internet Protocol）模型是实际互联网使用的模型，它将网络通信功能划分为四个层次：

1\. 应用层（Application Layer）

功能：与 OSI 模型的应用层和表示层对应，提供应用程序之间的通信。

示例：HTTP、FTP、SMTP、DNS 等。

2\. 传输层（Transport Layer）

功能：与 OSI 模型的传输层对应，负责端到端的数据传输。

示例：TCP、UDP。

3\. 网络层（Internet Layer）

功能：与 OSI 模型的网络层对应，负责路由选择和寻址。

示例：IP 协议、ICMP 协议、ARP 协议。

4\. 网络接口层（Network Interface Layer）

功能：与 OSI 模型的数据链路层和物理层对应，负责物理介质上的数据传输。

示例：以太网、PPP、Wi-Fi。

对比

1\. 层数不同

OSI 七层模型：分为七层，每一层都有明确的功能和职责。

TCP/IP 四层模型：分为四层，简化了 OSI 模型中的某些层次。

2\. 层次划分

OSI 模型：更加细致地划分了网络通信的功能，例如会话层和表示层。

TCP/IP 模型：将 OSI 模型中的会话层和表示层合并到应用层中。

3\. 实际应用

OSI 模型：主要用于理论研究和教学，提供了详细的网络通信层次结构。

TCP/IP 模型：实际互联网的标准模型，更接近实际应用中的层次划分。

### VPN

Virtual Private Network 虚拟专用网络的功能是：在[公用网络](https://baike.baidu.com/item/%E5%85%AC%E7%94%A8%E7%BD%91%E7%BB%9C/12752077"%20\t%20"_blank)上建立[专用网络](https://baike.baidu.com/item/%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/795899"%20\t%20"_blank)，进行[加密](https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86/752748"%20\t%20"_blank)通讯。在[企业网络](https://baike.baidu.com/item/%E4%BC%81%E4%B8%9A%E7%BD%91%E7%BB%9C/2119389"%20\t%20"_blank)中有广泛应用。[VPN](https://baike.baidu.com/item/VPN"%20\t%20"_blank)网关通过对[数据包](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85/489739"%20\t%20"_blank)的加密和数据包目标地址的转换实现[远程访问](https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/3326708"%20\t%20"_blank)。VPN有多种分类方式，主要是按协议进行分类。VPN可通过[服务器](https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571"%20\t%20"_blank)、硬件、软件等多种方式实现。

### SOAP

Simple object acees protocol

简单对象访问协议是交换数据的一种协议规范。基于XML的协议

### **webService三要素**

编辑

SOAP、

**WSDL**(**W**_eb_**S**_ervices_**D**_escription_**L**_anguage_)、

**UDDI**(**U**_niversal_**D**_escription_**D**_iscovery and_**I**_ntegration_)之一，

soap用来描述传递信息的格式， WSDL 用来描述如何访问具体的接口， uddi用来管理，分发，查询webService 。具体实现可以搜索 Web Services简单实例 ; SOAP 可以和现存的许多[因特网协议](https://baike.baidu.com/item/%E5%9B%A0%E7%89%B9%E7%BD%91%E5%8D%8F%E8%AE%AE"%20\t%20"_blank)和格式结合使用，包括[超文本](https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC"%20\t%20"_blank)[传输协议](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"%20\t%20"_blank)（HTTP），[简单邮件传输协议](https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"%20\t%20"_blank)（SMTP），[多用途网际邮件扩充协议](https://baike.baidu.com/item/%E5%A4%9A%E7%94%A8%E9%80%94%E7%BD%91%E9%99%85%E9%82%AE%E4%BB%B6%E6%89%A9%E5%85%85%E5%8D%8F%E8%AE%AE"%20\t%20"_blank)（MIME）。它还支持从[消息](https://baike.baidu.com/item/%E6%B6%88%E6%81%AF"%20\t%20"_blank)系统到[远程过程调用](https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"%20\t%20"_blank)（RPC）等大量的[应用程序](https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"%20\t%20"_blank)。SOAP使用基于XML的[数据结构](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"%20\t%20"_blank)和[超文本](https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC"%20\t%20"_blank)[传输协议](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"%20\t%20"_blank)(HTTP)的组合定义了一个标准的方法来使用Internet上各种不同操作环境中的[分布式对象](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1"%20\t%20"_blank)。

### DNS

Domin name system  
<br/>

1查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。

2、在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。

3、如果hosts里没有这个域名的映射，3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。

4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。

5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址([http://qq.com](https://link.zhihu.com/?target=http%3A//qq.com"%20\t%20"_blank))给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找[http://qq.com](https://link.zhihu.com/?target=http%3A//qq.com"%20\t%20"_blank)域服务器，重复上面的动作，进行查询，直至找到www . qq .com主机。

6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。  
<br/>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。

##### dns只能拿到IP，是如何将IP转为mac地址

将 IP 地址解析为 MAC（媒体访问控制地址） 地址的过程是由数据链路层的 ARP（Address Resolution Protocol）完成

通过arp协议，arp维护一个本地的高速缓存表，里面有ip到mac的映射，若没有则广播消息查找）

发送 ARP 请求：

客户端需要将数据包发送到 192.168.1.1，但不知道该 IP 地址对应的 MAC 地址。

客户端在本地网络中广播一个 ARP 请求，询问谁拥有 IP 地址 192.168.1.1。

ARP 请求包含客户端的 MAC 地址和 IP 地址，以及目标 IP 地址 192.168.1.1。

接收 ARP 请求：

所有在同一局域网内的设备都会接收到这个广播请求。

如果某个设备的 IP 地址是 192.168.1.1，它会回复一个 ARP 应答。

发送 ARP 应答：

拥有 IP 地址 192.168.1.1 的设备（例如，服务器）向客户端发送一个 ARP 应答。

ARP 应答包含目标设备的 MAC 地址。

例如，ARP 应答可能包含 00:11:22:33:44:55 作为 192.168.1.1 的 MAC 地址。

更新 ARP 缓存：

客户端收到 ARP 应答后，将 IP 地址 192.168.1.1 和 MAC 地址 00:11:22:33:44:55 的对应关系缓存起来，以便将来使用。

### 三次握手  



三次握手是指 建立tcp 连接时，需要客户端和服务器总共需要发送三个包。

1 作用是为了确认双方的接收能力和发送能力是否正常

2 防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，  


  
第一次握手（SYN）：

客户端向服务器发送一个带有SYN（Synchronize）标志的数据包，并选择一个初始序列号（Sequence Number，简称Seq），表示客户端希望开始建立连接。

例如，客户端发送一个 SYN 数据包，其中包含序列号 X。

第二次握手（SYN+ACK）：

服务器收到客户端的 SYN 数据包后，确认收到，并向客户端发送一个带有SYN和ACK（Acknowledgment）标志的数据包。

服务器选择自己的初始序列号 Y，并确认客户端的序列号 X+1（表明收到了客户端的序列号 X）。

例如，服务器发送一个 SYN+ACK 数据包，其中包含序列号 Y 和确认号 X+1。

第三次握手（ACK）：

客户端收到服务器的 SYN+ACK 数据包后，确认收到，并向服务器发送一个带有ACK标志的数据包。

客户端确认服务器的序列号 Y+1（表明收到了服务器的序列号 Y）。

例如，客户端发送一个 ACK 数据包，其中包含确认号 Y+1。  
挥手为什么需要四次？

双方向确认：

四次挥手过程中，连接的双方都需要确认对方的数据传输已经结束。主动关闭方发送 FIN 表示不再发送数据，而被动关闭方也需要发送 FIN 表示自己的数据传输也已完成。

防止丢失确认：

如果只有三次挥手，那么在被动关闭方发送 FIN 后，如果 ACK 数据包丢失，主动关闭方无法知道被动关闭方是否收到了 FIN。因此，需要第四次挥手来确认被动关闭方的 FIN 已经被主动关闭方收到。

### Http

<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS>  
<https://www.bbsmax.com/A/LPdooLRwd3/>

超文本传输协议，是一种基于请求与相应 无状态，应用层的协议，基于TCP/IP传输数据

#### **HTTP 是无状态，有会话的**

HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。

注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。

### Https

是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。SSL协议位于[TCP/IP协议](https://baike.baidu.com/item/TCP/IP%E5%8D%8F%E8%AE%AE)与各种应用层协议之间，为[数据通讯](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF)提供安全支持

- ****SSL****（Secure Sockets Layer）是最早的安全协议之一，由 Netscape 在 1994 年推出。随着版本的发展，S
- ****TLS**** 是 SSL 的后续版本，提供了更强大的安全性和更好的性能。

SSL/TLS 的主要作用是在客户端和服务器之间建立加密通道，保护数据的安全性

<https://http2.github.io/faq/>  
<https://mp.weixin.qq.com/s/i8qVR-b1MLQ_UI3NG7aPXw>

认证用户和服务器，确保数据发送到正确的[客户机](https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E6%9C%BA"%20\t%20"_blank)和[服务器](https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8"%20\t%20"_blank)；

2）加密数据以防止数据中途被窃取；

3）维护数据的完整性，确保数据在传输过程中不被改变。

#### 通信过程

（1） 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

　（3）客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。

　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

　（5）Web服务器利用自己的私钥解密出会话密钥。

　（6）Web服务器利用会话密钥加密与客户端之间的通信。

1客户端发起请求：

客户端通过 HTTP 请求连接服务器，并指定使用 HTTPS。

2服务器发送证书：

服务器发送包含公钥的数字证书给客户端。

3客户端验证证书：

客户端验证证书的有效性（例如，证书是否由可信的 CA 签名）。

4客户端生成会话密钥：

客户端生成一个随机的对称加密密钥（称为会话密钥）。

使用服务器的公钥对会话密钥进行加密。

5客户端发送加密的会话密钥：

客户端将加密后的会话密钥发送给服务器。

6服务器解密会话密钥：

服务器使用自己的私钥解密客户端发送的会话密钥。

7加密通信：

此后，客户端和服务器使用对称加密算法（如 AES）和会话密钥加密和解密数

#### https 传输过程的加密

在 HTTPS 传输过程中，主要使用了以下加密方法：

1. ****非对称加密****：用于密钥交换和身份验证。
2. ****对称加密****：用于高效地加密和解密实际传输的数据。
3. ****消息认证码（MAC）****：用于数据完整性验证。
4. ****数字签名****：用于服务器身份验证。

对称加密是一种加密技术，其中使用同一个密钥进行数据的加密和解密

1.速度快：对称加密算法（如 AES）的加解密速度非常快，适合大量数据的加密和解密。

2.资源消耗低：对称加密算法的计算复杂度较低，对计算资源的消耗较小。

非对称加密 缺点  
一效率慢

二是非对称加密，服务器端只能用私钥加密，但黑客可能获取到公钥，不能保证服务器端的数据安全

#### 8种方法

Get：请求指定的信息

Post：提交数据进行数据处理。数据包含在请求体

Put：从客户端向服务器传送的数据取代指定的文档内容

Delete：请求服务器删除指定的页面

Head：类似get，但是 响应中没有具体的内容

Connect：

Trace

Opotions:检查服务器那边是否允许自己发请求。

###### Post 和put 区别

put 具有幂等性， 多次提交相同请求 资源状态不会改变

一般用来更新资源

Post 一般用来创建数据或者触发服务器上的某些操作

#### 简单请求（Simple Request）

使用 GET、POST、HEAD 方法之一。

POST 请求的 Content-Type 限于三个值之一：application/x-www-form-urlencoded、multipart/form-data、text/plain。

预检请求（Preflight Request）：

使用除了 GET、POST、HEAD 之外的方法。

POST 请求的 Content-Type 不是上述三个值之一。

包含自定义请求头（非简单请求头）

#### 预检请求

非简单请求的CORS（Cross-Origin Resource Sharing）请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。只包含头部信息，不包含请求体





#### 状态码

1xx: 请求相关信息 2xx: 操作成功

3xx: 重定向

4xx: 客户端错误

5xx: 服务端错误

1开头：请求被接受，需要继续处理

2：请求被接收，理解

301：永久重定向

302：暂时重定向

304：从浏览器本地缓存读取数据

404:资源找不到

405：没有对应的get/post请求

500服务器错误

#### Restful

是一种API设计风格：

特点：

- - - 1. 根据URL知道需要什么资源；

每个 API 端点都应该代表一个具体的资源集合（如 /users 或 /orders）

- - - 1. 根据http method就知道什么做什么动作
            2.  根据状态码知道动作的结果
            3.  使用swagger等提供详细的 API 文档

#### HTTP/3

HTTP/3是HTTP/2的继承者。截至 2020 年 9 月，所有主要浏览器都对 HTTP/3提供了实验性支持，一些 CDN 也支持它。性能是 HTTP/3 相对于 HTTP/2 的主要优势。具体来说，HTTP/3 消除了连接级别的队头阻塞并减少了连接建立时间。

1 连接迁移：QUIC 允许在网络切换或 IP 变更时迁移连接，而不需要重新建立新的连接，从而避免了连接中断和数据丢失的问题。

2 可靠性流控制：QUIC 在每个流上都实现了可靠的流控制机制，可以根据发送方和接收方的负载情况动态调整数据发送速率，从而优化传输效率和可靠性。

3 数据重传：QUIC 中每个数据包都带有唯一标识符（Packet Number），接收方可以根据这个标识符进行数据包的确认和重传，以保证数据传输的可靠性。

4 拥塞控制：QUIC 采用了基于 TCP 的拥塞控制机制，可以根据网络拥塞程度自适应调整发送速率，以避免网络拥塞和丢包等问题。

HTTP/2 是一个二进制协议而不是文本

HTTP/2 引入了多路复用，该功能允许使用单个连接同时传输多个数据流。但是，对于 HTTP/2，单个丢弃的数据包会阻塞连接上的所有流（这种现象称为队头阻塞）。使用 HTTP/3，丢弃的数据包只会阻塞单个流。这种改进主要是 HTTP/3 使用UDP（HTTP/3 通过QUIC使用 UDP ）而不是TCP 的结果。这使得 HTTP/3 对于通过拥塞或有损网络传输数据特别有用。

减少连接建立时间

HTTP/3 使用 TLS 1.3，因此共享其性能优势：建立新连接只需要一次往返，恢复现有连接不需要任何往返。

##### 多路复用

为了避免 每次请求就建立一次连接。 采用了keep-alive。 一定时间内让建立一次连接可以多次请求数据。在http1 传输基于文本， 所以所有的数据必须按顺序传输。 HTTP2 采用二进制数据帧和流的概念。帧对数据进行顺序标记。浏览器接收到数据后按照序列对数据进行合并，不会出现合并数据错乱，。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。

#### HTTP连接建立流程

<https://www.jianshu.com/p/25313dbd2e46>  
浏览器请求 url -> 解析域名 -> 建立 HTTP 连接 -> 服务器处理文件 -> 返回数据 -> 浏览器解析、渲染文件

- 、输入网址
- 、DNS解析
- 3、建立tcp连接
- 4、客户端发送HTPP请求
- 5、服务器处理请求　[](https://www.cnblogs.com/xianyulaodi/p/6547807.html"%20\l%20"_label6)
- 6、服务器响应请求
- 7、浏览器展示HTML
- 8、浏览器发送请求获取其他在HTML中的资源。

#### **[HTTP 报文及其结构](https://segmentfault.com/a/1190000019788537)**

请求行

请求头

空行

请求主体

请求行: 由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，  
GET /data/info.html HTTP/1.1

请求头：Accept cookie authrization user-agent host

<https://segmentfault.com/a/1190000019788537>

#### cookie 的 secure 属性为 true

它表示创建的 cookie 只能在 HTTPS 连接中被浏览器传递到服务器端

#### http 和 https 有何区别？如何灵活使用？

区别：

1、HTTPS是加密传输协议，HTTP是名文传输协议;

2、HTTPS需要用到SSL证书，而HTTP不用;

3、HTTPS比HTTP更加安全，对搜索引擎更友好；

4、 HTTPS标准端口443，HTTP标准端口80;

5、 HTTPS基于传输层，HTTP基于应用层;

6、 HTTPS在浏览器显示绿色安全锁，HTTP没有显示;

#### SSL 握手过程

1. ****协商加密套件****：选择合适的加密算法和协议版本。
2. ****身份验证****：验证服务器的身份。
3. ****密钥交换****：安全地协商和交换会话密钥。
4. ****完整性验证****：通过 Finished 消息确保握手过程的完整性。

#### 网络优化

HTTP请求、

压缩资源、

优化缓存策略、

- ****浏览器缓存****：设置合理的HTTP缓存头（如Cache-Control、Expires），让浏览器缓存静态资源。
- ****CDN（内容分发网络）****：使用CDN加速静态资源的加载，减少用户的访问延迟。
- ****Service Worker****：使用Service Worker在客户端缓存资源，实现离线访问和快速加载。

优化资源加载、

- ****懒加载****：使用懒加载技术，延迟加载非关键资源（如图片、视频），提高初始加载速度。
- ****优先加载关键资源****：使用preload和prefetch指令，提前加载关键资源
- ****异步加载JavaScript****：使用async和defer属性，确保JavaScript文件不会阻塞页面的渲染。

优化服务器响应

- ****使用HTTP/2****：HTTP/2支持多路复用，可以同时处理多个请求，减少延迟。
- ****优化数据库查询****：优化数据库索引和查询语句，减少数据库响应时间。
- ****使用缓存层****：使用Redis、Memcached等缓存层，减少对数据库的直接访问

#### CDN 缓存

1\. 选择合适的 CDN 提供商

2\. 注册并设置 CDN 账户

3\. 配置 DNS 设置

为了使 CDN 生效，你可能需要更新你的域名系统（DNS）记录。这通常涉及添加一个 CNAME 记录指向 CDN 提供商提供的子域名。具体的配置方法取决于你的域名托管服务提供商和所使用的 CDN 服务。

例如，如果你使用的是 Cloudflare，那么只需要在 Cloudflare 控制面板中将你的域名加入，并开启其代理服务即可。对于其他 CDN，你可能需要手动配置 CNAME 或 A 记录。

4\. 将静态资源上传到 CDN

有些 CDN 提供商会允许你直接上传文件到它们的存储空间（如 Amazon S3）。对于这些情况，你可以通过 FTP、SFTP 或者 API 接口来上传文件。而像 Cloudflare 这样的 CDN 则会自动从源服务器抓取资源，无需单独上传。

5\. 修改应用程序引用静态资源的方式



## 网络安全  

### Xss

跨域脚本攻击

1: 反射型Xss: 恶意链接，点击完以后会获取有用信息。

通过 URL 链接点击触发，是一次性行为，本质上是服务器端没有对用户恶意输入做安全处理，直接反射输入内容。如输入baidu.com/?id=&lt;script&gt;alert(1)&lt;/script&gt;，弹出弹窗内容为 1。谷歌这类安全性高的浏览器基本可以自动处理这类攻击。

2：存储型：将恶意代码上传到服务器，下次浏览页面，恶意代码就会执行。

3：Sql注入。



数据库中密码不被明文存储，对密码进行加密，

<https://github.com/lgwebdream/FE-Interview/issues/1131>

危害： 获取cookie来获取敏感信息，请求一些平时不允许的操作。

防御：

对服务器提交的信息做检查，URL,http/post数据进行查询，对不是规定的格式，长度的内容进行过滤。

设置http only的cookie, Js脚本就不能获取到cookie.

3 白名单制度 Content-Security-Policy开发者明确告诉客户端哪些外部资源可以加载和执行。  
4 HTML 标签转义 将标签符号"&lt;"，"&gt;"等全局转义  

**secure-only:** 只允许https请求读取，发送请求时自动发送cookie。  
**host-only:** 只允许主机域名与domain设置完成一致的网站才能访问该cookie。  
<br/>

### 提高资源的安全性

1\. SRI 是 Subresource Integrity 子资源完整性

GitHub 宣布启用 SRI 策略，用来减少由「托管在 CDN 的资源被篡改」而引入的 XSS 等风险。

SRI 是 Subresource Integrity 子资源完整性

它通过对资源进行摘要签名机制，来保证外链资源的完整性

hTTPS 也可以确保传输过程中的数据完整性，但是对于 CDN 服务器被入侵或 HTTP 回源被劫持造成的文件篡改，HTTPS 无济于事，这时 SRI 就可以派上用场，作为补充

只需要在原有的标签里增加 integrity 属性即可，这个属性的签名算法支持 sha256、sha384 和 sha512，

览器在加载资源时，会计算资源的实际摘要，并将其与 integrity 属性中的摘要进行比较。如果两者匹配，则加载资源；如果不匹配，则拒绝加载该资源。

2\. CSP（Content Security Policy）

我们可以开启 CSP 机制来保证加载的是需要的资源文件、执行的是正常的脚本。

一方面通过制定 CSP 的外链白名单机制，限制了不可信域名的资源加载；另一方面通过开启 nonce 模式，确保执行的是正常的内联脚本

1 使用 meta 标签 &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';"&gt;

2 CSP 默认禁止内联脚本和样式，但有时你可能需要使用内联脚本或样式。为了允许内联脚本和样式，你可以在 CSP 中使用 'unsafe-inline'

'unsafe-inline' 允许内联脚本和样式。具体来说：

内联脚本：允许在 HTML 中直接嵌入 &lt;script&gt; 标签内的脚本。

内联样式：允许在 HTML 中直接嵌入 &lt;style&gt; 标签内的样式，以及使用 style 属性。

'unsafe-eval' 允许使用 eval 和类似的功能，如 new Function、setTimeout 和 setInterval 的字符串参数形式

JSON Web Token (JWT)  
token 加密 sha1 sha2 sah3 decrypt

对称加密

非对称加密

### HTTP 挟持  

##### 2.1 什么是 HTTP 挟持

在运营商的路由器节点上，设置协议检测，一旦发现是 HTTP 请求且是 HTML 类型请求，则拦截处理。常见有两种：

- 返回 302 让用户浏览器跳转到另外的地址
- 在服务器返回的 HTML 中插入 JS 或 DOM 节点

#### HTTP 挟持防御

- 向运营商投诉
- 在 html 上加上 &lt;meta http-equiv="Cache-Control" content="no-siteapp"&gt; &lt;meta http-equiv="Cache-Control" content="no-transform " /&gt;禁止转码
- 使用 HTTPS，HTTPS 增加了 SSL 协议，会对数据进行加密。
- 白名单过滤。大体思路是检查所有外链是否属于白名单。  
    <https://web.dev/strict-csp/>  
    <https://web.dev/secure/>
- 监听 DOM 节点插入及 DOM 节点移除事件

el.addEventListener("DOMNodeInserted", function (e) {

console.log(e.srcElement);

});

el.addEventListener("DOMNodeRemoved", function (e) {

console.log(e.srcElement);

});

// Feature detection  
if (window.trustedTypes && trustedTypes.createPolicy) {  
// Name and create a policy  
const policy = trustedTypes.createPolicy('escapePolicy', {  
createHTML: str => {  
return str.replace(/\\&lt;/g, '&lt;').replace(/&gt;/g, '&gt;');  
}  
});  
}

### DDoS

分布式拒绝服务攻击

的表现形式主要有两种，

一种为[流量攻击](https://baike.baidu.com/item/%E6%B5%81%E9%87%8F%E6%94%BB%E5%87%BB/10809856"%20\t%20"_blank)，主要是针对网络带宽的攻击，即大量攻击包导致网络带宽被阻塞，合法网络包被虚假的攻击包淹没而无法到达主机；

另一种为资源耗尽攻击，主要是针对服务器主机的攻击，即通过大量攻击包导致主机的内存被耗尽或CPU被内核及应用程序占完而造成无法提供网络服务。当被DDoS攻击时，主要表现为： <sup>\[5\]</sup>

(1)被攻击主机上有大量等待的TCP连接。 <sup>\[5\]</sup>

(2)网络中充斥着大量的无用的数据包，源地址为假。 <sup>\[5\]</sup>

(3)制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯。 <sup>\[5\]</sup>

(4)利用受害主机提供的服务或传输协议上的缺陷，反复高速地发出特定的服务请求，使受害主机无法及时处理所有正常请求。 <sup>\[5\]</sup>

(5)严重时会造成系统[死机](https://baike.baidu.com/item/%E6%AD%BB%E6%9C%BA/257238"%20\t%20"_blank)。 <sup>\[5\]</sup>

#### 攻击流程

攻击者进行一次DDoS攻击大概需要经过了解攻击目标、攻占[傀儡机](https://baike.baidu.com/item/%E5%82%80%E5%84%A1%E6%9C%BA/10413334"%20\t%20"_blank)、实际攻击三个主要步骤，下面依次说明每一步骤的具

## JS函数式编程

<https://juejin.cn/post/6844903936378273799>

### 优点

可预测性：

纯函数：纯函数指的是那些只依赖于输入参数，并且没有副作用的函数。这样的函数对于同样的输入总是产生同样的输出，使得程序的行为变得可预测。

无副作用：纯函数没有外部依赖，也不修改外部状态，因此减少了调试时的不确定性和复杂性。

易于测试：

由于函数的输入和输出明确，没有隐藏的状态或副作用，因此可以很容易地对函数进行单元测试。

模块化和重用：

- 函数式编程鼓励编写小而专注的函数，这些函数可以容易地组合和重用来构建更复杂的逻辑。
- 函数可以独立地开发和测试，便于代码的模块化。

简洁性：

函数式编程通常使用高阶函数、闭包等特性，使得代码更加简洁和表达力强。

通过模式匹配、递归等技术，可以写出更短小精悍的代码。

### 缺点

学习曲线：

对于习惯了命令式编程（如 C、Java、Python 等）的开发者来说，函数式编程的概念和思维方式可能会比较陌生，需要花费时间去适应和学习。

性能问题：

在某些情况下，频繁创建不可变数据结构可能导致垃圾回收的压力增加，进而影响程序的性能。

递归函数在某些语言中可能会导致栈溢出的问题，需要特别注意尾递归优化。

调试难度：

由于函数式编程强调不可变性和纯函数，有时在调试时难以跟踪数据的变化过程。

对于复杂的函数组合，可能需要更多的技巧来理解和调试程序。

代码可读性：



一等公民是指函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值

## 代码简洁

### template literals 模板字符串

var fName = 'Peter', sName = 'Smith', age = 43, job= 'photographer';

var a = 'Hi, I\\'m ' + fName + ' ' + sName + ', I\\'m ' + age + ' and work as a ' + job + '.';

var b = \`Hi, I'm ${ fName } ${ sName }, I'm ${ age } and work as a ${ job }.\`;

### 块级作用域语法



这个例子中，输出是“5 5 5 5 5”因为变量i在每次迭代中都会改变。

var 和 let的另外一个区别是 let 不会像 var一样被变量提升



### Const

在以前，如果你想在JavaScript中声明一个常量， 习惯性的做法是使用全大写来命名。然鹅，这不是真的去保护了这个变量不能被更改---只是让其他的开发者知道，这是一个常量，它不应该被更改。

### 拓展运算符

let a = \[3, 4, 5\];

let b = \[1, 2, ...a, 6\];

console.log(b); // \[1, 2, 3, 4, 5, 6\]

像我们项目里面的grid option 合并

this.gridOptions = { ...this.gridOptions, ...defaultGridOptions, domLayout: "normal" };

扩展运算符的另一个特点是，他可以生成一个新的数组或者对象. 下面的这个例子，就是b就是新建的数组，但c只是引用同一个数组。



### Default Parameter 参数默认值



**function** **writeForumComment**(subject = 'No subject', body = 'No text') {

...

}

function writeForumComment(**subject, body)** {

**subject** \= **subject ||** 'No Subject';

**body** \= **body ||** 'No text';

}

### 函数参数

参数过多时 应该合并成一个对象

**function** **createMenu**(title, body, buttonText, cancellable) {

...

}

**var** menuConfig = {

title: 'Foo',

body: 'Bar',

buttonText: 'Baz',

cancellable: true

}

**function** **createMenu**(menuConfig) {

...

}

### 用 Object.assign 设置默认对象



 

### 使用方法链



### 错误处理

Don’t use console.log(error);

**try** {

functionThatMightThrow();

} **catch** (**error**) {

console.**error**(**error**);

// 另一个选择：

notifyUserOfError(**error**);

// 另一个选择：

}

### 函数调用者和被调用者应该尽可能放在一起

如果一个函数调用另一个函数，那应该让他们在源文件中的位置非常接近。理想情况下应该把调用者放在被调用者的正上方，这会让你的代码更易读，因为我们都习惯从上往下读代码

### 不要把注释掉的代码留在代码库中

版本控制存在的原因就是保存你的历史代码。

## 前端单元测试

- 单元测试：关注应用中每个零部件的正常运转，防止后续修改影响之前的组件。
- 功能测试：确保其整体表现符合预期，关注能否让用户正常使用。
- 整合测试：确保单独运行正常的零部件整合到一起之后依然能正常运行。

## SSR

Server-side-render

什么是SSR？将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。

### 优点

有更利于SEO和首屏渲染

### 缺点

服务器压力大，

开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂第三库使用受限，

学习成本大。

Nuxt.js是Vue的SSR方案

**Next.js** 是一个轻量级的 React 服务端渲染应用框架。

## SPA

### 单页Web应用（single page web application，SPA）

特点是只有一个主页，所有的二级页面都是通过ajax动态请求响应，设置到主页面的DIV中，需要注意的是要把所有二级页面的css，javascript提前在主画面加载。

优点：服务器压力小。响应速度快

缺点：

2、不利于SEO。

3、初次加载耗时相对增多。

4、导航不可用，如果一定要导航需要自行实现前进、后退。

页面路由：ajax+历史记录，进行动态页面切换

### 多页应用

多页面应用（Multi-Page Application, MPA）是指一个网站或应用包含多个独立的页面，每个页面都有自己的 URL 和独立的 HTML 文件。

每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种类型的网站也就是多页网站，也叫做多页应用。

优点： 首屏时间快： 只经历一次请求

搜索引擎优化效果好： 搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重

确定： 切换慢

Angular 和 React 主要用于构建单页面应用，但通过Webpack 配置多个入口点，它们也可以很好地支持多页面应用

### SSR有利于SEO优化

另一个重要的原因，就是SSR提高了更好的SEO效果。在传统的客户端渲染中，搜索引擎的爬虫只能获取到一个空白的HTML页面，因为实际内容是通过JS动态渲染，这样导致搜索引擎无法正确的进行索引和分析。

而通过SSR,搜索引擎获得完整的已渲染的页面HTML，这使得搜索引擎能够更好的理解网页内容，提高爬取效率，并有利于网页的排名。对于需要依赖搜索引擎流量的网站来说，SSR可以给予巨大的优势。

## 模式

### 代理模式

代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的访问。 类似于中介

静态代理：

创建服务类接口（抽象类）

实现服务接口（具体类）

创建代理类（代理类）

使用代理类

public class Client {

public static void main(String\[\] args) {

Subject subject = new ConcreteSubject(); // 具体类

Proxy proxy = new Proxy(subject);

proxy.request();

}

}

### 和装饰器模式的区别

装饰器模式更侧重对对象的拓展

代理模式更多是对对象的控制，重心是为了借用对象的功能完成某一流程

### 单例模式

一种常见的软件设计模式

创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回这个对象的引用。



Synchronized保证同一时刻只有一个线程可以执行该方法或者代码块

### 工厂模式

#### 简单工厂模式

通过工厂传递类型来指定要创建的对象

public class Demo {

public static void main(String\[\] arg) {

PhoneFactory factory = new PhoneFactory();

Phone miPhone = factory.makePhone("MiPhone"); // make xiaomi phone!

IPhone iPhone = (IPhone)factory.makePhone("iPhone"); // make iphone!

}

}

#### 工厂方法模式

定义了一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品。将生成任务交给不同的派生类工厂。

public class Demo {

public static void main(String\[\] arg) {

AbstractFactory miFactory = new XiaoMiFactory();

AbstractFactory appleFactory = new AppleFactory();

miFactory.makePhone(); // make xiaomi phone!

appleFactory.makePhone(); // make iphone!

}

}

抽象工厂模式：

AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品

###   

<br/>观察者模式与发布订阅模式的区别

耦合度：

观察者模式：观察者和主题之间存在直接的依赖关系，观察者需要知道主题的存在。

发布订阅模式：发布者和订阅者之间没有直接的依赖关系，它们都依赖于消息中间件。

灵活性：

观察者模式：适用于简单的依赖关系，通常用于一个对象状态变化时通知多个依赖对象。

发布订阅模式：适用于更复杂的场景，允许多个发布者和订阅者之间的解耦，支持更灵活的消息传递机制。

消息传递：

观察者模式：消息传递是直接的，主题直接调用观察者的方法。

发布订阅模式：消息传递是间接的，通过消息中间件进行。

适用场景：

观察者模式：适用于对象之间的简单依赖关系，如 GUI 控件的事件处理。

发布订阅模式：适用于需要解耦和灵活消息传递的场景，如事件驱动系统、消息队列等。

总结

## 数据结构

选择合适的数据结构

在实际应用中，选择哪种数据结构取决于具体的业务逻辑和技术要求。以下是一些考虑因素：

- ****性能需求****：根据操作频率（如查找、插入、删除）来选择最优化的数据结构。
- ****内存限制****：某些数据结构可能占用更多内存，因此要考虑系统的资源约束。
- ****并发控制****：如果涉及到多线程或分布式环境下的并发访问，确保所选数据结构支持必要的同步机制。
- ****扩展性和维护性****：随着项目的成长，代码的可读性和易于维护也是重要的考量因素。

通过理解这些常见数据结构的特点和应用场景，你可以更明智地做出决策，从而构建更加

#### **1. **高频查找****

##### **哈希表（Hash Table）**

- ****适用场景****：当查找操作非常频繁时，哈希表是理想的选择，因为它提供了平均 O(1) 的查找时间复杂度。
- ****示例应用****：缓存系统、数据库索引。
- ****优点****：快速查找、插入和删除；实现简单，易于理解和使用。
- ****注意事项****：需要处理哈希冲突


##### **布隆过滤器（Bloom Filter）**

- ****适用场景****：在需要快速排除不存在的元素且允许少量假阳性的情况下，布隆过滤器非常适合大规模数据集的成员资格测试。
- ****示例应用****：缓存命中检测、大文件去重。
- ****优点****：空间效率极高，适用于海量数据集。
- ****注意事项****：存在一定的误识别率（False Positive），但不会产生假阴性（False Negative）

#### **2. **高频插入/删除****

##### **跳表（Skip List）**

- ****适用场景****：对于有序数据的高效管理，尤其是频繁的插入和删除操作，跳表可以在 O(log n) 时间内完成这些操作。
- ****示例应用****：分布式系统的排序索引、实时数据分析。
- ****优点****：支持高效的并发读写操作，易于并行化。
- ****注意事项****：相较于平衡二叉搜索树，跳表更易于实现和维护


##### **ConcurrentHashMap 或其他线程安全的哈希表**

- ****适用场景****：在高并发环境下，确保多个线程能同时安全地读写共享资源，并且提供高效的插入和删除操作。
- ****示例应用****：Web 应用服务器中的会话管理、多线程任务调度。
- ****优点****：线程安全，减少了锁争用，支持高效的并发读写操作。
- ****注意事项****：实现较为复杂，可能增加开发成本


#### **3. **高频查找 + 插入/删除****

##### **Trie（字典树）**

- ****适用场景****：如果既需要快速查找又涉及字符串前缀匹配查询，Trie 是一个很好的选择。
- ****示例应用****：自动补全功能、拼写检查。
- ****优点****：支持复杂的字符串操作，如前缀匹配；查找、插入和删除的时间复杂度均为 O(m)，其中 m 是关键字长度。
- ****注意事项****：对于非字符串类型的键值不适用


##### **Cuckoo Hashing**

- ****适用场景****：当需要低碰撞率和较好的并发性能时，Cuckoo Hashing 可以在高频查找和插入/删除操作中表现优异。
- ****示例应用****：网络路由表查找、DNS 查询。
- ****优点****：较低的碰撞率，较好的并发性能。
- ****注意事项****：实现相对复杂，可能不适合所有应用场景


#### **4. **考虑内存限制****

##### **Bit Array (Bitmap)**

- ****适用场景****：对于只需要知道某个元素是否存在的情况，bit array 是一种非常节省空间的方法，每个位代表一个布尔值。
- ****优点****：极小的内存占用，适合稀疏集合的表示。
- ****示例应用****：位图索引、存在性检查。
- ****注意事项****：仅适用于特定类型的问题，如布尔值存储或小范围整数集合


##### **布隆过滤器（Bloom Filter）**

- ****适用场景****：布隆过滤器虽然可能产生假阳性，但它的空间效率极高，特别适用于处理海量数据集。
- ****优点****：显著减少内存使用量，适用于大规模数据集的成员资格测试。
- ****注意事项****：存在一定的误识别率（False Positive），但不会产生假阴性（False Negative）


#### **5. **并发控制****

##### **ConcurrentHashMap 或其他线程安全的数据结构**

- ****适用场景****：在多线程或分布式环境中，确保多个线程可以安全地访问和修改数据结构而不发生竞争条件。
- ****优点****：支持高效的并发读写操作，减少了锁争用。
- ****示例应用****：Web 应用服务器、多线程任务调度。
- ****注意事项****：实现较为复杂，可能增加开发成本


##### **跳表（Skip List）**

- ****适用场景****：某些实现提供了良好的并发性能，尤其是在分布式系统中。
- ****优点****：易于并行化，适合高并发环境。
- ****示例应用****：分布式存储系统中的有序数据存储。
- ****注意事项****：相较于平衡二叉搜索树，跳表更易于实现和维护


#### **6. **扩展性和维护性****

##### **哈希表（Hash Table）**

- ****适用场景****：由于其实现简单且易于理解，哈希表通常具有较高的可读性和易维护性。
- ****优点****：代码简洁，容易实现和调试。
- ****示例应用****：缓存系统、数据库索引。
- ****注意事项****：需要处理哈希冲突


##### **跳表（Skip List）**

- ****适用场景****：相比于平衡二叉搜索树，跳表的实现更为直观，更容易理解和维护。
- ****优点****：逻辑清晰，适合教学和实际应用。
- ****示例应用****：分布式系统的排序索引、实时数据分析。
- ****注意事项****：相较于平衡二叉搜索树，跳表更易于实现和维护


##### **Trie（字典树）**

- ****适用场景****：对于特定类型的字符串操作，Trie 提供了高效的解决方案，并且其结构相对简单，易于扩展。
- ****优点****：支持复杂的字符串操作，如前缀匹配。
- ****示例应用****：自动补全功能、拼写检查。
- ****注意事项****：对于非字符串类型的键值不适用



### 数组

### 堆

### 栈 ****后进先出（LIFO）****

### 树形结构

数据元素明显的层次关系

一对多

### 图形结构

节点之间的关系是任意的，图中任意两个数据都可能相关

多对多

### HashMap

<https://zhuanlan.zhihu.com/p/78079598>  
其内部每个元素都是 key-value 键值对

HashMap是Map 接口的实现，允许空的key-value,被认为是hashtable的增强版，是一个非线程安全的容器，无序的。

底层数据结构是数组+链表的结合体

HashMap 实例有两个很重要的因素，初始容量和负载因子，初始容量指的就是 hash 表桶的数量，负载因子是一种衡量哈希表填充程度的标准，当哈希表中存在足够数量的 entry，以至于超过了负载因子和当前容量，这个哈希表会进行 rehash 操作，内部的数据结构重新 rebuilt。

可以使用 Collections.synchronizedMap(new HashMap) 来创建一个线程安全的 Map。

### 链表

<https://zhuanlan.zhihu.com/p/668382648>

链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。链表中数据元素的逻辑顺序是通过链表中的指针链接次序实现的

#### 链表的数据类型

##### 单向链表

单链表的第一个节点的存储位置叫做头指针，最后一个节点的后继指针为空，一般用 NULL 或者 “^” 表示。  




Node{

int data;

头指针，顾名思义，是指向链表第一个结点的指针，如果有头结点的话，那么

就是指向头结点的指针。它是链表的必备元素且无论链表是否为空，头指针都不能为空

头结点，是放在第一个元素的节点之前，它的数据域一般没有意义，并且它本身也不是链表必须要带的。

##### 双向链表

双向链表，顾名思义，两个方向向的链表。相比起单链表来说，它多了一个前驱指针 prev  
Node{

int data;

Node next;

Node prev;

}



##### 循环链表

链表的尾节点指向头节点形成一个环，称为循环链表



##### 链表操作

删除节点，找到要删除的节点，查找过程中记录上一个节点的prev  
prev.next = current.next

删除头节点，直接把链表head节点指向next指针即可 self.head = self.head.next

更新节点  
current.data= new_data  
插入节点



#### 链表和数组的区别

#### 两者的区别

数组静态分配内存，链表动态分配内存。

数组在内存中是连续的，链表是不连续的。

数组利用下标定位，查找的时间复杂度是O(1)，链表通过遍历定位元素，查找的时间复杂度是O(N)。

数组插入和删除需要移动其他元素，时间复杂度是O(N)，链表的插入或删除不需要移动其他元素，时间复杂度是O(1)。

#### 数组的优点

随机访问性比较强，可以通过下标进行快速定位。

查找速度快

#### 数组的缺点

插入和删除的效率低，需要移动其他元素。

会造成内存的浪费，因为内存是连续的，所以在申请数组的时候就必须规定七内存的大小，如果不合适，就会造成内存的浪费。

内存空间要求高，创建一个数组，必须要有足够的连续内存空间。

数组的大小是固定的，在创建数组的时候就已经规定好，不能动态拓展。

#### 链表的优点

插入和删除的效率高，只需要改变指针的指向就可以进行插入和删除。

内存利用率高，不会浪费内存，可以使用内存中细小的不连续的空间，只有在需要的时候才去创建空间。大小不固定，拓展很灵活。

#### 链表的缺点

查找的效率低，因为链表是从第一个节点向后遍历查找。

### 二叉树

<https://juejin.cn/post/6872263119758950407>

<https://blog.csdn.net/baidu_40188909/article/details/108655710>

- 每个节点的度最大为2（最多拥有2棵子树）
- 左子树和右子树是有顺序的（有序树）
- 即使某节点只有一棵子树，也要区分左右子树



深度  
每个节点的深度与它左右子树的深度有关，且等于其左右子树最大深度值加上 1。即：

maxDepth(root) = max(maxDepth(root.left),maxDepth(root.right)) + 1

## Git命令

### Git 工作区、暂存区和版本库

[CS-Notes/Git.md at master · CyC2018/CS-Notes (github.com)](https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md)

<http://rogerdudler.github.io/git-guide/index.zh.html>

<https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md>  
<br/><https://deepinout.com/git/git-tutorial/19_git_cherry-pick_command_\_a_comprehensive_guide_to_its_usage.html>  

工作区：就是你在电脑里能看到的目录。

暂存区：英文叫stage, 或index。一般存放在"git目录"下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。

版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。  


### 提交代码

提交代码第一步 Git status 查看当前的状态

提交代码第二步 Git add .或者git add xxx提交代码到本地git缓冲区

提交代码第三步 git commit -m "修复XXbug" 推送代码修改到本地git库

提交代码第四步 git pull &lt;远程主机名&gt; &lt;远程分支名&gt; 取回远程主机某个分支更新再与本地指定的分支合并

提交代码第五步：git push &lt;远程主机名&gt; &lt;远程分支名&gt; (git push origin &lt;branch_name&gt;

)

git pull = git fetch + git merge

### 其他命令

$ git checkout -b dev  
Switched to a new branch 'dev'  
<br/>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：  
$ git branch dev  
$ git checkout dev  
Switched to branch 'dev'

查看分支：git branch  
创建分支：git branch &lt;name&gt;  
切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;  
创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;  
合并某分支到当前分支：git merge &lt;name&gt;  
删除分支：git branch -d &lt;name&gt;

HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。

场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。  
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。

当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；

在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。  
$ git cherry-pick feature  
<br/>上面代码表示将feature分支的最近一次提交，转移到当前分支。

如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。

多人协作的工作模式通常是这样：  
<br/>首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改；  
<br/>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；  
<br/>如果合并有冲突，则解决冲突，并在本地提交；  
<br/>没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！  
<br/>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。  
这就是多人协作的工作模式，一旦熟悉了，就非常简单。

### git reset

<https://initialcommit.com/blog/git-reset>

git reset --hard: Known as a hard reset, this updates the current branch tip to the specified commit, unstages any changes, and also deletes any changes from the working directory.  
Note that if you already pushed a set of changes to your remote repository such as on GitHub or BitBucket, you probably want to use the git revert command instead of reset.

### 删除分支

在本地删除一个分支： git branch -D &lt;本地分支&gt;  
在github远程端删除一个分支：

- - - 1. git push origin :&lt;远程端分支&gt;
            2.  git push origin --delete master

### Merge/rebase

<https://blog.csdn.net/u014600626/article/details/108690049>

Merge

git merge：将两个分支，合并结果提交为一个新提交，并且此新提交有2个parent。



Rebase

git rebase：会取消合并分支中的每个提交，并把他们临时存放，然后把当前分支更新到最新的origin分支，最后再把所有提交应用到分支上。

git rebase 可以把它理解成是“重新设置基线”，将你的当前分支重新设置开始点。这个时候才能知道你当前分支于你需要比较的分支之间的差异。  



### git push --mirror 项目迁移到新的仓库

\## 首先克隆现有的仓库为裸仓库

git clone --mirror <https://github.com/user/old-repo.git>

\## 进入克隆下来的裸仓库目录

cd old-repo.git

\## 添加新的远程仓库

git remote add new-origin <https://github.com/user/new-repo.git>

\## 将所有内容推送到新的远程仓库

git push --mirror new-origin

## 使用 PRPL 模式应用即时加载

PRPL 是一个首字母缩写词，它描述了一种用于使网页加载并变得更快的交互模式：

- 推送（或预加载）最重要的资源。
- 尽快渲染初始路线。
- 预缓存剩余资产。
- 延迟加载其他路由和非关键资产。
- [Preload](https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content)是一个声明性的 fetch 请求，它告诉浏览器尽快请求资源。通过在 HTML 文档的头部添加&lt;link&gt;标签rel="preload"来预加载关键资源：  
    <https://zhuanlan.zhihu.com/p/181623811>
- &lt;link rel="preload" as="style" href="css/style.css"&gt;
- 浏览器为资源设置了更合适的优先级，以便在不延迟window.onload事件的情况下尽快下载它。

## 面向对象

三个特征：

封装

把客观事物封装成抽象的类，然后可以设置public, private, protected访问权限

继承

通过继承创建子类或者派生类

有实现继承，接口继承

实现继承是指 使用基类的方法和属性无需额外编码

接口继承是指 使用基类方法和属性的名称，必须提供实现的能力

_多重继承可以通过多级继承实现_

多态性

允许将子类类型的指针赋值给父类类型的指针

覆盖和重载

覆盖是 子类重新定义基类虚函数的做法

重载是指。存在多个同名函数，而参数列表不同；

封装和继承是代码重用，多态是接口重用，为了类在继承和派生的时候使用家谱中任一类的实例的某一属性的正确调用

赋值是将某一数值或对象赋给某个变量的过程，分为下面 2 部分

- 基本数据类型：赋值，赋值之后两个变量互不影响
- 引用数据类型：赋**址**，两个变量具有相同的引用，指向同一个对象，相互之间有影响  

## Animation

**window.requestAnimationFrame()** 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

## Flex布局

flex: auto(1 1 auto) 或者flex none(0 0 auto)

flex: 1; 等同于 flex: 1 1 0;

### flex-grow

&lt;number&gt; /\*default 0\*/ 即如果有剩余空间也不放大。

如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

### flex-shrink

&lt;number&gt; /\*default 1\*/ 即如果空间不足。该项目将缩小。 flex-shrink属性为0时 表明不缩小。

### flex-basis

在分配剩余空间之前，项目占据的主轴空间。它的默认值为auto，即项目的本来大小。

## Flutter

<https://zhuanlan.zhihu.com/p/90836859>

是谷歌推出的移动UI 框架， 可以快速IOS和andriod上构建高质量的原生用户界面

1 跨平台 支持IOS/Andriod/WEB

2 热重载特性提高了开发效率

3 自绘UI引擎和编译成原生代码，高性能

4使用Dart语言，同时支持编译成Web代码

## JSBridge

<https://blog.csdn.net/yuzhengfei7/article/details/93468914>

给JS提供调用Native功能的接口， 让混合开发中的前端可以使用native的功能

核心是构建Native和非native间的双向消息通道

## Serverless

- **在某些场景可以解读为一种软件系统架构方法，通常称为 Serverless 架构**
- **而在另一些情况下，又可以代表一种产品形态，称为 Serverless 产品**

Serverless 架构: 依托于云厂商或云平台提供产品完成系统的组织及构建

&nbsp;Serverless 产品 代表的是无需理解、管理服务器，按需使用，按使用付费的产品。Serverless 产品中，其实也可以包含存储、计算等多种类型的产品。而典型的计算产品，就是云函数这种形态。

### Serverless 架构

Serverless 架构并不是完全没有服务器，而是指开发者无需关心底层基础设施的运维细节。云服务提供商负责管理和运维服务器，开发者只需要关注自己的应用程序逻辑。Serverless 架构可以分为几个层次：

#### FaaS（Function as a Service，函数即服务）

FaaS 是一种允许开发者上传单个函数并在特定事件触发时执行这些函数的服务。FaaS 的主要特点如下：

- ****事件驱动****：函数可以在特定事件发生时自动执行，例如文件上传、HTTP 请求等。
- ****无状态****：每个函数实例通常是短暂的，并且应该是无状态的。
- ****按需付费****：开发者只需为实际执行的时间和资源消耗付费。

示例：AWS Lambda

AWS Lambda 是一个典型的 FaaS 服务，开发者可以上传函数代码，并配置触发器（如 S3 文件上传、API Gateway 等），Lambda 会在事件发生时自动执行相应的函数。

#### BaaS（Backend as a Service，后端即服务）

BaaS 提供了一系列后端服务，通常包括数据库、身份验证、推送通知等功能。BaaS 的主要特点如下：

- ****集成服务****：提供了多种后端服务的集成，简化了后端开发工作。
- ****易于集成****：开发者可以通过简单的 API 调用或 SDK 来使用这些服务。
- ****托管服务****：云服务商管理所有基础设施，开发者只需要关注应用程序逻辑。

#### PaaS（Platform as a Service，平台即服务）

#### **PaaS（Platform as a Service，平台即服务）**

PaaS 提供了一个完整的开发和部署环境，包括操作系统、数据库、网络等基础设施。PaaS 的主要特点如下：

- ****完整的开发环境****：提供了一套完整的开发工具和运行环境。
- ****自动化部署****：支持自动化部署和持续集成/持续部署（CI/CD）。
- ****高度可定制****：相比 FaaS 和 BaaS，PaaS 提供了更多的定制选项。

#### **区别**

- ****FaaS****：专注于单个函数级别的执行，适合处理微小的、事件驱动的任务。
- ****BaaS****：提供了一系列后端服务的集成，适合快速构建具有复杂后端需求的应用程序。
- ****PaaS****：提供了一个完整的开发和部署平台，适合构建较大规模的应用程序，并提供了更多的定制选项。

#### **应用场景**

- ****FaaS****：适用于需要快速响应事件的小型任务，如数据处理、文件转换等。
- ****BaaS****：适用于需要快速集成多种后端服务的移动应用或 Web 应用。
- ****PaaS****：适用于需要高度定制化和自动化的开发和部署流程的企业级应用程序。

## 精读前后端渲染之争

<https://github.com/dt-fe/weekly/blob/v2/003.%E7%B2%BE%E8%AF%BB%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%B9%8B%E4%BA%89.md>

## 事件驱动和数据驱动

事件驱动（Event-driven）和数据驱动（Data-driven）是两种常见的编程模型或设计模式，它们各自有不同的应用场景和特点。下面我们详细探讨这两种模型的区别和应用场景。

### 事件驱动（Event-driven）

事件驱动是一种编程模型，其中程序的执行是由外部事件触发的。这些事件可以是用户操作（如点击按钮）、系统事件（如文件系统的更改通知）、网络请求等。在这种模型中，程序并不主动执行任务，而是等待事件的发生，然后根据事件做出响应。

#### 特点

非阻塞：程序不会因为等待某个事件的发生而停止执行其他任务。

异步：事件的处理通常是异步的，事件发生时可以立即做出响应。

响应式：程序可以根据发生的事件快速做出响应。

解耦：事件的生产者和消费者通常是解耦的，这有助于提高系统的灵活性和可扩展性。

#### 应用场景

用户界面：GUI 应用程序通常采用事件驱动模型，用户操作（如点击、拖拽等）会触发相应的事件。

网络编程：服务器端的网络编程（如 Web 服务器）通常采用事件驱动模型，客户端请求会触发服务器上的事件处理。

物联网（IoT）：设备之间的通信通常采用事件驱动模型，设备状态的变化会触发相应的事件处理。

游戏开发：游戏中的交互通常也是事件驱动的，玩家的动作会触发游戏中的相应事件。

document.getElementById('myButton').addEventListener('click', function() {

console.log('Button clicked!');

});

在这个示例中，当用户点击按钮时，会触发一个点击事件，然后执行回调函数。

### 数据驱动（Data-driven）

数据驱动是一种编程模型，其中程序的执行流程和决策逻辑是根据数据来决定的。在这种模型中，程序的逻辑通常是围绕着数据的处理和分析展开的。

#### 特点

基于数据：程序的执行主要依赖于数据的状态，而不是外部事件。

可预测性：程序的行为通常更加可预测，因为它是基于数据的逻辑而不是外部事件。

灵活性：可以通过改变数据来改变程序的行为，而无需修改代码。

批量处理：适用于需要处理大量数据的场景，如数据分析、报表生成等。

#### 应用场景

数据分析：数据驱动的模型非常适合处理大量的数据集，从中提取有用的信息。

报告生成：根据数据生成报表或图表，数据驱动的模型可以动态地根据数据生成不同的报告格式。

配置管理：应用程序的配置通常采用数据驱动的方式，通过配置文件或数据库中的数据来控制程序的行为。

机器学习：训练机器学习模型的过程通常是数据驱动的，模型的训练和预测都是基于数据集来进行的。

示例代码

python

浅色版本

data = \[

{'name': 'Alice', 'age': 30},

{'name': 'Bob', 'age': 25},

{'name': 'Charlie', 'age': 35}

\]

def process_data(data):

for person in data:

if person\['age'\] > 30:

print(f"{person\['name'\]} is over 30 years old.")

process_data(data)

在这个示例中，程序根据数据集中的年龄信息来判断哪些人超过了 30 岁，并输出相应的信息。

### 区别

#### 触发方式

事件驱动：程序的执行由外部事件触发。

数据驱动：程序的执行主要依赖于数据的状态。

#### 执行模式

事件驱动：通常是异步的，非阻塞的。

数据驱动：通常是同步的，按照数据的逻辑顺序执行。

适用场景：

事件驱动：适用于需要快速响应外部事件的应用场景。

数据驱动：适用于需要根据数据做出决策的应用场景。

结合使用

在实际应用中，事件驱动和数据驱动往往是结合使用的。例如，在 Web 开发中，用户界面通常采用事件驱动模型来响应用户的操作，而在后台处理数据时，则采用数据驱动模型来处理数据集。

## IndexDB 实践

由浏览器支持 用来存储大量数据

支持事务

支持索引

Key-value

对DB 的操作是异步的

## Blob

Blob 对象表示一个不可变，原始数据的类文件对象。 可以按文本或二进制的格式进行读取，也可以转换成 [ReadableStream](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 来用于数据操作。

[File](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。

## Docker

[http://www.alloyteam.com/2019/07/13885/#prettyPhoto](http://www.alloyteam.com/2019/07/13885/"%20\l%20"prettyPhoto)

使用 Linux Namespace 进行网络、进程空间、命名空间等资源的隔离，使用 Cgroups 技术对资源的占用、使用量进行限制，使用 AUFS 等存储驱动来实现分层结构、增量更新等能力

虚拟机依赖硬件设备来提供资源隔离，需要更大的资源开销

不同于虚拟机提供在物理硬件级别的操作系统隔离，容器技术提供的是操作系统级别的进程隔离，Docker 本身只是操作系统的一个进程，只是在容器技术下，进程之间网络、空间等等是隔离的，互不知道彼此。

### 利用 linux Namespace 来实现独立环境

- **Mount Namespace** - 用于隔离文件系统的挂载点
- **UTS Namespace** - 用于隔离 HostName 和 DomianName
- **IPC Namespace** - 用于隔离进程间通信
- **PID Namespace** - 用于隔离进程 ID
- **Network Namespace** - 用于隔离网络
- **User Namespace** - 用于隔离用户和用户组 UID/GID

### Linux Namespace API

### Docker 的资源限制：cgroups

因此除了 Namespace 隔离，还需要通过另外一种技术来限制进程资源使用大小情况：cgroups(control groups)。

### Docker 存储驱动：Union File Systems

#### 1、AUFS

其实在有了 Namespace 和 cgroups 的情况下，对于 Docker 项目的初始化可以简单抽象为：

1. 启动 Namespace 配置
2. 设置 cgroups 参数，对资源进行限制
3. 切换进程的根目录

Docker 中最典型的存储驱动就是 AUFS（Advanced Multi-layered unification filesytem），可以将 AUFS 想象为一个可以 “栈式叠加” 的文件系统，AUFS 允许在一个基础的文件系统的上，“增量式” 的增加文件。

## Responsive/images

1．使用相对尺寸，

&nbsp; max-width: 100%;

2\. 高 DPI 设备上使用 srcset 来增强 img

&lt;img src="photo.png" srcset="<photo@2x.png> 2x" ...&gt;

3\. 使用picture  
picture 元素定义了一个声明性解决办法，可根据设备大小、设备分辨率、屏幕方向等不同特性来提供一个图像的多个版本。

&lt;picture&gt;  
  &lt;source media="(min-width: 800px)" srcset="head.jpg, head-2x.jpg 2x"&gt;  
  &lt;source media="(min-width: 450px)" srcset="head-small.jpg, head-small-2x.jpg 2x"&gt;  
  &lt;img src="head-fb.jpg" srcset="head-fb-2x.jpg 2x" alt="a head carved out of wood"&gt;  
&lt;/picture&gt;

4\. 压缩图像

压缩的图像技术可以给所有设备提供一个高度压缩的 2x 图像，

5.Svg  
使用 SVG 可在网页中包含自适应矢量图像。  
6\. Dataurl

通过 Data URI 可以添加文件，如图像，使用以下格式将 img 元素的 src 设置为 Base64 编码的字符串进行内联:

&lt;img src="data:image/svg+xml;base64,\[data\]"&gt;  
7\. 使用 image-set 提供高分辨率图像

background-image: image-set(  
  url(icon1x.jpg) 1x,  
  url(icon2x.jpg) 2x  
);

8 缓存。雪碧图。使用 CSS 替换图像

## Rem/em

rem r 是 root 的意思，就是相对于根节点来进行缩放是相对于根元素&lt;html&gt;，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高. 根据不同屏幕大小设置不同的html font-size;  
<http://caibaojian.com/web-app-rem.html>  
<br/>html{

font-size:20px;

}

.btn {

width: 6rem;

height: 3rem;

line-height: 3rem;

font-size: 1.2rem;

display: inline-block;

background: #06c;

color: #fff;

border-radius: .5rem;

text-decoration: none;

text-align: center;

}  


Em  
用户的浏览器默认渲染的文字大小是“16px”  
em”是一个相对的大小，我们可以这样来设置1em，0.5em，1.5em等  
如果你将其子元素的字体大小设置为“0.75em”，那么其字体大小计算出来后就相当于“0.75 X 16px = 12px”；

vw 和 vh

全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于  
屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的  
话 vh 单位更好。  
说明：

1 个 vw 相当于页面宽度的 1%，比如页面宽度是 1000px，那么 1vw

就是 10px，vh 同理。

P 标签的宽度是 50vw，所以就是页面宽度的 50%，高度是 50vh，所以就

是页面高度的 50%。



## Learnsite

[https://github.com/dextery](https://github.com/dexteryy/spellbook-of-modern-webdev#html5--web-apis)[y/spellboo](https://github.com/dexteryy/spellbook-of-modern-webdev#html5--web-apis)[k](https://github.com/dexteryy/spellbook-of-modern-webdev#html5--web-apis)[\-of-modern-webdev#html5--web-apis](https://github.com/dexteryy/spellbook-of-modern-webdev#html5--web-apis)  
<br/><https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking>  
<br/><https://web.dev/secure>  
<br/><https://w3c.github.io/using-aria/>  
<br/><br/><https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_templates_and_slots>

<https://developers.google.com/web/fundamentals/web-components/customelements>  
<br/><https://alistapart.com/article/web-animation-past-present-and-future/>  
<br/><br/><https://codelabs.developers.google.com/codelabs/webrtc-web/#3>  
<br/><https://github.com/you-dont-need/You-Dont-Need-JavaScript>  
<br/><https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API>  
<br/><https://developers.google.com/web/fundamentals/design-and-ux/responsive/images>  
<br/><https://rxjs-cn.github.io/learn-rxjs-operators/>  
internet  
<https://hpbn.co/>  
<https://segmentfault.com/a/1190000042311288>  

http api design guide  
<https://github.com/ZhangBohan/http-api-design-ZH_CN>  
<br/><http://blog.404mzk.com/beforeunloadunload.html>

字体反爬的攻与防

Performance  
<https://zhuanlan.zhihu.com/p/350657764>  
<https://web.dev/fcp/>

<https://cjting.me/2020/07/01/douyu-crawler-and-font-anti-crawling/>  
掌握Shell编程  
<https://zhuanlan.zhihu.com/p/102176365>

安全指南  
<https://github.com/Tencent/secguide>

前端部署  
<https://mp.weixin.qq.com/s/E8UXYrJMY3AqBrprxfJ-3A>  
<br/>web3  
<https://mp.weixin.qq.com/s/-yWw1qJ2hcpno62ibmtJCQ>  
<br/><https://codepen.io/2022/popular/pens/>  

区块链  
<https://www.theblockbeats.info/report>  
<br/>design  
<https://www.yuque.com/wikidesign/ykf0s9>  
<br/>音视频开发  
<https://mp.weixin.qq.com/s/oFXvXb0Lr_wETmHn7GqJxA>

## LeetCode  



## SQL

[面向初学者的 SQL 学习资源 ·GitHub](https://gist.github.com/momer/19a159ffc336a047b2fa)  
[CyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计 (github.com)](https://github.com/CyC2018/CS-Notes)  
[SQL Server ASCII() Function (w3schools.com)](https://www.w3schools.com/SQL/func_sqlserver_ascii.asp)  
[Online SQL Editor (programiz.com)](https://www.programiz.com/sql/online-compiler/)

- CREATE TABLE creates a new table.
- INSERT INTO adds a new row to a table.
- SELECT queries data from a table.
- ALTER TABLE changes an existing table.
- UPDATE edits a row in a table.
- DELETE FROM deletes rows from a table.

## Express

基于 Node.js 平台，快速、开放、极简的 Web 开发框架, 可以快速地搭建一个完整功能的网站  


<br/>启动此应用：  
express myapp自动创建一个名为test 的express  
$env:DEBUG='myapp:\*'; npm start  
<br/>自定义project  
mkdir my app

npm init

npm install express

node index.js

## MySQL

MySQL是一个数据库管理系统  
MySQL 数据库是关系型的  
MySQL 软件是开源的。  
<https://dev.mysql.com/doc/refman/8.0/en/connecting-disconnecting.html>  
<br/>apache

Redis

## 代理服务器

我们知道在 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。

当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。

那代理服务器到底是用来做什么的呢？

功能

负载均衡客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性hash、LRU\`\`(最近最少使用)等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。

保障安全利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。

缓存代理将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。

## 解释性语言和编译型语言

1\. 编译型语言（Compiled Languages）

编译型语言的代码在执行之前需要经过一个编译过程，将源代码转换成机器码或字节码。编译后的程序可以直接在目标平台上运行。

特点：

编译过程：在程序运行之前，源代码通过编译器被转化为机器码或字节码。编译器通常会生成一个可执行文件（如 Windows 下的 .exe 文件）。

静态类型：编译型语言通常采用静态类型系统，这意味着变量的类型在编译时就已经确定。

执行效率：由于编译后的代码直接运行在操作系统上，所以编译型语言的执行效率较高。

平台相关性：编译后的程序通常是针对特定平台的，如果要在另一个平台上运行，可能需要重新编译。

调试和修改：一旦程序被编译，修改源代码需要重新编译才能生效。

示例：

C/C++：广泛应用于系统编程、游戏开发等领域。

Rust：一种注重安全性和性能的语言，用于系统编程。

Swift：苹果公司开发的用于 iOS 和 macOS 应用开发的语言。

2\. 解释型语言（Interpreted Languages）

解释型语言的代码不需要预先编译，而是直接由解释器逐行解释并执行。每次运行程序时，解释器都会读取源代码，并将其翻译成机器指令执行。

特点：

解释过程：每次运行程序时，解释器会逐行读取源代码并执行，无需事先编译。

动态类型：解释型语言通常采用动态类型系统，变量的类型在运行时确定。

执行效率：由于每次运行都需要解释，解释型语言的执行效率通常低于编译型语言。

跨平台性：解释型语言通常具有更好的跨平台能力，因为解释器可以在不同的平台上运行同样的源代码。

调试和修改：可以随时修改源代码并立即运行新的版本，无需重新编译。

示例：

Python：广泛应用于科学计算、数据分析等领域。

JavaScript：主要应用于 Web 开发，运行在浏览器中。

Ruby：一种用于 Web 开发和其他领域的脚本语言。

3\. 混合型语言（Hybrid Approach）

近年来，很多语言采用了混合型方法，结合了编译型语言和解释型语言的优点。例如，Java 和 C## 使用了中间代码（字节码），在运行时由虚拟机解释执行。这种方法既提高了执行效率，又保留了跨平台的优点。

特点：

字节码：源代码被编译成字节码，而不是直接的机器码。

虚拟机：字节码由虚拟机解释执行，虚拟机负责将字节码转换成具体的机器指令。

JIT 编译：一些虚拟机（如 Java 的 JVM）使用即时编译（JIT Compilation）技术，在运行时将热点代码编译成本地机器码，从而提高执行效率。

示例：

Java：编译成字节码，由 JVM 解释执行。

C#：编译成 MSIL（微软中间语言），由 CLR（公共语言运行时）解释执行。

总结

编译型语言和解释型语言各有优缺点，选择哪种语言取决于具体的应用场景和需求。编译型语言通常更适合需要高性能的应用，而解释型语言则更适合需要快速开发和迭代的应用。随着技术的发展，越来越多的语言采用了混合的方法，以平衡开发效率和运行效率。

## 空间复杂度和时间复杂度

时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。

随着n的不断增大，时间复杂度不断增大，算法花费时间越多。

#### 常见的时间复杂度

- 常数阶O(1)
- 对数阶O(log2 n)
- 线性阶O(n)
- 线性对数阶O(n log2 n)
- 平方阶O(n^2)
- 立方阶O(n^3)
- k次方阶O(n^K)
- 指数阶O(2^n)

#### 计算方法

- 选取相对增长最高的项
- 最高项系数是都化为1
- 若是常数的话用O(1)表示

举个例子：如f(n)=3\*n^4+3n+300 则 O(n)=n^4

通常我们计算时间复杂度都是计算最坏情况。计算时间复杂度的要注意的几个点:

- 如果算法的执行时间不随n的增加而增长，假如算法中有上千条语句，执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。

举例如下：代码执行100次，是一个常数，复杂度也是O(1)。

let x = 1; while (x <100) { x++; }

- 有多个循环语句时候，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的方法决定的。

举例如下：在下面for循环当中，外层循环每执行一次，内层循环要执行n次，执行次数是根据n所决定的，时间复杂度是O(n^2)。

for (i = 0; i < n; i++){ for (j = 0; j < n; j++) { // ...code } }

- 循环不仅与n有关，还与执行循环判断条件有关。

举例如下：在代码中，如果arr\[i\]不等于1的话，时间复杂度是O(n)。如果arr\[i\]等于1的话，循环不执行，时间复杂度是O(0)。

for(var i = 0; i<n && arr\[i\] !=1; i++) { // ...code }

空间复杂度是对一个算法在运行过程中临时占用存储空间的大小。

#### 计算方法

- 忽略常数，用O(1)表示
- 递归算法的空间复杂度=(递归深度n)\*(每次递归所要的辅助空间)

仅仅只复制单个变量，空间复杂度为O(1)。

举例如下：空间复杂度为O(n) = O(1)。

let a = 1; let b = 2; let c = 3; console.log('输出a,b,c', a, b, c);

递归实现，调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O(n\*1) = O(n)。

function fun(n) { let k = 10; if (n == k) { return n; } else { return fun(++n) } }

## Electron

#### **主要特性**

##### **1. **跨平台支持****

Electron 支持 Windows、macOS 和 Linux，可以使用相同的代码库构建跨平台应用。

##### **2. **Node.js 集成****

主进程可以直接使用 Node.js 的所有功能，包括文件系统操作、网络请求等。

##### **3. **Chromium 渲染引擎****

渲染进程使用 Chromium 渲染引擎，支持现代 Web 技术，如 HTML5、CSS3 和 JavaScript。

##### **4. **丰富的 API****

Electron 提供了丰富的 API，用于创建和管理窗口、菜单、系统托盘图标、通知等。

#### win.loadURL 和 win.loadFile

开发阶段：

如果你正在开发一个基于 React、Angular 或其他前端框架的应用，通常会使用 win.loadURL 加载本地开发服务器上的内容。这样可以利用热重载和其他开发工具。

例如，React 应用通常使用 win.loadURL('<http://localhost:3000')。>

生产阶段：

当你打包应用并发布时，通常会使用 win.loadFile 加载本地文件。这样可以确保应用在没有网络连接的情况下也能正常运行。

例如，打包后的应用通常使用 win.loadFile(path.join(\__dirname, 'index.html'))。

#### Demo

主进程 (main.js)：

使用 ipcMain.on 监听 show-dialog 通道。

当收到消息时，显示一个消息对话框，并将结果发送回渲染进程。

前端预加载脚本 (preload.js)：

使用 contextBridge 暴露 send 和 receive 方法，允许渲染进程安全地使用 ipcRenderer。

渲染进程 (renderer.js)：

通过 electronAPI.send

#### preload.js

当 contextIsolation 选项设置为 true 时，渲染进程和主进程之间的通信是隔离的。这提高了应用的安全性，防止潜在的 XSS 攻击。

这时候 ipcRenderer.send 不会生效

在 preload.js 中，使用 contextBridge 暴露一个方法，该方法使用 ipcRenderer.send 发送消息。



#### 渲染进程使用暴露的方法  



#### main.js



#### electron-builder

是一个非常强大的工具，用于打包和构建 Electron 应用。



基本配置

appId:

应用的唯一标识符，用于在操作系统中注册应用。

例如："appId": "com.example.my-electron-app"

directories:

指定构建输出目录。

例如："output": "dist"

files:

列出需要包含在构建包中的文件和目录。

例如："files": \["main.js", "index.html", "renderer.js", "preload.js", "node_modules/\*\*/\*"\]

平台特定配置

win:

配置 Windows 构建选项。

例如："target": "nsis" 表示生成 NSIS 安装包。

mac:

配置 macOS 构建选项。

例如："target": "dmg" 表示生成 DMG 安装包。

linux:

配置 Linux 构建选项。

例如："target": "AppImage" 表示生成 AppImage 安装包。

#### process.platform

这是一个 Node.js 提供的属性，返回当前操作系统的平台名称。常见的值包括：

'darwin'：表示 macOS。

'win32'：表示 Windows。

'linux'：表示 Linux。



这段代码确保了在非 macOS 平台上，当所有窗口都关闭时，应用会完全退出。

#### **ipcMain 和ipcRenderer**

ipcMain 和 ipcRenderer 是 Electron 中用于在主进程和渲染进程之间进行通信的两个重要模块。它们通过 Inter-Process Communication (IPC) 机制实现了进程间的双向通信。下面详细介绍这两个模块及其用法。

ipcMain 模块在主进程中使用，用于监听来自渲染进程的消息，并处理这些消息。

ipcRenderer 模块在渲染进程中使用，用于向主进程发送消息，并接收主进程的响应

#### ipcRenderer.invoke 和 ipcRenderer.send

ipcRenderer.send 是一个异步方法，用于从渲染进程向主进程发送消息。主进程可以通过 ipcMain.on 或 ipcMain.addListener 监听这些消息，并进行相应的处理。send 方法不等待主进程的响应，而是立即返回。

ipcRenderer.invoke 是一个同步方法（尽管它是异步的，但会等待主进程的响应），用于从渲染进程向主进程发送消息并等待主进程的响应。主进程可以通过 ipcMain.handle 处理这些请求，并返回结果。invoke 方法会等待主进程的响应，然后返回结果。

#### MessagePort



例子

Main.js  


Preload.js



renderer.js



Index.html



## 可视化

#### Svg 和 canvas

##### **SVG (Scalable Vector Graphics)**

- ****基于 XML****：SVG 是一种基于 XML 的矢量图形格式。
- ****分辨率独立****：SVG 图形可以无损缩放，适合高分辨率屏幕和打印。
- ****DOM 访问****：每个 SVG 元素都是 DOM 节点，可以单独访问和操作。
- ****适合复杂图形****：适合创建复杂的、交互性强的图表和图形。

##### **Canvas**

- ****基于像素****：Canvas 是一个位图画布，使用 JavaScript 绘制图形。
- ****分辨率依赖****：Canvas 图形在放大时可能会失真，不适合高分辨率屏幕和打印。
- ****绘图上下文****：Canvas 提供了一个 2D 绘图上下文，所有绘图操作都通过这个上下文进行。

#### Echarts 和 d3

使用echarts绘图更加简单。使用D3绘图更加灵活，容易定制，同时它要求你理解更多东西，所以学习曲线会比较陡峭。

D3.js 主要用于操作 SVG，但它也可以用于操作 Canvas 元素

#### D3.js 和 GoJS

D3

1.D3.js 主要使用 SVG 进行绘图

2.复杂图表：适合创建复杂的图表，如散点图、热力图、树状图、桑基图等。

GoJS

1.高性能：

GoJS 主要使用 &lt;canvas&gt; 进行绘图，提供了高效的绘图性能，特别是在处理大量图形和复杂动画时。适合创建高性能的图表和可视化。

2.丰富的内置功能：

GoJS 提供了丰富的内置功能和预定义的图表类型，如流程图、组织结构图、网络拓扑图等。

易于使用：

GoJS 提供了高层次的 API，使得开发者可以快速创建复杂的图表，而不需要深入了解底层绘图细节。

适用于

- ****复杂图表和流程图****：适合创建复杂的图表和流程图，如组织结构图、流程图、网络拓扑图等。
- ****高性能需求****：适合需要高性能的图表和可视化，特别是在处理大量数据和复杂动画时。

#### Gojs

性能：&lt;canvas&gt; 提供了更高的绘图性能，特别是在处理大量图形和复杂动画时。&lt;canvas&gt; 是一个位图，所有的绘图操作都在内存中进行，然后一次性绘制到屏幕上，这比 SVG 的 DOM 操作更高效。

内存管理：&lt;canvas&gt; 可以更好地管理内存，特别是在处理大量数据和复杂图表时。SVG 的每个元素都是一个 DOM 节点，当元素数量增加时，DOM 的管理和渲染开销会显著增加。

灵活性：&lt;canvas&gt; 提供了更多的低级绘图控制，使得开发者可以实现更复杂的绘图效果和优化。

基本使用  
1.初始化 Diagram：

使用 go.GraphObject.make 函数创建 GoJS 对象。

设置图表的容器为 myDiagramDiv。

配置图表的默认布局为树形布局（TreeLayout）。

允许用户删除和复制节点。

2.定义节点模板：

使用 go.Node 创建节点。

使用 go.Shape 创建节点的形状，设置填充颜色和边框颜色。

使用 go.TextBlock 创建节点的文本块，并绑定文本到节点的 key 属性。

3.定义链接模板：

使用 go.Link 创建链接。

设置链接的路由方式为正交路由（Orthogonal），并设置拐角半径。

使用 go.Shape 创建链接的线条，设置线条宽度和颜色。

4.添加初始数据：

使用 go.TreeModel 创建树形模型。

添加一些初始节点数据，包括节点的键（key）、颜色（color）和父节点（parent）。

功能

- ****拖放操作****：允许用户拖动节点。
- ****动态更新****：可以在运行时动态添加、删除和修改节点和链接。
- ****自定义样式****：可以自定义节点和链接的样式。
- ****动画效果****：可以添加动画效果，使图表更加生动。
- ****工具提示****：可以为节点和链接添加工具提示。
- ****事件处理****：可以处理各种事件，如点击、双击、鼠标悬停等



## 编程  

#### 懒加载实现

###

  
<br/>压缩图片  




#### 深克隆浅克隆

浅克隆是指只复制对象的一层结构，即如果源对象中的属性是引用类型（如数组、对象等），那么浅克隆后的新对象中的这些属性将仍然指向原对象中对应的属性的内存地址。这意味着，对新对象中这些属性的修改会影响到原对象。

##### 浅克隆  

使用Object.assign()

let obj1 = { a: 1, b: { c: 2 } };

let obj2 = Object.assign({}, obj1);

扩展运算符 (...):

let obj1 = { a: 1, b: { c: 2 } };

let obj2 = { ...obj1 };

**方法  
**//在Object类的原型中添加一个克隆方法

**Object.prototype.clone = function() {**

//根据情况创建数组对象或者普通object对象

**Var obj = this instanseof Array ? \[\]:{};**

//遍历当前对象的成员，赋给新对象

**for(prop in this){**

**obj\[prop\] = this\[prop\]**

}

**return obj;**

}

##### 深克隆

JSON.parse(JSON.stringify） 不copy 原型链

let obj1 = { a: 1, b: { c: 2 } };

let obj2 = JSON.parse(JSON.stringify(obj1));

第三方的库  
loadash

自定义

**//在Objectl类的原型中中添加一个克隆方法**

**Object.Prototype.clone = function {**

//根据情况创建一个数组或者普通object对象

**Var obj = this instanseof Array ? \[\]:{}**

//遍历当前对象的成员 赋给新对象

**for(prop in this){**

//如果当前成员是对象类型

**If（typeof this\[prop\] === ‘object’）**

**obj\[prop\] = this\[prop\].clone();**

**else**

**obj\[ prop\] = this\[prop\]**

**}**

**Return obj;**

**性能优化  
**

#### 节流与防抖（throttle和debounce）

##### Throttle

规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行

场景： 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断

实现设置一个参数，执行完毕才为true， 如果为false 不继续执行去下

//节流throttle代码：

function throttle(fn,delay) {

let canRun = true; // 通过闭包保存一个标记

return function () {

// 在函数开头判断标记是否为true，不为true则return

if (!canRun) return;

// 立即设置为false

canRun = false;

// 将外部传入的函数的执行放在setTimeout中

setTimeout(() => {

// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。

// 当定时器没有执行的时候标记永远是false，在开头被return掉

fn.apply(this, arguments);

canRun = true;

}, delay);

};

}

function sayHi(e) {

console.log('节流：', e.target.innerWidth, e.target.innerHeight);

}

##### Debounce

在事件被触发n秒后再执行

触发多次只执行一次（input 输入，**onresize**）

每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法

//防抖debounce代码：

function debounce(fn,delay) {

var timeout = null; // 创建一个标记用来存放定时器的返回值

return function (e) {

// 每当用户输入的时候把前一个 setTimeout clear 掉

clearTimeout(timeout);

// 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数

timeout = setTimeout(fn

, delay);

};

}

// 处理函数

function handle() {

console.log('防抖：', Math.random());

}

#### 实现promise.all  



## 计算机基础

### 进程间通信（IPC）

进程间通信（IPC）是操作系统提供的一种机制，允许不同的进程之间交换数据和信息。以下是几种常见的IPC方式的详细介绍：

##### 1\. 管道（Pipes）

- ****定义****：管道是一种半双工的通信方式，意味着它只能在一个方向上传输数据。一个进程写入管道的数据可以被另一个进程读取。
- ****使用场景****：适用于父子进程之间的简单通信。例如，在Unix/Linux系统中，通过命令行组合多个命令时经常使用管道。
- ****局限性****：管道只支持单向通信，并且通常限于具有亲缘关系的进程之间。

##### 2\. 消息队列（Message Queues）

- ****定义****：消息队列是一个存储消息的链表，存放在内核中并由消息队列标识符标识。进程可以向队列中添加消息或从队列中读取消息。
- ****特点****：
  - 支持多对多通信模式，即多个发送者和接收者。
  - 数据以消息的形式传递，每个消息都有固定的格式和长度限制。
  - 提供了同步和异步两种操作模式。
- ****优点****：灵活、可靠，适合复杂的应用程序架构。

##### 3\. 共享内存（Shared Memory）

- ****定义****：共享内存允许两个或更多的进程访问同一块物理内存区域。这使得它们能够快速地交换大量数据。
- ****实现****：需要结合其他同步机制（如信号量）来避免竞态条件和其他并发问题。
- ****优势****：效率极高，因为不需要额外的数据拷贝过程；非常适合频繁的数据交换场景。
- ****风险****：由于直接共享内存地址空间，如果管理不当可能导致严重的错误，如段错误或数据损坏。

##### 4\. 信号（Signals）

- ****定义****：信号是一种特殊的软中断通知机制，用来告知进程发生了某些事件（如用户按下Ctrl+C终止程序）。每个信号都有一个编号，并且可以在进程间发送。
- ****处理****：接收方可以通过注册信号处理器来定义当收到特定信号时应采取的动作。
- ****用途****：主要用于异常情况下的通知，如进程终止、定时器超时等。

##### 5\. 套接字（Sockets）

- ****定义****：套接字提供了网络上的进程间通信接口，不仅限于同一台机器上的进程，还可以跨越不同主机进行通信。
- ****类型****：
  - 流式套接字（Stream Sockets）：基于TCP协议，提供面向连接的可靠服务。
  - 数据报套接字（Datagram Sockets）：基于UDP协议，无连接且不可靠，但延迟较低。
- ****应用广泛****：Web服务器与客户端之间的HTTP请求/响应、电子邮件传输（SMTP）、文件传输（FTP）等都依赖于套接字。

#### **Socket 与网络进程通信**

- ****关系****：Socket是一种抽象层，它为应用程序提供了访问底层网络协议的能力，使得不同主机上的进程可以通过网络相互通信。
- ****连接过程****：
  - 客户端发起TCP三次握手以建立连接。
  - 数据传输阶段：双方通过已建立的连接交换数据。
  - 断开连接：客户端或服务器发送FIN包来终止会话，随后进行四次挥手断开连接。

### JS引擎

主要由两部分组成：

内存堆：内存分配发生的地方

调用栈：代码执行的地方

 JavaScript 是一门单线程的语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。

调用栈是一种数据结构，它记录了我们在程序中的位置。

我们还有很多引擎之外的 API，我们把这些称为浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout等等。

### 垃圾回收的基本原理

##### 标记-清除（Mark and Sweep）

标记：从根对象（如全局变量、栈中的局部变量等）出发，递归地遍历所有可达对象，并标记这些对象。

清除：扫描整个堆内存，释放未被标记的对象所占用的内存。

##### 引用计数（Reference Counting）

每个对象都有一个引用计数器，每当有一个新的引用指向该对象时，计数器加1；每当有一个引用被移除时，计数器减1。

当引用计数器为0时，对象被释放。

缺点：无法处理循环引用的问题。

##### 分代收集（Generational Collection）

将堆内存分为不同的代（如新生代和老年代），不同代的垃圾回收策略不同。

新生代：频繁进行小规模的垃圾回收，因为新分配的对象往往生命周期较短。

老年代：较少进行大规模的垃圾回收，因为老对象往往生命周期较长。

##### 标记-压缩

1. ****标记****：与标记-清除相同。
2. ****压缩****：将存活的对象移动到连续的内存区域，以减少内存碎片。

##### 垃圾回收的挑战

1. ****性能开销****：垃圾回收过程会消耗 CPU 和内存资源，可能导致应用程序短暂的停顿。
2. ****内存碎片****：频繁的垃圾回收可能导致内存碎片，影响内存分配效率。
3. ****循环引用****：引用计数机制无法处理循环引用的问题，需要额外的机制来检测和处理。

### 单线程的JS

单线程的优势

简化了编程模型：避免了多线程编程中的许多复杂问题，如死锁、竞争条件等。开发者不需要担心多个线程之间的同步问题8。

减少了上下文切换开销：传统多线程应用中，频繁的线程创建、销毁及上下文切换会消耗大量CPU时间片。而单线程模式则避免了这些问题7。

高效处理高并发请求：对于I/O密集型任务，单线程的非阻塞I/O和事件驱动机制可以显著提高吞吐量，减少等待时间4。

内存占用低：相比为每个连接分配独立线程的传统方式，单线程模型大大降低了内存消耗，理论上能够支撑更多的并发用户1。

单线程的局限性

不适合CPU密集型任务：长时间运行的计算任务（例如复杂的数学运算或图像处理）会导致主线程被阻塞，影响其他I/O操作的响应速度16。

可靠性挑战：一旦单线程发生未捕获的异常，整个进程可能会崩溃，进而导致服务中断。因此，需要额外的措施来保证系统的稳定性和容错能力15。

不能充分利用多核CPU：标准的单线程应用仅利用了一个CPU核心，无法自动并行化到多核处理器上。不过，可以通过Cluster模块或其他多进程管理工具来部分解决这个问题19。

调试难度较大：由于缺乏多线程环境中常见的调试工具和技术，某些类型的错误可能更难以定位和修复4。

### 同步任务 和异步任务



1在执行过程中，同步和异步任务分别进入不同的执行场所，同步的是进入主线程，异步的进入Event Table并注册函数

2指定的事情完成时，Event Tabel 会将这个函数移入Event Quene

3主线程内的任务执行完毕时为空，会将Event Queue读取对应函数，进入主线程执行

4以上过程重复时，就是Event Loop

let data = \[\];

$.ajax({ url:www.javascript.com, data:data, success:() => {

console.log('发送成功!');

} })

console.log('代码执行结束');

1ajax 进入Event table注册回调函数Success

2执行console.log('代码执行结束');

3 ajax事件完成，回调函数success进入Event Quene.

4主线程从Event Quene读取回调函数并执行

除了广义的同步任务和异步任务还有

Macro-task(宏任务) 包括整体的script,setTimeout,setInterval

Micro-task(微任务)； promise, process.nextTick

setImmediate 的回调会在当前事件循环的所有同步和异步操作完成后执行，也就是 Check 阶段。这意味着它会在 setTimeout 的回调之前执行，但晚于 process.nextTick 的回调。

异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在  
<br/>

JavaScript 的执行顺序遵循以下规则：

同步代码：首先执行宏任务中的同步代码。

微任务队列：在当前宏任务的 JavaScript 代码执行完成后，立即执行所有的微任务。

下一个宏任务：在所有微任务执行完毕后，才会执行下一个宏任务

### 浏览器进程与线程

<https://zhuanlan.zhihu.com/p/133239925>  
<br/>进程是资源分配和独立运行的基本单位，而线程是进程中的执行单元。

进程之间独立运行，线程共享进程的资源。

线程共享相同的地址空间，因此线程间的通信相对容易。

进程切换的开销较大，线程切换的开销相对较小。

进程之间需要通过进程间通信（IPC）来进行数据交换，线程之间可以直接访问共享的数据。

### 浏览器的多进程架构

1. 浏览器进程 要负责界面显示、用户交互、子进程管理，同时提供存储等功能
2. 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页
3. 插件进程： 网页使用的插件
4. GPU进程： 负责整个应用程序的GPU任务
5. 网络进程

优点： 安全 快速，容错性

### 渲染流程

****解析HTML构建DOM树****：

****解析CSS构建CSSOM树****：

****构建渲染树****：一旦DOM和CSSOM都准备好了，浏览器就会结合两者来构建渲染树。渲染树只包含可见的节点及其对应的样式信息，例如被设置了display: none;的元素不会出现在渲染树中

****布局（Layout/Reflow）****：在构建好渲染树之后，浏览器会计算每个可见元素的位置和尺寸，这个过程称为布局或重排。这决定了每个元素在视口内的确切位置。任何影响几何结构的变化都会触发重新布局 (**分层**)

****绘制（Painting）****：完成布局后，浏览器开始绘制，即填充每个元素的颜色、图像、边框等属性。这一阶段生成的是位图。值得注意的是，如果渲染树发生了改变，则渲染器会触发重绘（Repaint）和重排（Reflow），其中重排的成本通常比重绘要高得多

****光栅化（Rasterization）****：通过解析、布局和绘制过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。接下来，这些信息会被转换为屏幕上的像素，这个过程被称为光栅化。光栅化可以被GPU加速，光栅化后的位图会被存储在GPU内存中

****合成（Compositing）****：现代浏览器通常使用合成的方式，将页面的各个部分分成若干层，分别对其进行栅格化（将它们分割成了不同的瓦片）。然后，这些图层会在GPU上进行合成，最终显示在屏幕上

#### 重绘触发

****绘制（Painting）****：****光栅化（Rasterization）****：****合成（Compositing）****

#### 回流触发

****布局 绘制（Painting）****：****光栅化（Rasterization）****：****合成（Compositing）****

重绘和回流

<https://www.jianshu.com/p/e081f9aa03fb>

- 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。
- 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow）

### 浏览器的结构

用户界面

浏览器引擎

渲染引擎

Js 解释器

网络

用户界面后端

数据存储

<https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/>

## 缓存

### 1 浏览器缓存

#### 浏览器什么情况下会使用本地缓存

##### .首次访问后的重复请求

当用户首次访问一个网页时，浏览器会下载所有需要的资源（如HTML、CSS、JavaScript文件、图片等），并将它们存储到本地缓存中。如果这些资源被标记为可缓存，并且在后续页面加载或同一网站的不同页面中再次引用相同资源，浏览器将尝试从本地缓存中读取这些资源，而不是重新从服务器请求

##### ****遵循HTTP响应头部中的缓存指令****

服务器可以通过HTTP响应头部提供具体的缓存指示，指导浏览器如何处理和存储资源。常见的缓存控制头部包括：

- - Cache-Control：定义了资源的缓存策略，例如是否允许缓存、缓存的最大年龄（max-age）、是否必须验证缓存等。
    - Expires：指定了资源过期的具体日期和时间。
    - ETag 和 Last-Modified：用于条件请求，帮助浏览器判断缓存内容是否仍然有效。当浏览器发送带有 If-None-Match 或 If-Modified-Since 头部的请求时，服务器可以根据这些头部信息决定是返回304 Not Modified状态码还是完整的资源。

#### 强制缓存

<https://segmentfault.com/a/1190000040748678>  
<https://zhuanlan.zhihu.com/p/143064070>  
强制缓存就是直接从浏览器缓存查找该结果，并根据结果的缓存规则来决定是否使用该缓存的过程。

控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

##### Cache-Control

关于浏览器请求的缓存问题：浏览器发出请求的时候，会把请求的结果自动复制一份放到客户端本地，这就是浏览器缓存，当下次发出相同的url请求的时候，并且如果服务器端资源最后修改日期和本地缓存的资源最后修改日期相同，就会走本地资源（304），如果是动态生成的内容就会出问题（修改日期不变，内容已经发生变化），一般在请求的后面追加一个不重复值的参数就可以（版本号），一般都是当前时间，这样永远不会走本地缓存。

Cache-Control:

在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：

public：所有内容都将被缓存（客户端/代理服务器/CDN等）

private：只有客户端可以缓存，Cache-Control默认值

no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定

no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存

max-age=xxx：缓存将在xxx秒后失效

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，有服务器根据缓存标识决定是否使用缓存的过程 Last-Modified/If-Modified-Since

Etag/If-None-Match

判断是否使用缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

Last-Modified： 一个是资源最后的修改时间

弊端：时间以秒计时

如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改

ETag：一个是资源是否修改过。 要生成hash值 ，性能不够好，但是更精确  
Cache-Control  
no-cache: 需要使用对比缓存（Last-Modified/If-Modified-Since/Etag/If-None-Match）来验证缓存数据

no-store: 所有内容都不会缓存，强制缓存和对比缓存都不会触发

##### ETag

Etag值通常由服务器生成，并在响应头中返回给客户端。客户端在后续请求中通过 If-None-Match 头将 ETag 值发送回服务器，服务器根据 ETag 值判断资源是否已更改，从而决定是否返回新的内容或返回 304 Not Modified 状态码。

ETag 的生成算法没有严格的标准，不同的服务器和应用程序可以根据自己的需求选择合适的算法

****基于文件内容的哈希值****：

- 1. 计算文件内容的哈希值（如 MD5、SHA-1、SHA-256 等），并将哈希值作为 ETag。
  2. 优点：能够准确反映文件内容的变化。
  3. 缺点：计算哈希值可能会消耗较多资源。

****基于文件的最后修改时间****：

- 1. 使用文件的最后修改时间（通常格式化为字符串）作为 ETag。
  2. 优点：计算简单，资源消耗少。
  3. 缺点：不能精确反映文件内容的变化，如果文件内容变化但修改时间不变，ETag 也会不变。

****基于文件的大小和最后修改时间****：

- 1. 结合文件的大小和最后修改时间生成 ETag。
  2. 优点：比单独使用最后修改时间更准确。
  3. 缺点：仍然可能存在误判的情况。

****自定义算法****：

- 1. 根据具体需求设计自定义的 ETag 生成算法。
  2. 优点：灵活性高，可以针对特定场景优化。
  3. 缺点：需要更多的开发和测试工作。

### CDN缓存

CDN其全称是Content Delivery Network，即内容分发网络。CDN是构建在网络上的内容分发网络，具备内容存储和分发两个关键要素。其基本原理是广泛采用各种缓存服务器，  
<https://web.dev/content-delivery-networks/>

### Service woker

相比于localstorage和 sessionstorage

可以实现异步存储、静态资源存储、URL匹配、请求拦截等功能。

基于基于web worker，不能访问dom

可以拦截当前网站的所有请求，进行判断,如果需要像服务器发起请求就转给服务器，如果可以使用缓存就返回缓存，提高浏览体验。在 Service Worker 中，你可以监听 fetch 事件来拦截网络请求

如何判断是否使用缓存：  
1 一旦更新文件，通过计算hash值可以判断是否相同。

2 ，对资源进行版本控制

### 性能优化

<https://juejin.cn/post/6907212467122733070>

  

#### **1\. 加载优化（预加载，懒加载，滚动加载，分页加载）**

- ****按需加载****：根据用户的需求动态加载资源，避免一次性加载所有资源，从而减少初始加载时间。
- ****缓存策略****：利用浏览器缓存和服务器端缓存策略，减少资源的重复加载。 Service Worker
- ****请求合并****：通过合并多个请求为一个请求，减少HTTP请求的数量，从而加快加载速度。

API端点聚合可以通过创建一个中间层（通常称为API网关或代理服务）来实现，

**合并CSS和JavaScript文件**

#### **2\. JS优化**

- ****异步加载****：通过异步加载JavaScript文件，避免阻塞页面的渲染。
- ****减少回流和重绘****：优化JavaScript代码，减少不必要的DOM操作，从而减少回流（reflow）和重绘（repaint）。
- ****合并DOM操作****：将多个DOM操作合并为一次操作，减少浏览器的处理负担。
- webwoker 做复杂的运算

#### **3\. 资源优化**

。webpack 打包和压缩

#### **4\. 渲染优化**

- ****减少DOM数量和层级****：简化DOM结构，减少DOM节点的数量和层级，从而减少浏览器的处理负担。
- ****避免JS渲染动画****：使用CSS动画代替JavaScript动画，减少JavaScript的执行时间。
- ****高频操作节流防抖****：对高频操作（如滚动事件）使用节流（throttle）和防抖（debounce）技术，减少不必要的处理。

### 首屏页面加载很慢

### Hexo

首先安装Hexo：

npm install -g hexo-cli

hexo init blog

cd blog

npm install

你可以使用类似的主题，我推荐使用 hexo-theme-doc 或 hexo-theme-book，它们都能实现类似的文档风格。这里以 hexo-theme-doc 为例：

npm install --save hexo-theme-doc

gh-pages 是一个 npm 包，它的主要作用是简化将静态网站部署到 GitHub Pages 的过程。GitHub Pages 是 GitHub 提供的一项服务，允许用户直接从仓库的特定分支（通常是 gh-pages 或默认分支如 main/master）托管静态网页。gh-pages 包使得开发者能够轻松地将本地构建的静态文件推送到 GitHub 仓库的指定分支，从而实现自动化和便捷的部署流程。

### gh-pages

1创建或更新 GitHub Pages 分支:

如果目标分支（通常是 gh-pages）不存在，gh-pages 会自动创建它。

如果该分支已经存在，gh-pages 会更新这个分支的内容，用最新的构建结果替换旧内容。

2推送本地目录的内容:

可以指定一个本地目录作为源，gh-pages 会将该目录下的所有文件复制并推送到 GitHub 仓库的目标分支。这对于前端项目特别有用，因为它们通常有一个专门存放生产环境静态资源的输出目录（例如，通过 Webpack、Gulp 或 Next.js 等工具生成的 dist 或 out 文件夹）。

3支持自定义路径:

不仅可以推送整个目录，还可以配置推送特定路径下的文件，或者只推送满足某些模式匹配规则的文件。

4与 CI/CD 集成:

gh-pages 可以很容易地集成到持续集成/持续部署（CI/CD）管道中，比如在 Travis CI、CircleCI 或 GitHub Actions 中使用，确保每次代码更改后都能自动部署更新后的静态站点。

5处理子模块和复杂仓库结构:

支持更复杂的仓库结构，包括处理 Git 子模块的情况，这在大型项目或多仓库设置中非常有用。

6发布历史记录:

每次部署都会创建一个新的提交，并且可以包含描述性的提交信息，有助于追踪版本历史。

7清理远程分支:

还提供了选项来清理远程分支上的文件，确保只有最新的构建产物被保留在 GitHub Pages 上