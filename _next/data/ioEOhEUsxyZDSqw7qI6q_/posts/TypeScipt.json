{"pageProps":{"postData":{"id":"TypeScipt","contentHtml":"<h1>Typescript</h1>\n<h2 id=\"为什么推荐使用ts\">为什么推荐使用TS</h2>\n<p>主要是静态类型检测，更有利于构建大型项目</p>\n<h2 id=\"类型检查\">类型检查</h2>\n<p>// 在ts中，定义isFlag为true，为布尔类型boolean</p>\n<p>// 在变量名后加冒号和类型，如 :boolean</p>\n<p>let isFlag:boolean = true</p>\n<p>// 重新赋值到字符串类型会报错</p>\n<p>isFlag = \"hello swr\"</p>\n<p>任意类型any void类型</p>\n<h2 id=\"const\">Const</h2>\n<h3><strong>类型检查与安全性</strong></h3>\n<p>当使用 const 修饰变量时，编译器会执行更严格的类型检查，确保该变量在其生命周期内不会被意外修改</p>\n<h3>内联替换与优化</h3>\n<p>对于局部 const 变量，编译器通常不会为它们分配实际的内存空间，而是直接在编译时将它们替换为对应的值（即所谓的“常量折叠”），从而避免了运行时访问内存的操作，提高了执行速度 19。此外，由于 const 表达式的值是在编译期确定的，因此可以更容易地进行各种编译优化，如循环展开、函数内联等</p>\n<h2 id=\"元组类型tuple\">元组类型tuple</h2>\n<p>什么是元组类型？其实元组是数组的一种。</p>\n<p>表示已知元素数量和类型的数组</p>\n<p>let person:[string,number] = ['邵威儒',28]</p>\n<p>有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上，多了少了或者类型不对都会报错。</p>\n<p>元组类型是一个不可变的数组，长度、类型是不可变的。</p>\n<h2 id=\"枚举\">枚举</h2>\n<h3><strong>数字枚举</strong></h3>\n<h3><strong>字符串枚举</strong></h3>\n<h2 id=\"类\">类</h2>\n<p><strong>抽象类</strong></p>\n<p>如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错。</p>\n<p><strong>Public private protected修饰符</strong></p>\n<p><strong>private</strong>：</p>\n<ul>\n<li>\n<ul>\n<li>只能在声明它的类内部访问。\n<ul>\n<li>不能被子类继承或访问。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>protected</strong>：</p>\n<ul>\n<li>\n<ul>\n<li>可以在声明它的类及其子类中访问。\n<ul>\n<li>可以被子类继承和访问。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"接口\">接口</h2>\n<p><strong><strong>接口</strong></strong> 主要用于描述对象的形状，可以被实现或继承，适合用于描述数据模型或约定</p>\n<h2 id=\"interface-和-type-的区别\">interface 和 type 的区别</h2>\n<p>1定义</p>\n<p>type关键字可以定义一个集合，可以包含各种类型的属性和值，以用来描述对象、函数、联合类型、交叉类型等。</p>\n<p>interface： 它定义了一个对象的形状，描述了对象应该具有的属性及类型</p>\n<p>Interface只能表示 object、class、function 类型。</p>\n<p>type 还可以用来表示其他的类型，比如基本数据类型、联合类型、交叉类型等</p>\n<p>2写法</p>\n<p>type使用等号来定义类型别名，</p>\n<p>而interface使用花括号直接定义接口的成员。</p>\n<p>3声明合并</p>\n<p>type 不支持声明合并</p>\n<p>interface支持声明合并</p>\n<p>4 继承</p>\n<p>Interface支持继承<br>\ntype：可以通过 &#x26; 符号创建交叉类型，以组合现有的多种类型</p>\n<p>1 type和interface的定义</p>\n<p>type A = string; // 声明了一个类型别名A，同时它的类型等价于string类型</p>\n<p>type StatusCode = 200 | 301 | 400 | 500 | 502;</p>\n<p>type PossibleDataTypes = string | number | (() => unknown);</p>\n<p>联合类型（ | ）和交叉类型（&#x26;）</p>\n<p>Type 组合方式</p>\n<p>Interface 多次声明来合并声明</p>\n<p>Interface extend继承</p>\n<h2 id=\"泛型\">泛型</h2>\n<p>泛型可以理解为宽泛的类型，通常用于类和函数</p>\n<p>TypeScript 的泛型（Generics）是一种强大的工具，它允许开发者在定义函数、类或接口时使用类型参数，而不是具体的类型。</p>\n<p>一个组件可以支持多种类型的数据,为代码添加额外的抽象层和可重用性</p>\n<p>// T表示泛型，具体什么类型是调用这个方法的时候决定的。</p>\n<p>function getData&#x3C;T>(value:T):T{</p>\n<p>return value;</p>\n<p>}</p>\n<p>getData&#x3C;number>(123456);</p>\n<p>函数声明中的 &#x3C;T>:</p>\n<p>这是泛型类型的声明部分。它告诉 TypeScript 编译器，这个函数将会使用一个名为 T 的类型参数。T 可以代表任何类型，并且这个类型将在调用函数时由调用者提供或通过上下文推断出来。</p>\n<p>参数列表中的 value: T:</p>\n<p>在这里，T 指定了函数接受的参数 value 的类型。这意味着传入给 getData 函数的 value 参数可以是任意类型，但是一旦确定了这个类型，它在整个函数内部就只能是这种类型。例如，如果你传递了一个字符串，那么在这个函数的作用域内，T 就是 string 类型。</p>\n<p>返回值类型 : T:</p>\n<p>最后的 T 定义了函数的返回值类型。这表明 getData 函数将返回与输入参数 value 同一类型的值。因此，如果 value 是一个数字，则返回值也将是一个数字；如果 value 是一个对象，则返回值也是一个相同类型的对象。</p>\n<h2 id=\"类型断言\">类型断言</h2>\n<p>可以用来手动指定一个值具体的类型，即允许变量从一种类型更改为另一种类型。</p>\n<p>\"尖括号\" 语法：&#x3C;类型>值</p>\n<p>as 语法：值 as 类型</p>\n<p>let someValue: any = 'this is a string'</p>\n<p>let strLength: number = (someValue as string).length</p>\n<h2 id=\"配置tsconfigjson\">配置tsconfig.json</h2>\n<p>首先我们要生成一个tsconfig.json来告诉ts-loader怎样去编译这个ts代码</p>\n<p>tsc --init</p>\n<p>会在项目中生成了一个tsconfig.json文件，接下来进入这个文件，来修改相关配置</p>\n<p>// tsconfig.json</p>\n<p>{</p>\n<p>// 编译选项</p>\n<p>\"compilerOptions\": {</p>\n<p>\"target\": \"es5\", // 编译成es5语法</p>\n<p>\"module\": \"commonjs\", // 模块的类型</p>\n<p>\"outDir\": \"./dist\", // 编译后的文件目录</p>\n<p>\"sourceMap\": true, // 生成sourceMap方便我们在开发过程中调试</p>\n<p>\"noImplicitAny\": true, // 每个变量都要标明类型</p>\n<p>\"jsx\": \"react\", // jsx的版本,使用这个就不需要额外使用babel了，会编译成React.createElement</p>\n<p>},</p>\n<p>// 为了加快整个编译过程，我们指定相应的路径</p>\n<p>\"include\": [</p>\n<p>\"./src/**/*\"</p>\n<p>]</p>\n<p>}</p>\n<p>Constructor方法，类被实例化一次调用一次</p>\n<p>包含构造函数的派生类必须调用super()，它会执行基类的构造方法和其他方法。</p>\n<p>Protected成员在类的内部和子类可以调用</p>\n<p>接口声明的方法 应用的类必须调用<br>\n类型声明文件里面只有类型代码，没有具体的代码实现</p>\n<p>protected修饰符<br>\n除了能够在（deriving classes）派生类，也就是子类中访问到base class成员，其他的特性和private基本一致</p>\n<p>Void表示没有任何返回值的函数</p>\n<h2 id=\"数组的类型\">数组的类型</h2>\n<p>最简单的方法是使用[类型+方括号]表示法</p>\n<p>Let Fibonacci: number[] = [1,1,2,3,5]</p>\n<p>数组泛型表示数组</p>\n<p>Let Fibonacci: Array&#x3C;number> = [1,2,3]</p>\n<p>一个比较常见的做法是，用 any 表示数组中允许出现任意类型：</p>\n<p>let list: any[] = ['Xcat Liu', 25, { website: '<a href=\"http://xcatliu.com\">http://xcatliu.com</a>' }];</p>\n<h2 id=\"重载\">重载</h2>\n<p>允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>\n<p>比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。</p>\n<p>利用联合类型，我们可以这么实现：</p>\n<p>这时，我们可以使用重载定义多个 reverse 的函数类型：</p>\n<p>function reverse(x: number): number;</p>\n<p>function reverse(x: string): string;</p>\n<p>function reverse(x: number | string): number | string {</p>\n<p>if (typeof x === 'number') {</p>\n<p>return Number(x.toString().split('').reverse().join(''));</p>\n<p>} else if (typeof x === 'string') {</p>\n<p>return x.split('').reverse().join('');</p>\n<p>}</p>\n<p>}</p>\n<p>此时可以使用类型断言，将 something 断言成 string：<br>\nfunction getLength(something: string | number): number {<br>\nif ((&#x3C;string>something).length) {<br>\nreturn (&#x3C;string>something).length;<br>\n} else {<br>\nreturn something.toString().length;<br>\n}<br>\n}<br>\n<br/>类型断言的用法如上，在需要断言的变量前加上 &#x3C;Type> 即可。</p>\n<h2 id=\"重写\">重写</h2>\n<p>当父类和其<a href=\"https://so.csdn.net/so/search?q=%E6%B4%BE%E7%94%9F%E7%B1%BB&#x26;spm=1001.2101.3001.7020%22%20%5Ct%20%22https://blog.csdn.net/qq_24518001/article/details/_blank\">派生类</a>拥有同一个方法时，这种情况就是方法的重写</p>\n<h2 id=\"三斜线指令\">三斜线指令</h2>\n<p>管理模块之间的依赖关系</p>\n<p>引入库的类型定义</p>\n<p>三斜线指令以 /// &#x3C;reference ... /> 开头，放在文件的顶部。</p>\n<p>替代方案：在现代 TypeScript 项目中，通常使用 tsconfig.json 文件中的 types 和 lib 字段来管理类型定义，三斜线指令的使用频率逐渐减少。</p>\n<h2 id=\"mixin\">Mixin</h2>\n<p>由于TypeScrip中的类不支持多继承，所以引入了混合（Mixin）的特性，可以间接实现多继承的效果</p>\n<p>使用mixin</p>\n<p>概念</p>\n<p>首先，抽象类是不允许被实例化的：</p>\n<p>其次，抽象类中的抽象方法必须被子类实现：</p>\n<p>this参数在回调函数里</p>\n<p>“内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”</p>\n","h2Titles":[{"title":"为什么推荐使用TS","id":"为什么推荐使用ts"},{"title":"类型检查","id":"类型检查"},{"title":"Const","id":"const"},{"title":"元组类型tuple","id":"元组类型tuple"},{"title":"枚举","id":"枚举"},{"title":"类","id":"类"},{"title":"接口","id":"接口"},{"title":"interface 和 type 的区别","id":"interface-和-type-的区别"},{"title":"泛型","id":"泛型"},{"title":"类型断言","id":"类型断言"},{"title":"配置tsconfig.json","id":"配置tsconfigjson"},{"title":"数组的类型","id":"数组的类型"},{"title":"重载","id":"重载"},{"title":"重写","id":"重写"},{"title":"三斜线指令","id":"三斜线指令"},{"title":"Mixin","id":"mixin"}],"title":"Typescript","date":"2025-1-11","description":"Js的超集，面向对象的编程语言，包含类和接口的概念"},"allPostsData":[{"id":"前端基础","title":"前端基础","date":"2025-1-18","description":"内容包括一些前端的基础理论","h2Titles":[{"title":"HTML","id":"html"},{"title":"CSS3.0","id":"css30"},{"title":"CSS","id":"css"},{"title":"less和sass","id":"less和sass"},{"title":"Css","id":"css"},{"title":"Script","id":"script"},{"title":"Jquery","id":"jquery"},{"title":"HTML5","id":"html5"},{"title":"BootStrap","id":"bootstrap"},{"title":"三层架构","id":"三层架构"},{"title":"MVC","id":"mvc"},{"title":"AngularJS","id":"angularjs"},{"title":"跨域请求","id":"跨域请求"},{"title":"D3","id":"d3"},{"title":"JS","id":"js"},{"title":"Aurelia","id":"aurelia"},{"title":"ES6","id":"es6"},{"title":".NET","id":"net"},{"title":"Webpack","id":"webpack"},{"title":"C#","id":"c"},{"title":"Webpack 配置","id":"webpack-配置"},{"title":"Gulp","id":"gulp"},{"title":"协议","id":"协议"},{"title":"网络安全","id":"网络安全"},{"title":"JS函数式编程","id":"js函数式编程"},{"title":"代码简洁","id":"代码简洁"},{"title":"前端单元测试","id":"前端单元测试"},{"title":"SSR","id":"ssr"},{"title":"SPA","id":"spa"},{"title":"模式","id":"模式"},{"title":"数据结构","id":"数据结构"},{"title":"Git命令","id":"git命令"},{"title":"使用 PRPL 模式应用即时加载","id":"使用-prpl-模式应用即时加载"},{"title":"面向对象","id":"面向对象"},{"title":"Animation","id":"animation"},{"title":"Flex布局","id":"flex布局"},{"title":"Flutter","id":"flutter"},{"title":"JSBridge","id":"jsbridge"},{"title":"Serverless","id":"serverless"},{"title":"精读前后端渲染之争","id":"精读前后端渲染之争"},{"title":"事件驱动和数据驱动","id":"事件驱动和数据驱动"},{"title":"IndexDB 实践","id":"indexdb-实践"},{"title":"Blob","id":"blob"},{"title":"Docker","id":"docker"},{"title":"Responsive/images","id":"responsiveimages"},{"title":"Rem/em","id":"remem"},{"title":"Learnsite","id":"learnsite"},{"title":"LeetCode","id":"leetcode"},{"title":"SQL","id":"sql"},{"title":"Express","id":"express"},{"title":"MySQL","id":"mysql"},{"title":"代理服务器","id":"代理服务器"},{"title":"解释性语言和编译型语言","id":"解释性语言和编译型语言"},{"title":"空间复杂度和时间复杂度","id":"空间复杂度和时间复杂度"},{"title":"Electron","id":"electron"},{"title":"可视化","id":"可视化"},{"title":"编程","id":"编程"},{"title":"计算机基础","id":"计算机基础"},{"title":"缓存","id":"缓存"}]},{"id":"TypeScipt","title":"Typescript","date":"2025-1-11","description":"Js的超集，面向对象的编程语言，包含类和接口的概念","h2Titles":[{"title":"为什么推荐使用TS","id":"为什么推荐使用ts"},{"title":"类型检查","id":"类型检查"},{"title":"Const","id":"const"},{"title":"元组类型tuple","id":"元组类型tuple"},{"title":"枚举","id":"枚举"},{"title":"类","id":"类"},{"title":"接口","id":"接口"},{"title":"interface 和 type 的区别","id":"interface-和-type-的区别"},{"title":"泛型","id":"泛型"},{"title":"类型断言","id":"类型断言"},{"title":"配置tsconfig.json","id":"配置tsconfigjson"},{"title":"数组的类型","id":"数组的类型"},{"title":"重载","id":"重载"},{"title":"重写","id":"重写"},{"title":"三斜线指令","id":"三斜线指令"},{"title":"Mixin","id":"mixin"}]},{"id":"React","title":"React","date":"2025-1-10","description":"","h2Titles":[{"title":"基本写法","id":"基本写法"},{"title":"Dom diff","id":"dom-diff"},{"title":"React 特点","id":"react-特点"},{"title":"虚拟 dom 和真实 dom","id":"虚拟-dom-和真实-dom"},{"title":"组件","id":"组件"},{"title":"元素","id":"元素"},{"title":"生命周期","id":"生命周期"},{"title":"ReactDOM","id":"reactdom"},{"title":"ReactDOMServer","id":"reactdomserver"},{"title":"ReactTestUtils","id":"reacttestutils"},{"title":"Hook","id":"hook"},{"title":"Redux","id":"redux"},{"title":"问题","id":"问题"},{"title":"Fiber","id":"fiber"},{"title":"useImperativeHandle","id":"useimperativehandle"},{"title":"BrowserRouter 和 HashRouter","id":"browserrouter-和-hashrouter"},{"title":"React 服务端渲染（Server-Side Rendering, SSR）","id":"react-服务端渲染server-side-rendering-ssr"},{"title":"Next.js 服务端渲染的基本步骤","id":"nextjs-服务端渲染的基本步骤"},{"title":"Navigate","id":"navigate"},{"title":"搭建步骤","id":"搭建步骤"},{"title":"React","id":"react"}]},{"id":"Angular","title":"Angular","date":"2025-1-10","description":"Angular 是一个 Web 框架，能够帮助开发者构建快速、可靠的应用。","h2Titles":[{"title":"模块","id":"模块"},{"title":"数据传输","id":"数据传输"},{"title":"装饰器 decorator","id":"装饰器-decorator"},{"title":"依赖注入（Dependency Injection, DI）模式","id":"依赖注入dependency-injection-di模式"},{"title":"providedIn: 'root'","id":"providedin-root"},{"title":"设计模式","id":"设计模式"},{"title":"路由","id":"路由"},{"title":"EventEmitter","id":"eventemitter"},{"title":"视图封装（View Encapsulation）","id":"视图封装view-encapsulation"},{"title":"变更检测","id":"变更检测"},{"title":"app.module.ts根模块文件","id":"appmodulets根模块文件"},{"title":"Angular CDK","id":"angular-cdk"},{"title":"Angular 指令","id":"angular-指令"},{"title":"应用启动时执行初始化逻辑","id":"应用启动时执行初始化逻辑"},{"title":"注册拦截器","id":"注册拦截器"},{"title":"HttpClient","id":"httpclient"},{"title":"国际化","id":"国际化"},{"title":"@ngmodule","id":"ngmodule"},{"title":"Angular CDK","id":"angular-cdk"},{"title":"Reactive Forms","id":"reactive-forms"},{"title":"项目结构","id":"项目结构"},{"title":"常见用法","id":"常见用法"},{"title":"@Optional() @SkipSelf()","id":"optional-skipself"},{"title":"Rxjs","id":"rxjs"}]},{"id":"算法相关","title":"算法","date":"2024-10-10","description":"这里会总结算法相关的内容","h2Titles":[{"title":"每五秒打印一个数字","id":"每五秒打印一个数字"},{"title":"async 函数的实现","id":"async-函数的实现"},{"title":"输入一个promise和一个时间","id":"输入一个promise和一个时间"},{"title":"实现promise.all","id":"实现promiseall"},{"title":"虚拟dom 转换成真实dom","id":"虚拟dom-转换成真实dom"},{"title":"加密算法","id":"加密算法"}]},{"id":"Node","title":"Node","date":"2024-03-14","description":"Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，用于在服务器端运行 JavaScript 代码。","h2Titles":[{"title":"Express","id":"express"},{"title":"Communication","id":"communication"},{"title":"I/O","id":"io"},{"title":"Synchronous and Asynchronous","id":"synchronous-and-asynchronous"},{"title":"Eventloop","id":"eventloop"},{"title":"V8","id":"v8"},{"title":"FS","id":"fs"},{"title":"Script","id":"script"},{"title":"HTTP","id":"http"},{"title":"mongoDB","id":"mongodb"},{"title":"Template engine","id":"template-engine"},{"title":"JWT","id":"jwt"},{"title":"Passport.js","id":"passportjs"},{"title":"OAuth","id":"oauth"},{"title":"Node API retry","id":"node-api-retry"},{"title":"Others","id":"others"}]}]},"__N_SSG":true}